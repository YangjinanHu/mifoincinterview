{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Parser = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst solidity_files_cache_1 = require(\"../../builtin-tasks/utils/solidity-files-cache\");\n\nconst log = (0, debug_1.default)(\"hardhat:core:solidity:imports\");\n\nclass Parser {\n  constructor(_solidityFilesCache) {\n    this._cache = new Map();\n    this._solidityFilesCache = _solidityFilesCache !== null && _solidityFilesCache !== void 0 ? _solidityFilesCache : solidity_files_cache_1.SolidityFilesCache.createEmpty();\n  }\n\n  parse(fileContent, absolutePath, contentHash) {\n    const cacheResult = this._getFromCache(absolutePath, contentHash);\n\n    if (cacheResult !== null) {\n      return cacheResult;\n    }\n\n    let result;\n\n    try {\n      const parser = require(\"@solidity-parser/parser\");\n\n      const ast = parser.parse(fileContent, {\n        tolerant: true\n      });\n      const imports = [];\n      const versionPragmas = [];\n      parser.visit(ast, {\n        ImportDirective: node => imports.push(node.path),\n        PragmaDirective: node => {\n          if (node.name === \"solidity\") {\n            versionPragmas.push(node.value);\n          }\n        }\n      });\n      result = {\n        imports,\n        versionPragmas\n      };\n    } catch (error) {\n      log(\"Failed to parse Solidity file to extract its imports, using regex fallback\\n\", error);\n      result = {\n        imports: findImportsWithRegexps(fileContent),\n        versionPragmas: findVersionPragmasWithRegexps(fileContent)\n      };\n    }\n\n    this._cache.set(contentHash, result);\n\n    return result;\n  }\n  /**\n   * Get parsed data from the internal cache, or from the solidity files cache.\n   *\n   * Returns null if cannot find it in either one.\n   */\n\n\n  _getFromCache(absolutePath, contentHash) {\n    const internalCacheEntry = this._cache.get(contentHash);\n\n    if (internalCacheEntry !== undefined) {\n      return internalCacheEntry;\n    }\n\n    const solidityFilesCacheEntry = this._solidityFilesCache.getEntry(absolutePath);\n\n    if (solidityFilesCacheEntry === undefined) {\n      return null;\n    }\n\n    const {\n      imports,\n      versionPragmas\n    } = solidityFilesCacheEntry;\n\n    if (solidityFilesCacheEntry.contentHash !== contentHash) {\n      return null;\n    }\n\n    return {\n      imports,\n      versionPragmas\n    };\n  }\n\n}\n\nexports.Parser = Parser;\n\nfunction findImportsWithRegexps(fileContent) {\n  const importsRegexp = /import\\s+(?:(?:\"([^;]*)\"|'([^;]*)')(?:;|\\s+as\\s+[^;]*;)|.+from\\s+(?:\"(.*)\"|'(.*)');)/g;\n  let imports = [];\n  let result;\n\n  while (true) {\n    result = importsRegexp.exec(fileContent);\n\n    if (result === null) {\n      return imports;\n    }\n\n    imports = [...imports, ...result.slice(1).filter(m => m !== undefined)];\n  }\n}\n\nfunction findVersionPragmasWithRegexps(fileContent) {\n  const versionPragmasRegexp = /pragma\\s+solidity\\s+(.+?);/g;\n  let versionPragmas = [];\n  let result;\n\n  while (true) {\n    result = versionPragmasRegexp.exec(fileContent);\n\n    if (result === null) {\n      return versionPragmas;\n    }\n\n    versionPragmas = [...versionPragmas, ...result.slice(1).filter(m => m !== undefined)];\n  }\n}","map":{"version":3,"mappings":"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","names":["log","Parser","constructor","_solidityFilesCache","Map","solidity_files_cache_1","createEmpty","parse","fileContent","absolutePath","contentHash","cacheResult","_getFromCache","result","parser","require","ast","tolerant","imports","versionPragmas","visit","ImportDirective","node","push","path","PragmaDirective","name","value","error","findImportsWithRegexps","findVersionPragmasWithRegexps","_cache","set","internalCacheEntry","get","undefined","solidityFilesCacheEntry","getEntry","exports","importsRegexp","exec","slice","filter","m","versionPragmasRegexp"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/internal/solidity/parse.ts"],"sourcesContent":["import debug from \"debug\";\n\nimport { SolidityFilesCache } from \"../../builtin-tasks/utils/solidity-files-cache\";\n\nconst log = debug(\"hardhat:core:solidity:imports\");\n\ninterface ParsedData {\n  imports: string[];\n  versionPragmas: string[];\n}\n\nexport class Parser {\n  private _cache = new Map<string, ParsedData>();\n  private _solidityFilesCache: SolidityFilesCache;\n\n  constructor(_solidityFilesCache?: SolidityFilesCache) {\n    this._solidityFilesCache =\n      _solidityFilesCache ?? SolidityFilesCache.createEmpty();\n  }\n\n  public parse(\n    fileContent: string,\n    absolutePath: string,\n    contentHash: string\n  ): ParsedData {\n    const cacheResult = this._getFromCache(absolutePath, contentHash);\n\n    if (cacheResult !== null) {\n      return cacheResult;\n    }\n\n    let result;\n    try {\n      const parser = require(\"@solidity-parser/parser\");\n      const ast = parser.parse(fileContent, { tolerant: true });\n\n      const imports: string[] = [];\n      const versionPragmas: string[] = [];\n\n      parser.visit(ast, {\n        ImportDirective: (node: { path: string }) => imports.push(node.path),\n        PragmaDirective: (node: { name: string; value: string }) => {\n          if (node.name === \"solidity\") {\n            versionPragmas.push(node.value);\n          }\n        },\n      });\n\n      result = { imports, versionPragmas };\n    } catch (error) {\n      log(\n        \"Failed to parse Solidity file to extract its imports, using regex fallback\\n\",\n        error\n      );\n      result = {\n        imports: findImportsWithRegexps(fileContent),\n        versionPragmas: findVersionPragmasWithRegexps(fileContent),\n      };\n    }\n\n    this._cache.set(contentHash, result);\n\n    return result;\n  }\n\n  /**\n   * Get parsed data from the internal cache, or from the solidity files cache.\n   *\n   * Returns null if cannot find it in either one.\n   */\n  private _getFromCache(\n    absolutePath: string,\n    contentHash: string\n  ): ParsedData | null {\n    const internalCacheEntry = this._cache.get(contentHash);\n\n    if (internalCacheEntry !== undefined) {\n      return internalCacheEntry;\n    }\n\n    const solidityFilesCacheEntry =\n      this._solidityFilesCache.getEntry(absolutePath);\n\n    if (solidityFilesCacheEntry === undefined) {\n      return null;\n    }\n\n    const { imports, versionPragmas } = solidityFilesCacheEntry;\n\n    if (solidityFilesCacheEntry.contentHash !== contentHash) {\n      return null;\n    }\n\n    return { imports, versionPragmas };\n  }\n}\n\nfunction findImportsWithRegexps(fileContent: string): string[] {\n  const importsRegexp: RegExp =\n    /import\\s+(?:(?:\"([^;]*)\"|'([^;]*)')(?:;|\\s+as\\s+[^;]*;)|.+from\\s+(?:\"(.*)\"|'(.*)');)/g;\n\n  let imports: string[] = [];\n  let result: RegExpExecArray | null;\n\n  while (true) {\n    result = importsRegexp.exec(fileContent);\n    if (result === null) {\n      return imports;\n    }\n\n    imports = [\n      ...imports,\n      ...result.slice(1).filter((m: any) => m !== undefined),\n    ];\n  }\n}\n\nfunction findVersionPragmasWithRegexps(fileContent: string): string[] {\n  const versionPragmasRegexp: RegExp = /pragma\\s+solidity\\s+(.+?);/g;\n\n  let versionPragmas: string[] = [];\n  let result: RegExpExecArray | null;\n\n  while (true) {\n    result = versionPragmasRegexp.exec(fileContent);\n    if (result === null) {\n      return versionPragmas;\n    }\n\n    versionPragmas = [\n      ...versionPragmas,\n      ...result.slice(1).filter((m: any) => m !== undefined),\n    ];\n  }\n}\n"]},"metadata":{},"sourceType":"script"}