{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbiHelpers = void 0;\n\nconst abi = __importStar(require(\"@ethersproject/abi\"));\n\nclass AbiHelpers {\n  /**\n   * Try to compute the selector for the function/event/error\n   * with the given name and param types. Return undefined\n   * if it cannot do it. This can happen if some ParamType is\n   * not understood by @ethersproject/abi\n   */\n  static computeSelector(name, inputs) {\n    try {\n      const fragment = abi.FunctionFragment.from({\n        type: \"function\",\n        constant: true,\n        name,\n        inputs: inputs.map(i => abi.ParamType.from(i))\n      });\n      const selectorHex = abi.Interface.getSighash(fragment);\n      return Buffer.from(selectorHex.slice(2), \"hex\");\n    } catch (_a) {\n      return;\n    }\n  }\n\n  static formatValues(values) {\n    return values.map(x => AbiHelpers._formatValue(x)).join(\", \");\n  }\n\n  static _formatValue(value) {\n    // print nested values as [value1, value2, ...]\n    if (Array.isArray(value)) {\n      return `[${value.map(v => AbiHelpers._formatValue(v)).join(\", \")}]`;\n    } // surround string values with quotes\n\n\n    if (typeof value === \"string\") {\n      return `\"${value}\"`;\n    }\n\n    return value.toString();\n  }\n\n}\n\nexports.AbiHelpers = AbiHelpers;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AAEA,MAAaA,UAAb,CAAuB;AACrB;;;;;;AAM6B,SAAfC,eAAe,CAC3BC,IAD2B,EAE3BC,MAF2B,EAEd;AAEb,QAAI;AACF,YAAMC,QAAQ,GAAGC,GAAG,CAACC,gBAAJ,CAAqBC,IAArB,CAA0B;AACzCC,YAAI,EAAE,UADmC;AAEzCC,gBAAQ,EAAE,IAF+B;AAGzCP,YAHyC;AAIzCC,cAAM,EAAEA,MAAM,CAACO,GAAP,CAAYC,CAAD,IAAON,GAAG,CAACO,SAAJ,CAAcL,IAAd,CAAmBI,CAAnB,CAAlB;AAJiC,OAA1B,CAAjB;AAMA,YAAME,WAAW,GAAGR,GAAG,CAACS,SAAJ,CAAcC,UAAd,CAAyBX,QAAzB,CAApB;AAEA,aAAOY,MAAM,CAACT,IAAP,CAAYM,WAAW,CAACI,KAAZ,CAAkB,CAAlB,CAAZ,EAAkC,KAAlC,CAAP;AACD,KAVD,CAUE,WAAM;AACN;AACD;AACF;;AAEyB,SAAZC,YAAY,CAACC,MAAD,EAAc;AACtC,WAAOA,MAAM,CAACT,GAAP,CAAYU,CAAD,IAAOpB,UAAU,CAACqB,YAAX,CAAwBD,CAAxB,CAAlB,EAA8CE,IAA9C,CAAmD,IAAnD,CAAP;AACD;;AAE0B,SAAZD,YAAY,CAACE,KAAD,EAAW;AACpC;AACA,QAAIC,KAAK,CAACC,OAAN,CAAcF,KAAd,CAAJ,EAA0B;AACxB,aAAO,IAAIA,KAAK,CAACb,GAAN,CAAWgB,CAAD,IAAO1B,UAAU,CAACqB,YAAX,CAAwBK,CAAxB,CAAjB,EAA6CJ,IAA7C,CAAkD,IAAlD,CAAuD,GAAlE;AACD,KAJmC,CAMpC;;;AACA,QAAI,OAAOC,KAAP,KAAiB,QAArB,EAA+B;AAC7B,aAAO,IAAIA,KAAK,GAAhB;AACD;;AAED,WAAOA,KAAK,CAACI,QAAN,EAAP;AACD;;AA1CoB;;AAAvBC","names":["AbiHelpers","computeSelector","name","inputs","fragment","abi","FunctionFragment","from","type","constant","map","i","ParamType","selectorHex","Interface","getSighash","Buffer","slice","formatValues","values","x","_formatValue","join","value","Array","isArray","v","toString","exports"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/internal/util/abi-helpers.ts"],"sourcesContent":["import * as abi from \"@ethersproject/abi\";\n\nexport class AbiHelpers {\n  /**\n   * Try to compute the selector for the function/event/error\n   * with the given name and param types. Return undefined\n   * if it cannot do it. This can happen if some ParamType is\n   * not understood by @ethersproject/abi\n   */\n  public static computeSelector(\n    name: string,\n    inputs: any[]\n  ): Buffer | undefined {\n    try {\n      const fragment = abi.FunctionFragment.from({\n        type: \"function\",\n        constant: true,\n        name,\n        inputs: inputs.map((i) => abi.ParamType.from(i)),\n      });\n      const selectorHex = abi.Interface.getSighash(fragment);\n\n      return Buffer.from(selectorHex.slice(2), \"hex\");\n    } catch {\n      return;\n    }\n  }\n\n  public static formatValues(values: any[]): string {\n    return values.map((x) => AbiHelpers._formatValue(x)).join(\", \");\n  }\n\n  private static _formatValue(value: any): string {\n    // print nested values as [value1, value2, ...]\n    if (Array.isArray(value)) {\n      return `[${value.map((v) => AbiHelpers._formatValue(v)).join(\", \")}]`;\n    }\n\n    // surround string values with quotes\n    if (typeof value === \"string\") {\n      return `\"${value}\"`;\n    }\n\n    return value.toString();\n  }\n}\n"]},"metadata":{},"sourceType":"script"}