{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.any = exports.json = exports.inputFile = exports.float = exports.int = exports.boolean = exports.string = void 0;\n\nconst fs = __importStar(require(\"fs\"));\n\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\n\nconst errors_1 = require(\"../errors\");\n\nconst errors_list_1 = require(\"../errors-list\");\n/**\n * String type.\n *\n * Accepts any kind of string.\n */\n\n\nexports.string = {\n  name: \"string\",\n  parse: (argName, strValue) => strValue,\n\n  /**\n   * Check if argument value is of type \"string\"\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"string\"\n   */\n  validate: (argName, value) => {\n    const isString = typeof value === \"string\";\n\n    if (!isString) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: exports.string.name\n      });\n    }\n  }\n};\n/**\n * Boolean type.\n *\n * Accepts only 'true' or 'false' (case-insensitive).\n * @throws HH301\n */\n\nexports.boolean = {\n  name: \"boolean\",\n  parse: (argName, strValue) => {\n    if (strValue.toLowerCase() === \"true\") {\n      return true;\n    }\n\n    if (strValue.toLowerCase() === \"false\") {\n      return false;\n    }\n\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n      value: strValue,\n      name: argName,\n      type: \"boolean\"\n    });\n  },\n\n  /**\n   * Check if argument value is of type \"boolean\"\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"boolean\"\n   */\n  validate: (argName, value) => {\n    const isBoolean = typeof value === \"boolean\";\n\n    if (!isBoolean) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: exports.boolean.name\n      });\n    }\n  }\n};\n/**\n * Int type.\n * Accepts either a decimal string integer or hexadecimal string integer.\n * @throws HH301\n */\n\nexports.int = {\n  name: \"int\",\n  parse: (argName, strValue) => {\n    const decimalPattern = /^\\d+(?:[eE]\\d+)?$/;\n    const hexPattern = /^0[xX][\\dABCDEabcde]+$/;\n\n    if (strValue.match(decimalPattern) === null && strValue.match(hexPattern) === null) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value: strValue,\n        name: argName,\n        type: exports.int.name\n      });\n    }\n\n    return Number(strValue);\n  },\n\n  /**\n   * Check if argument value is of type \"int\"\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"int\"\n   */\n  validate: (argName, value) => {\n    const isInt = Number.isInteger(value);\n\n    if (!isInt) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: exports.int.name\n      });\n    }\n  }\n};\n/**\n * Float type.\n * Accepts either a decimal string number or hexadecimal string number.\n * @throws HH301\n */\n\nexports.float = {\n  name: \"float\",\n  parse: (argName, strValue) => {\n    const decimalPattern = /^(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE]\\d+)?$/;\n    const hexPattern = /^0[xX][\\dABCDEabcde]+$/;\n\n    if (strValue.match(decimalPattern) === null && strValue.match(hexPattern) === null) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value: strValue,\n        name: argName,\n        type: exports.float.name\n      });\n    }\n\n    return Number(strValue);\n  },\n\n  /**\n   * Check if argument value is of type \"float\".\n   * Both decimal and integer number values are valid.\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"number\"\n   */\n  validate: (argName, value) => {\n    const isFloatOrInteger = typeof value === \"number\" && !isNaN(value);\n\n    if (!isFloatOrInteger) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: exports.float.name\n      });\n    }\n  }\n};\n/**\n * Input file type.\n * Accepts a path to a readable file..\n * @throws HH302\n */\n\nexports.inputFile = {\n  name: \"inputFile\",\n\n  parse(argName, strValue) {\n    try {\n      fs.accessSync(strValue, fs_extra_1.default.constants.R_OK);\n      const stats = fs.lstatSync(strValue);\n\n      if (stats.isDirectory()) {\n        // This is caught and encapsulated in a hardhat error.\n        // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n        throw new Error(`${strValue} is a directory, not a file`);\n      }\n    } catch (error) {\n      if (error instanceof Error) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_INPUT_FILE, {\n          name: argName,\n          value: strValue\n        }, error);\n      } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n      throw error;\n    }\n\n    return strValue;\n  },\n\n  /**\n   * Check if argument value is of type \"inputFile\"\n   * File string validation succeeds if it can be parsed, ie. is a valid accessible file dir\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"inputFile\"\n   */\n  validate: (argName, value) => {\n    try {\n      exports.inputFile.parse(argName, value);\n    } catch (error) {\n      // the input value is considered invalid, throw error.\n      if (error instanceof Error) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n          value,\n          name: argName,\n          type: exports.inputFile.name\n        }, error);\n      } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n      throw error;\n    }\n  }\n};\nexports.json = {\n  name: \"json\",\n\n  parse(argName, strValue) {\n    try {\n      return JSON.parse(strValue);\n    } catch (error) {\n      if (error instanceof Error) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_JSON_ARGUMENT, {\n          param: argName,\n          error: error.message\n        }, error);\n      } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n      throw error;\n    }\n  },\n\n  /**\n   * Check if argument value is of type \"json\". We consider everything except\n   * undefined to be json.\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"json\"\n   */\n  validate: (argName, value) => {\n    if (value === undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: exports.json.name\n      });\n    }\n  }\n};\nexports.any = {\n  name: \"any\",\n\n  validate(_argName, _argumentValue) {}\n\n};","map":{"version":3,"mappings":"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","names":["exports","name","parse","argName","strValue","validate","value","isString","errors_1","errors_list_1","ARGUMENTS","INVALID_VALUE_FOR_TYPE","type","toLowerCase","isBoolean","decimalPattern","hexPattern","match","Number","isInt","isInteger","isFloatOrInteger","isNaN","fs","accessSync","fs_extra_1","constants","R_OK","stats","lstatSync","isDirectory","Error","error","INVALID_INPUT_FILE","JSON","INVALID_JSON_ARGUMENT","param","message","undefined","_argName","_argumentValue"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/internal/core/params/argumentTypes.ts"],"sourcesContent":["import * as fs from \"fs\";\nimport fsExtra from \"fs-extra\";\n\nimport { ArgumentType, CLIArgumentType } from \"../../../types\";\nimport { HardhatError } from \"../errors\";\nimport { ERRORS } from \"../errors-list\";\n\n/**\n * String type.\n *\n * Accepts any kind of string.\n */\nexport const string: CLIArgumentType<string> = {\n  name: \"string\",\n  parse: (argName, strValue) => strValue,\n  /**\n   * Check if argument value is of type \"string\"\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"string\"\n   */\n  validate: (argName: string, value: any): void => {\n    const isString = typeof value === \"string\";\n\n    if (!isString) {\n      throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: string.name,\n      });\n    }\n  },\n};\n\n/**\n * Boolean type.\n *\n * Accepts only 'true' or 'false' (case-insensitive).\n * @throws HH301\n */\nexport const boolean: CLIArgumentType<boolean> = {\n  name: \"boolean\",\n  parse: (argName, strValue) => {\n    if (strValue.toLowerCase() === \"true\") {\n      return true;\n    }\n    if (strValue.toLowerCase() === \"false\") {\n      return false;\n    }\n\n    throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n      value: strValue,\n      name: argName,\n      type: \"boolean\",\n    });\n  },\n  /**\n   * Check if argument value is of type \"boolean\"\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"boolean\"\n   */\n  validate: (argName: string, value: any): void => {\n    const isBoolean = typeof value === \"boolean\";\n\n    if (!isBoolean) {\n      throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: boolean.name,\n      });\n    }\n  },\n};\n\n/**\n * Int type.\n * Accepts either a decimal string integer or hexadecimal string integer.\n * @throws HH301\n */\nexport const int: CLIArgumentType<number> = {\n  name: \"int\",\n  parse: (argName, strValue) => {\n    const decimalPattern = /^\\d+(?:[eE]\\d+)?$/;\n    const hexPattern = /^0[xX][\\dABCDEabcde]+$/;\n\n    if (\n      strValue.match(decimalPattern) === null &&\n      strValue.match(hexPattern) === null\n    ) {\n      throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value: strValue,\n        name: argName,\n        type: int.name,\n      });\n    }\n\n    return Number(strValue);\n  },\n  /**\n   * Check if argument value is of type \"int\"\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"int\"\n   */\n  validate: (argName: string, value: any): void => {\n    const isInt = Number.isInteger(value);\n    if (!isInt) {\n      throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: int.name,\n      });\n    }\n  },\n};\n\n/**\n * Float type.\n * Accepts either a decimal string number or hexadecimal string number.\n * @throws HH301\n */\nexport const float: CLIArgumentType<number> = {\n  name: \"float\",\n  parse: (argName, strValue) => {\n    const decimalPattern = /^(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE]\\d+)?$/;\n    const hexPattern = /^0[xX][\\dABCDEabcde]+$/;\n\n    if (\n      strValue.match(decimalPattern) === null &&\n      strValue.match(hexPattern) === null\n    ) {\n      throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value: strValue,\n        name: argName,\n        type: float.name,\n      });\n    }\n\n    return Number(strValue);\n  },\n  /**\n   * Check if argument value is of type \"float\".\n   * Both decimal and integer number values are valid.\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"number\"\n   */\n  validate: (argName: string, value: any): void => {\n    const isFloatOrInteger = typeof value === \"number\" && !isNaN(value);\n\n    if (!isFloatOrInteger) {\n      throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: float.name,\n      });\n    }\n  },\n};\n\n/**\n * Input file type.\n * Accepts a path to a readable file..\n * @throws HH302\n */\nexport const inputFile: CLIArgumentType<string> = {\n  name: \"inputFile\",\n  parse(argName: string, strValue: string): string {\n    try {\n      fs.accessSync(strValue, fsExtra.constants.R_OK);\n      const stats = fs.lstatSync(strValue);\n\n      if (stats.isDirectory()) {\n        // This is caught and encapsulated in a hardhat error.\n        // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n        throw new Error(`${strValue} is a directory, not a file`);\n      }\n    } catch (error) {\n      if (error instanceof Error) {\n        throw new HardhatError(\n          ERRORS.ARGUMENTS.INVALID_INPUT_FILE,\n          {\n            name: argName,\n            value: strValue,\n          },\n          error\n        );\n      }\n\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n\n    return strValue;\n  },\n\n  /**\n   * Check if argument value is of type \"inputFile\"\n   * File string validation succeeds if it can be parsed, ie. is a valid accessible file dir\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"inputFile\"\n   */\n  validate: (argName: string, value: any): void => {\n    try {\n      inputFile.parse(argName, value);\n    } catch (error) {\n      // the input value is considered invalid, throw error.\n      if (error instanceof Error) {\n        throw new HardhatError(\n          ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE,\n          {\n            value,\n            name: argName,\n            type: inputFile.name,\n          },\n          error\n        );\n      }\n\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n  },\n};\n\nexport const json: CLIArgumentType<any> = {\n  name: \"json\",\n  parse(argName: string, strValue: string): any {\n    try {\n      return JSON.parse(strValue);\n    } catch (error) {\n      if (error instanceof Error) {\n        throw new HardhatError(\n          ERRORS.ARGUMENTS.INVALID_JSON_ARGUMENT,\n          {\n            param: argName,\n            error: error.message,\n          },\n          error\n        );\n      }\n\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n  },\n\n  /**\n   * Check if argument value is of type \"json\". We consider everything except\n   * undefined to be json.\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"json\"\n   */\n  validate: (argName: string, value: any): void => {\n    if (value === undefined) {\n      throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: json.name,\n      });\n    }\n  },\n};\n\nexport const any: ArgumentType<any> = {\n  name: \"any\",\n  validate(_argName: string, _argumentValue: any) {},\n};\n"]},"metadata":{},"sourceType":"script"}