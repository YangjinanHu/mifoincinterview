{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveProjectPaths = exports.resolveConfig = void 0;\n\nconst ethereumjs_util_1 = require(\"ethereumjs-util\");\n\nconst fs = __importStar(require(\"fs\"));\n\nconst cloneDeep_1 = __importDefault(require(\"lodash/cloneDeep\"));\n\nconst path_1 = __importDefault(require(\"path\"));\n\nconst constants_1 = require(\"../../constants\");\n\nconst lang_1 = require(\"../../util/lang\");\n\nconst errors_1 = require(\"../errors\");\n\nconst default_config_1 = require(\"./default-config\");\n/**\n * This functions resolves the hardhat config, setting its defaults and\n * normalizing its types if necessary.\n *\n * @param userConfigPath the user config filepath\n * @param userConfig     the user config object\n *\n * @returns the resolved config\n */\n\n\nfunction resolveConfig(userConfigPath, userConfig) {\n  var _a;\n\n  userConfig = (0, cloneDeep_1.default)(userConfig);\n  return Object.assign(Object.assign({}, userConfig), {\n    defaultNetwork: (_a = userConfig.defaultNetwork) !== null && _a !== void 0 ? _a : default_config_1.defaultDefaultNetwork,\n    paths: resolveProjectPaths(userConfigPath, userConfig.paths),\n    networks: resolveNetworksConfig(userConfig.networks),\n    solidity: resolveSolidityConfig(userConfig),\n    mocha: resolveMochaConfig(userConfig)\n  });\n}\n\nexports.resolveConfig = resolveConfig;\n\nfunction resolveNetworksConfig() {\n  let networksConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var _a;\n\n  const hardhatNetworkConfig = networksConfig[constants_1.HARDHAT_NETWORK_NAME];\n  const localhostNetworkConfig = (_a = networksConfig.localhost) !== null && _a !== void 0 ? _a : undefined;\n  const hardhat = resolveHardhatNetworkConfig(hardhatNetworkConfig);\n  const localhost = resolveHttpNetworkConfig(Object.assign(Object.assign({}, (0, cloneDeep_1.default)(default_config_1.defaultLocalhostNetworkParams)), localhostNetworkConfig));\n  const otherNetworks = (0, lang_1.fromEntries)(Object.entries(networksConfig).filter(_ref => {\n    let [name, config] = _ref;\n    return name !== \"localhost\" && name !== \"hardhat\" && config !== undefined && isHttpNetworkConfig(config);\n  }).map(_ref2 => {\n    let [name, config] = _ref2;\n    return [name, resolveHttpNetworkConfig(config)];\n  }));\n  return Object.assign({\n    hardhat,\n    localhost\n  }, otherNetworks);\n}\n\nfunction isHttpNetworkConfig(config) {\n  return \"url\" in config;\n}\n\nfunction normalizeHexString(str) {\n  const normalized = str.trim().toLowerCase();\n\n  if (normalized.startsWith(\"0x\")) {\n    return normalized;\n  }\n\n  return `0x${normalized}`;\n}\n\nfunction resolveHardhatNetworkConfig() {\n  let hardhatNetworkConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var _a, _b, _c, _d, _e, _f, _g;\n\n  const clonedDefaultHardhatNetworkParams = (0, cloneDeep_1.default)(default_config_1.defaultHardhatNetworkParams);\n  const accounts = hardhatNetworkConfig.accounts === undefined ? default_config_1.defaultHardhatNetworkHdAccountsConfigParams : Array.isArray(hardhatNetworkConfig.accounts) ? hardhatNetworkConfig.accounts.map(_ref3 => {\n    let {\n      privateKey,\n      balance\n    } = _ref3;\n    return {\n      privateKey: normalizeHexString(privateKey),\n      balance\n    };\n  }) : Object.assign(Object.assign({}, default_config_1.defaultHardhatNetworkHdAccountsConfigParams), hardhatNetworkConfig.accounts);\n  const forking = hardhatNetworkConfig.forking !== undefined ? {\n    url: hardhatNetworkConfig.forking.url,\n    enabled: (_a = hardhatNetworkConfig.forking.enabled) !== null && _a !== void 0 ? _a : true\n  } : undefined;\n\n  if (forking !== undefined) {\n    const blockNumber = (_b = hardhatNetworkConfig === null || hardhatNetworkConfig === void 0 ? void 0 : hardhatNetworkConfig.forking) === null || _b === void 0 ? void 0 : _b.blockNumber;\n\n    if (blockNumber !== undefined) {\n      forking.blockNumber = (_c = hardhatNetworkConfig === null || hardhatNetworkConfig === void 0 ? void 0 : hardhatNetworkConfig.forking) === null || _c === void 0 ? void 0 : _c.blockNumber;\n    }\n  }\n\n  const mining = resolveMiningConfig(hardhatNetworkConfig.mining);\n  const minGasPrice = new ethereumjs_util_1.BN((_d = hardhatNetworkConfig.minGasPrice) !== null && _d !== void 0 ? _d : clonedDefaultHardhatNetworkParams.minGasPrice);\n  const blockGasLimit = (_e = hardhatNetworkConfig.blockGasLimit) !== null && _e !== void 0 ? _e : clonedDefaultHardhatNetworkParams.blockGasLimit;\n  const gas = (_f = hardhatNetworkConfig.gas) !== null && _f !== void 0 ? _f : blockGasLimit;\n  const initialDate = (_g = hardhatNetworkConfig.initialDate) !== null && _g !== void 0 ? _g : new Date().toISOString();\n  const chains = new Map(default_config_1.defaultHardhatNetworkParams.chains);\n\n  if (hardhatNetworkConfig.chains !== undefined) {\n    for (const [chainId, userChainConfig] of Object.entries(hardhatNetworkConfig.chains)) {\n      const chainConfig = {\n        hardforkHistory: new Map()\n      };\n\n      if (userChainConfig.hardforkHistory !== undefined) {\n        for (const [name, block] of Object.entries(userChainConfig.hardforkHistory)) {\n          chainConfig.hardforkHistory.set(name, block);\n        }\n      }\n\n      chains.set(parseInt(chainId, 10), chainConfig);\n    }\n  }\n\n  const config = Object.assign(Object.assign(Object.assign({}, clonedDefaultHardhatNetworkParams), hardhatNetworkConfig), {\n    accounts,\n    forking,\n    mining,\n    blockGasLimit,\n    gas,\n    initialDate,\n    minGasPrice,\n    chains\n  }); // We do it this way because ts gets lost otherwise\n\n  if (config.forking === undefined) {\n    delete config.forking;\n  }\n\n  return config;\n}\n\nfunction isHdAccountsConfig(accounts) {\n  return typeof accounts === \"object\" && !Array.isArray(accounts);\n}\n\nfunction resolveHttpNetworkConfig(networkConfig) {\n  const accounts = networkConfig.accounts === undefined ? default_config_1.defaultHttpNetworkParams.accounts : isHdAccountsConfig(networkConfig.accounts) ? Object.assign(Object.assign({}, default_config_1.defaultHdAccountsConfigParams), networkConfig.accounts) : Array.isArray(networkConfig.accounts) ? networkConfig.accounts.map(normalizeHexString) : \"remote\";\n  const url = networkConfig.url;\n  (0, errors_1.assertHardhatInvariant)(url !== undefined, \"Invalid http network config provided. URL missing.\");\n  return Object.assign(Object.assign(Object.assign({}, (0, cloneDeep_1.default)(default_config_1.defaultHttpNetworkParams)), networkConfig), {\n    accounts,\n    url\n  });\n}\n\nfunction resolveMiningConfig(userConfig) {\n  const mempool = resolveMempoolConfig(userConfig === null || userConfig === void 0 ? void 0 : userConfig.mempool);\n\n  if (userConfig === undefined) {\n    return {\n      auto: true,\n      interval: 0,\n      mempool\n    };\n  }\n\n  const {\n    auto,\n    interval\n  } = userConfig;\n\n  if (auto === undefined && interval === undefined) {\n    return {\n      auto: true,\n      interval: 0,\n      mempool\n    };\n  }\n\n  if (auto === undefined && interval !== undefined) {\n    return {\n      auto: false,\n      interval,\n      mempool\n    };\n  }\n\n  if (auto !== undefined && interval === undefined) {\n    return {\n      auto,\n      interval: 0,\n      mempool\n    };\n  } // ts can't infer it, but both values are defined here\n\n\n  return {\n    auto: auto,\n    interval: interval,\n    mempool\n  };\n}\n\nfunction resolveMempoolConfig(userConfig) {\n  if (userConfig === undefined) {\n    return {\n      order: \"priority\"\n    };\n  }\n\n  if (userConfig.order === undefined) {\n    return {\n      order: \"priority\"\n    };\n  }\n\n  return {\n    order: userConfig.order\n  };\n}\n\nfunction resolveSolidityConfig(userConfig) {\n  var _a, _b;\n\n  const userSolidityConfig = (_a = userConfig.solidity) !== null && _a !== void 0 ? _a : default_config_1.DEFAULT_SOLC_VERSION;\n  const multiSolcConfig = normalizeSolidityConfig(userSolidityConfig);\n  const overrides = (_b = multiSolcConfig.overrides) !== null && _b !== void 0 ? _b : {};\n  return {\n    compilers: multiSolcConfig.compilers.map(resolveCompiler),\n    overrides: (0, lang_1.fromEntries)(Object.entries(overrides).map(_ref4 => {\n      let [name, config] = _ref4;\n      return [name, resolveCompiler(config)];\n    }))\n  };\n}\n\nfunction normalizeSolidityConfig(solidityConfig) {\n  if (typeof solidityConfig === \"string\") {\n    return {\n      compilers: [{\n        version: solidityConfig\n      }]\n    };\n  }\n\n  if (\"version\" in solidityConfig) {\n    return {\n      compilers: [solidityConfig]\n    };\n  }\n\n  return solidityConfig;\n}\n\nfunction resolveCompiler(compiler) {\n  var _a;\n\n  const resolved = {\n    version: compiler.version,\n    settings: (_a = compiler.settings) !== null && _a !== void 0 ? _a : {}\n  };\n  resolved.settings.optimizer = Object.assign({\n    enabled: false,\n    runs: 200\n  }, resolved.settings.optimizer);\n\n  if (resolved.settings.outputSelection === undefined) {\n    resolved.settings.outputSelection = {};\n  }\n\n  for (const [file, contractSelection] of Object.entries(default_config_1.defaultSolcOutputSelection)) {\n    if (resolved.settings.outputSelection[file] === undefined) {\n      resolved.settings.outputSelection[file] = {};\n    }\n\n    for (const [contract, outputs] of Object.entries(contractSelection)) {\n      if (resolved.settings.outputSelection[file][contract] === undefined) {\n        resolved.settings.outputSelection[file][contract] = [];\n      }\n\n      for (const output of outputs) {\n        if (!resolved.settings.outputSelection[file][contract].includes(output)) {\n          resolved.settings.outputSelection[file][contract].push(output);\n        }\n      }\n    }\n  }\n\n  return resolved;\n}\n\nfunction resolveMochaConfig(userConfig) {\n  return Object.assign(Object.assign({}, (0, cloneDeep_1.default)(default_config_1.defaultMochaOptions)), userConfig.mocha);\n}\n/**\n * This function resolves the ProjectPathsConfig object from the user-provided config\n * and its path. The logic of this is not obvious and should well be document.\n * The good thing is that most users will never use this.\n *\n * Explanation:\n *    - paths.configFile is not overridable\n *    - If a path is absolute it is used \"as is\".\n *    - If the root path is relative, it's resolved from paths.configFile's dir.\n *    - If any other path is relative, it's resolved from paths.root.\n *    - Plugin-defined paths are not resolved, but encouraged to follow the same pattern.\n */\n\n\nfunction resolveProjectPaths(userConfigPath) {\n  let userPaths = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const configFile = fs.realpathSync(userConfigPath);\n  const configDir = path_1.default.dirname(configFile);\n  const root = resolvePathFrom(configDir, \"\", userPaths.root);\n  return Object.assign(Object.assign({}, userPaths), {\n    root,\n    configFile,\n    sources: resolvePathFrom(root, \"contracts\", userPaths.sources),\n    cache: resolvePathFrom(root, \"cache\", userPaths.cache),\n    artifacts: resolvePathFrom(root, \"artifacts\", userPaths.artifacts),\n    tests: resolvePathFrom(root, \"test\", userPaths.tests)\n  });\n}\n\nexports.resolveProjectPaths = resolveProjectPaths;\n\nfunction resolvePathFrom(from, defaultPath) {\n  let relativeOrAbsolutePath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultPath;\n\n  if (path_1.default.isAbsolute(relativeOrAbsolutePath)) {\n    return relativeOrAbsolutePath;\n  }\n\n  return path_1.default.join(from, relativeOrAbsolutePath);\n}","map":{"version":3,"mappings":"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","names":["resolveConfig","userConfigPath","userConfig","defaultNetwork","_a","default_config_1","paths","resolveProjectPaths","networks","resolveNetworksConfig","solidity","resolveSolidityConfig","mocha","resolveMochaConfig","exports","networksConfig","hardhatNetworkConfig","constants_1","localhostNetworkConfig","localhost","undefined","hardhat","resolveHardhatNetworkConfig","resolveHttpNetworkConfig","otherNetworks","Object","entries","filter","name","config","isHttpNetworkConfig","map","normalizeHexString","str","normalized","trim","toLowerCase","startsWith","clonedDefaultHardhatNetworkParams","accounts","Array","isArray","privateKey","balance","forking","url","enabled","blockNumber","_b","_c","mining","resolveMiningConfig","minGasPrice","ethereumjs_util_1","_d","blockGasLimit","_e","gas","_f","initialDate","_g","Date","toISOString","chains","Map","chainId","userChainConfig","chainConfig","hardforkHistory","block","set","parseInt","isHdAccountsConfig","networkConfig","mempool","resolveMempoolConfig","auto","interval","order","userSolidityConfig","multiSolcConfig","normalizeSolidityConfig","overrides","compilers","resolveCompiler","solidityConfig","version","compiler","resolved","settings","optimizer","runs","outputSelection","file","contractSelection","contract","outputs","output","includes","push","userPaths","configFile","fs","realpathSync","configDir","path_1","dirname","root","resolvePathFrom","sources","cache","artifacts","tests","from","defaultPath","relativeOrAbsolutePath","isAbsolute","join"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/internal/core/config/config-resolution.ts"],"sourcesContent":["import { BN } from \"ethereumjs-util\";\nimport * as fs from \"fs\";\nimport cloneDeep from \"lodash/cloneDeep\";\nimport path from \"path\";\n\nimport {\n  HardhatConfig,\n  HardhatNetworkAccountsConfig,\n  HardhatNetworkChainConfig,\n  HardhatNetworkChainsConfig,\n  HardhatNetworkConfig,\n  HardhatNetworkForkingConfig,\n  HardhatNetworkMiningConfig,\n  HardhatNetworkMiningUserConfig,\n  HardhatNetworkMempoolConfig,\n  HardhatNetworkMempoolUserConfig,\n  HardhatNetworkUserConfig,\n  HardhatUserConfig,\n  HDAccountsUserConfig,\n  HttpNetworkAccountsConfig,\n  HttpNetworkAccountsUserConfig,\n  HttpNetworkConfig,\n  HttpNetworkUserConfig,\n  MultiSolcUserConfig,\n  NetworksConfig,\n  NetworksUserConfig,\n  NetworkUserConfig,\n  ProjectPathsConfig,\n  ProjectPathsUserConfig,\n  SolcConfig,\n  SolcUserConfig,\n  SolidityConfig,\n  SolidityUserConfig,\n} from \"../../../types\";\nimport { HARDHAT_NETWORK_NAME } from \"../../constants\";\nimport { HardforkName } from \"../../util/hardforks\";\nimport { fromEntries } from \"../../util/lang\";\nimport { assertHardhatInvariant } from \"../errors\";\n\nimport {\n  DEFAULT_SOLC_VERSION,\n  defaultDefaultNetwork,\n  defaultHardhatNetworkHdAccountsConfigParams,\n  defaultHardhatNetworkParams,\n  defaultHdAccountsConfigParams,\n  defaultHttpNetworkParams,\n  defaultLocalhostNetworkParams,\n  defaultMochaOptions,\n  defaultSolcOutputSelection,\n} from \"./default-config\";\n\n/**\n * This functions resolves the hardhat config, setting its defaults and\n * normalizing its types if necessary.\n *\n * @param userConfigPath the user config filepath\n * @param userConfig     the user config object\n *\n * @returns the resolved config\n */\nexport function resolveConfig(\n  userConfigPath: string,\n  userConfig: HardhatUserConfig\n): HardhatConfig {\n  userConfig = cloneDeep(userConfig);\n\n  return {\n    ...userConfig,\n    defaultNetwork: userConfig.defaultNetwork ?? defaultDefaultNetwork,\n    paths: resolveProjectPaths(userConfigPath, userConfig.paths),\n    networks: resolveNetworksConfig(userConfig.networks),\n    solidity: resolveSolidityConfig(userConfig),\n    mocha: resolveMochaConfig(userConfig),\n  };\n}\n\nfunction resolveNetworksConfig(\n  networksConfig: NetworksUserConfig = {}\n): NetworksConfig {\n  const hardhatNetworkConfig = networksConfig[HARDHAT_NETWORK_NAME];\n\n  const localhostNetworkConfig =\n    (networksConfig.localhost as HttpNetworkUserConfig) ?? undefined;\n\n  const hardhat = resolveHardhatNetworkConfig(hardhatNetworkConfig);\n  const localhost = resolveHttpNetworkConfig({\n    ...cloneDeep(defaultLocalhostNetworkParams),\n    ...localhostNetworkConfig,\n  });\n\n  const otherNetworks: { [name: string]: HttpNetworkConfig } = fromEntries(\n    Object.entries(networksConfig)\n      .filter(\n        ([name, config]) =>\n          name !== \"localhost\" &&\n          name !== \"hardhat\" &&\n          config !== undefined &&\n          isHttpNetworkConfig(config)\n      )\n      .map(([name, config]) => [\n        name,\n        resolveHttpNetworkConfig(config as HttpNetworkUserConfig),\n      ])\n  );\n\n  return {\n    hardhat,\n    localhost,\n    ...otherNetworks,\n  };\n}\n\nfunction isHttpNetworkConfig(\n  config: NetworkUserConfig\n): config is HttpNetworkUserConfig {\n  return \"url\" in config;\n}\n\nfunction normalizeHexString(str: string): string {\n  const normalized = str.trim().toLowerCase();\n  if (normalized.startsWith(\"0x\")) {\n    return normalized;\n  }\n\n  return `0x${normalized}`;\n}\n\nfunction resolveHardhatNetworkConfig(\n  hardhatNetworkConfig: HardhatNetworkUserConfig = {}\n): HardhatNetworkConfig {\n  const clonedDefaultHardhatNetworkParams = cloneDeep(\n    defaultHardhatNetworkParams\n  );\n\n  const accounts: HardhatNetworkAccountsConfig =\n    hardhatNetworkConfig.accounts === undefined\n      ? defaultHardhatNetworkHdAccountsConfigParams\n      : Array.isArray(hardhatNetworkConfig.accounts)\n      ? hardhatNetworkConfig.accounts.map(({ privateKey, balance }) => ({\n          privateKey: normalizeHexString(privateKey),\n          balance,\n        }))\n      : {\n          ...defaultHardhatNetworkHdAccountsConfigParams,\n          ...hardhatNetworkConfig.accounts,\n        };\n\n  const forking: HardhatNetworkForkingConfig | undefined =\n    hardhatNetworkConfig.forking !== undefined\n      ? {\n          url: hardhatNetworkConfig.forking.url,\n          enabled: hardhatNetworkConfig.forking.enabled ?? true,\n        }\n      : undefined;\n\n  if (forking !== undefined) {\n    const blockNumber = hardhatNetworkConfig?.forking?.blockNumber;\n    if (blockNumber !== undefined) {\n      forking.blockNumber = hardhatNetworkConfig?.forking?.blockNumber;\n    }\n  }\n\n  const mining = resolveMiningConfig(hardhatNetworkConfig.mining);\n\n  const minGasPrice = new BN(\n    hardhatNetworkConfig.minGasPrice ??\n      clonedDefaultHardhatNetworkParams.minGasPrice\n  );\n\n  const blockGasLimit =\n    hardhatNetworkConfig.blockGasLimit ??\n    clonedDefaultHardhatNetworkParams.blockGasLimit;\n\n  const gas = hardhatNetworkConfig.gas ?? blockGasLimit;\n\n  const initialDate =\n    hardhatNetworkConfig.initialDate ?? new Date().toISOString();\n\n  const chains: HardhatNetworkChainsConfig = new Map(\n    defaultHardhatNetworkParams.chains\n  );\n  if (hardhatNetworkConfig.chains !== undefined) {\n    for (const [chainId, userChainConfig] of Object.entries(\n      hardhatNetworkConfig.chains\n    )) {\n      const chainConfig: HardhatNetworkChainConfig = {\n        hardforkHistory: new Map(),\n      };\n      if (userChainConfig.hardforkHistory !== undefined) {\n        for (const [name, block] of Object.entries(\n          userChainConfig.hardforkHistory\n        )) {\n          chainConfig.hardforkHistory.set(\n            name as HardforkName,\n            block as number\n          );\n        }\n      }\n      chains.set(parseInt(chainId, 10), chainConfig);\n    }\n  }\n\n  const config = {\n    ...clonedDefaultHardhatNetworkParams,\n    ...hardhatNetworkConfig,\n    accounts,\n    forking,\n    mining,\n    blockGasLimit,\n    gas,\n    initialDate,\n    minGasPrice,\n    chains,\n  };\n\n  // We do it this way because ts gets lost otherwise\n  if (config.forking === undefined) {\n    delete config.forking;\n  }\n\n  return config;\n}\n\nfunction isHdAccountsConfig(\n  accounts: HttpNetworkAccountsUserConfig\n): accounts is HDAccountsUserConfig {\n  return typeof accounts === \"object\" && !Array.isArray(accounts);\n}\n\nfunction resolveHttpNetworkConfig(\n  networkConfig: HttpNetworkUserConfig\n): HttpNetworkConfig {\n  const accounts: HttpNetworkAccountsConfig =\n    networkConfig.accounts === undefined\n      ? defaultHttpNetworkParams.accounts\n      : isHdAccountsConfig(networkConfig.accounts)\n      ? {\n          ...defaultHdAccountsConfigParams,\n          ...networkConfig.accounts,\n        }\n      : Array.isArray(networkConfig.accounts)\n      ? networkConfig.accounts.map(normalizeHexString)\n      : \"remote\";\n\n  const url = networkConfig.url;\n\n  assertHardhatInvariant(\n    url !== undefined,\n    \"Invalid http network config provided. URL missing.\"\n  );\n\n  return {\n    ...cloneDeep(defaultHttpNetworkParams),\n    ...networkConfig,\n    accounts,\n    url,\n  };\n}\n\nfunction resolveMiningConfig(\n  userConfig: HardhatNetworkMiningUserConfig | undefined\n): HardhatNetworkMiningConfig {\n  const mempool = resolveMempoolConfig(userConfig?.mempool);\n  if (userConfig === undefined) {\n    return {\n      auto: true,\n      interval: 0,\n      mempool,\n    };\n  }\n\n  const { auto, interval } = userConfig;\n\n  if (auto === undefined && interval === undefined) {\n    return {\n      auto: true,\n      interval: 0,\n      mempool,\n    };\n  }\n\n  if (auto === undefined && interval !== undefined) {\n    return {\n      auto: false,\n      interval,\n      mempool,\n    };\n  }\n\n  if (auto !== undefined && interval === undefined) {\n    return {\n      auto,\n      interval: 0,\n      mempool,\n    };\n  }\n\n  // ts can't infer it, but both values are defined here\n  return {\n    auto: auto!,\n    interval: interval!,\n    mempool,\n  };\n}\n\nfunction resolveMempoolConfig(\n  userConfig: HardhatNetworkMempoolUserConfig | undefined\n): HardhatNetworkMempoolConfig {\n  if (userConfig === undefined) {\n    return {\n      order: \"priority\",\n    };\n  }\n\n  if (userConfig.order === undefined) {\n    return {\n      order: \"priority\",\n    };\n  }\n\n  return {\n    order: userConfig.order,\n  } as HardhatNetworkMempoolConfig;\n}\n\nfunction resolveSolidityConfig(userConfig: HardhatUserConfig): SolidityConfig {\n  const userSolidityConfig = userConfig.solidity ?? DEFAULT_SOLC_VERSION;\n\n  const multiSolcConfig: MultiSolcUserConfig =\n    normalizeSolidityConfig(userSolidityConfig);\n\n  const overrides = multiSolcConfig.overrides ?? {};\n\n  return {\n    compilers: multiSolcConfig.compilers.map(resolveCompiler),\n    overrides: fromEntries(\n      Object.entries(overrides).map(([name, config]) => [\n        name,\n        resolveCompiler(config),\n      ])\n    ),\n  };\n}\n\nfunction normalizeSolidityConfig(\n  solidityConfig: SolidityUserConfig\n): MultiSolcUserConfig {\n  if (typeof solidityConfig === \"string\") {\n    return {\n      compilers: [\n        {\n          version: solidityConfig,\n        },\n      ],\n    };\n  }\n\n  if (\"version\" in solidityConfig) {\n    return { compilers: [solidityConfig] };\n  }\n\n  return solidityConfig;\n}\n\nfunction resolveCompiler(compiler: SolcUserConfig): SolcConfig {\n  const resolved: SolcConfig = {\n    version: compiler.version,\n    settings: compiler.settings ?? {},\n  };\n\n  resolved.settings.optimizer = {\n    enabled: false,\n    runs: 200,\n    ...resolved.settings.optimizer,\n  };\n\n  if (resolved.settings.outputSelection === undefined) {\n    resolved.settings.outputSelection = {};\n  }\n\n  for (const [file, contractSelection] of Object.entries(\n    defaultSolcOutputSelection\n  )) {\n    if (resolved.settings.outputSelection[file] === undefined) {\n      resolved.settings.outputSelection[file] = {};\n    }\n\n    for (const [contract, outputs] of Object.entries(contractSelection)) {\n      if (resolved.settings.outputSelection[file][contract] === undefined) {\n        resolved.settings.outputSelection[file][contract] = [];\n      }\n\n      for (const output of outputs) {\n        if (\n          !resolved.settings.outputSelection[file][contract].includes(output)\n        ) {\n          resolved.settings.outputSelection[file][contract].push(output);\n        }\n      }\n    }\n  }\n\n  return resolved;\n}\n\nfunction resolveMochaConfig(userConfig: HardhatUserConfig): Mocha.MochaOptions {\n  return {\n    ...cloneDeep(defaultMochaOptions),\n    ...userConfig.mocha,\n  };\n}\n\n/**\n * This function resolves the ProjectPathsConfig object from the user-provided config\n * and its path. The logic of this is not obvious and should well be document.\n * The good thing is that most users will never use this.\n *\n * Explanation:\n *    - paths.configFile is not overridable\n *    - If a path is absolute it is used \"as is\".\n *    - If the root path is relative, it's resolved from paths.configFile's dir.\n *    - If any other path is relative, it's resolved from paths.root.\n *    - Plugin-defined paths are not resolved, but encouraged to follow the same pattern.\n */\nexport function resolveProjectPaths(\n  userConfigPath: string,\n  userPaths: ProjectPathsUserConfig = {}\n): ProjectPathsConfig {\n  const configFile = fs.realpathSync(userConfigPath);\n  const configDir = path.dirname(configFile);\n\n  const root = resolvePathFrom(configDir, \"\", userPaths.root);\n\n  return {\n    ...userPaths,\n    root,\n    configFile,\n    sources: resolvePathFrom(root, \"contracts\", userPaths.sources),\n    cache: resolvePathFrom(root, \"cache\", userPaths.cache),\n    artifacts: resolvePathFrom(root, \"artifacts\", userPaths.artifacts),\n    tests: resolvePathFrom(root, \"test\", userPaths.tests),\n  };\n}\n\nfunction resolvePathFrom(\n  from: string,\n  defaultPath: string,\n  relativeOrAbsolutePath: string = defaultPath\n) {\n  if (path.isAbsolute(relativeOrAbsolutePath)) {\n    return relativeOrAbsolutePath;\n  }\n\n  return path.join(from, relativeOrAbsolutePath);\n}\n"]},"metadata":{},"sourceType":"script"}