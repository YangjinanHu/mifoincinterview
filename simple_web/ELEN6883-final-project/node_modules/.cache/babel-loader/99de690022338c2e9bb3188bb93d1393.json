{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst chalk_1 = __importDefault(require(\"chalk\"));\n\nconst child_process_1 = require(\"child_process\");\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\n\nconst path_1 = __importDefault(require(\"path\"));\n\nconst semver_1 = __importDefault(require(\"semver\"));\n\nconst artifacts_1 = require(\"../internal/artifacts\");\n\nconst config_env_1 = require(\"../internal/core/config/config-env\");\n\nconst errors_1 = require(\"../internal/core/errors\");\n\nconst errors_list_1 = require(\"../internal/core/errors-list\");\n\nconst compilation_job_1 = require(\"../internal/solidity/compilation-job\");\n\nconst compiler_1 = require(\"../internal/solidity/compiler\");\n\nconst compiler_input_1 = require(\"../internal/solidity/compiler/compiler-input\");\n\nconst downloader_1 = require(\"../internal/solidity/compiler/downloader\");\n\nconst dependencyGraph_1 = require(\"../internal/solidity/dependencyGraph\");\n\nconst parse_1 = require(\"../internal/solidity/parse\");\n\nconst resolver_1 = require(\"../internal/solidity/resolver\");\n\nconst glob_1 = require(\"../internal/util/glob\");\n\nconst global_dir_1 = require(\"../internal/util/global-dir\");\n\nconst strings_1 = require(\"../internal/util/strings\");\n\nconst builtin_tasks_1 = require(\"../types/builtin-tasks\");\n\nconst contract_names_1 = require(\"../utils/contract-names\");\n\nconst source_names_1 = require(\"../utils/source-names\");\n\nconst task_names_1 = require(\"./task-names\");\n\nconst solidity_files_cache_1 = require(\"./utils/solidity-files-cache\");\n\nfunction isConsoleLogError(error) {\n  return error.type === \"TypeError\" && typeof error.message === \"string\" && error.message.includes(\"log\") && error.message.includes(\"type(library console)\");\n}\n\nconst log = (0, debug_1.default)(\"hardhat:core:tasks:compile\");\nconst COMPILE_TASK_FIRST_SOLC_VERSION_SUPPORTED = \"0.4.11\";\n/**\n * Returns a list of absolute paths to all the solidity files in the project.\n * This list doesn't include dependencies, for example solidity files inside\n * node_modules.\n *\n * This is the right task to override to change how the solidity files of the\n * project are obtained.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS, async (_, _ref) => {\n  let {\n    config\n  } = _ref;\n  const paths = await (0, glob_1.glob)(path_1.default.join(config.paths.sources, \"**/*.sol\"));\n  return paths;\n});\n/**\n * Receives a list of absolute paths and returns a list of source names\n * corresponding to each path. For example, receives\n * [\"/home/user/project/contracts/Foo.sol\"] and returns\n * [\"contracts/Foo.sol\"]. These source names will be used when the solc input\n * is generated.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES).addParam(\"sourcePaths\", undefined, undefined, config_env_1.types.any).setAction(async (_ref2, _ref3) => {\n  let {\n    sourcePaths\n  } = _ref2;\n  let {\n    config\n  } = _ref3;\n  const sourceNames = await Promise.all(sourcePaths.map(p => (0, source_names_1.localPathToSourceName)(config.paths.root, p)));\n  return sourceNames;\n});\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_READ_FILE).addParam(\"absolutePath\", undefined, undefined, config_env_1.types.string).setAction(async _ref4 => {\n  let {\n    absolutePath\n  } = _ref4;\n  const content = await fs_extra_1.default.readFile(absolutePath, {\n    encoding: \"utf8\"\n  });\n  return content;\n});\n/**\n * Receives a list of source names and returns a dependency graph. This task\n * is responsible for both resolving dependencies (like getting files from\n * node_modules) and generating the graph.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH).addParam(\"sourceNames\", undefined, undefined, config_env_1.types.any).addOptionalParam(\"solidityFilesCache\", undefined, undefined, config_env_1.types.any).setAction(async (_ref5, _ref6) => {\n  let {\n    sourceNames,\n    solidityFilesCache\n  } = _ref5;\n  let {\n    config,\n    run\n  } = _ref6;\n  const parser = new parse_1.Parser(solidityFilesCache);\n  const resolver = new resolver_1.Resolver(config.paths.root, parser, absolutePath => run(task_names_1.TASK_COMPILE_SOLIDITY_READ_FILE, {\n    absolutePath\n  }));\n  const resolvedFiles = await Promise.all(sourceNames.map(sn => resolver.resolveSourceName(sn)));\n  const dependencyGraph = await dependencyGraph_1.DependencyGraph.createFromResolvedFiles(resolver, resolvedFiles);\n  return dependencyGraph;\n});\n/**\n * Receives a dependency graph and a file in it, and returns the compilation\n * job for that file. The compilation job should have everything that is\n * necessary to compile that file: a compiler config to be used and a list of\n * files to use as input of the compilation.\n *\n * If the file cannot be compiled, a MatchingCompilerFailure should be\n * returned instead.\n *\n * This is the right task to override to change the compiler configuration.\n * For example, if you want to change the compiler settings when targetting\n * rinkeby, you could do something like this:\n *\n *   const compilationJob = await runSuper();\n *   if (config.network.name === 'rinkeby') {\n *     compilationJob.solidityConfig.settings = newSettings;\n *   }\n *   return compilationJob;\n *\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE).addParam(\"dependencyGraph\", undefined, undefined, config_env_1.types.any).addParam(\"file\", undefined, undefined, config_env_1.types.any).addOptionalParam(\"solidityFilesCache\", undefined, undefined, config_env_1.types.any).setAction(async (_ref7, _ref8) => {\n  let {\n    dependencyGraph,\n    file\n  } = _ref7;\n  let {\n    config\n  } = _ref8;\n  return (0, compilation_job_1.createCompilationJobFromFile)(dependencyGraph, file, config.solidity);\n});\n/**\n * Receives a dependency graph and returns a tuple with two arrays. The first\n * array is a list of CompilationJobsSuccess, where each item has a list of\n * compilation jobs. The second array is a list of CompilationJobsFailure,\n * where each item has a list of files that couldn't be compiled, grouped by\n * the reason for the failure.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS).addParam(\"dependencyGraph\", undefined, undefined, config_env_1.types.any).addOptionalParam(\"solidityFilesCache\", undefined, undefined, config_env_1.types.any).setAction(async (_ref9, _ref10) => {\n  let {\n    dependencyGraph,\n    solidityFilesCache\n  } = _ref9;\n  let {\n    run\n  } = _ref10;\n  const connectedComponents = dependencyGraph.getConnectedComponents();\n  log(`The dependency graph was divided in '${connectedComponents.length}' connected components`);\n  const compilationJobsCreationResults = await Promise.all(connectedComponents.map(graph => (0, compilation_job_1.createCompilationJobsFromConnectedComponent)(graph, file => run(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE, {\n    file,\n    dependencyGraph,\n    solidityFilesCache\n  }))));\n  let jobs = [];\n  let errors = [];\n\n  for (const result of compilationJobsCreationResults) {\n    jobs = jobs.concat(result.jobs);\n    errors = errors.concat(result.errors);\n  }\n\n  return {\n    jobs,\n    errors\n  };\n});\n/**\n * Receives a list of compilation jobs and returns a new list where some of\n * the compilation jobs might've been removed.\n *\n * This task can be overriden to change the way the cache is used, or to use\n * a different approach to filtering out compilation jobs.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_FILTER_COMPILATION_JOBS).addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any).addParam(\"force\", undefined, undefined, config_env_1.types.boolean).addOptionalParam(\"solidityFilesCache\", undefined, undefined, config_env_1.types.any).setAction(async _ref11 => {\n  let {\n    compilationJobs,\n    force,\n    solidityFilesCache\n  } = _ref11;\n  (0, errors_1.assertHardhatInvariant)(solidityFilesCache !== undefined, \"The implementation of this task needs a defined solidityFilesCache\");\n\n  if (force) {\n    log(`force flag enabled, not filtering`);\n    return compilationJobs;\n  }\n\n  const neededCompilationJobs = compilationJobs.filter(job => needsCompilation(job, solidityFilesCache));\n  const jobsFilteredOutCount = compilationJobs.length - neededCompilationJobs.length;\n  log(`'${jobsFilteredOutCount}' jobs were filtered out`);\n  return neededCompilationJobs;\n});\n/**\n * Receives a list of compilation jobs and returns a new list where some of\n * the jobs might've been merged.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_MERGE_COMPILATION_JOBS).addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any).setAction(async _ref12 => {\n  let {\n    compilationJobs\n  } = _ref12;\n  return (0, compilation_job_1.mergeCompilationJobsWithoutBug)(compilationJobs);\n});\n/**\n * Prints a message when there's nothing to compile.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_LOG_NOTHING_TO_COMPILE).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).setAction(async _ref13 => {\n  let {\n    quiet\n  } = _ref13;\n\n  if (!quiet) {\n    console.log(\"Nothing to compile\");\n  }\n});\n/**\n * Receives a list of compilation jobs and sends each one to be compiled.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE_JOBS).addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).setAction(async (_ref14, _ref15) => {\n  let {\n    compilationJobs,\n    quiet\n  } = _ref14;\n  let {\n    run\n  } = _ref15;\n\n  if (compilationJobs.length === 0) {\n    log(`No compilation jobs to compile`);\n    await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_NOTHING_TO_COMPILE, {\n      quiet\n    });\n    return {\n      artifactsEmittedPerJob: []\n    };\n  } // sort compilation jobs by compiler version\n\n\n  const sortedCompilationJobs = compilationJobs.slice().sort((job1, job2) => {\n    return semver_1.default.compare(job1.getSolcConfig().version, job2.getSolcConfig().version);\n  });\n  log(`Compiling ${sortedCompilationJobs.length} jobs`);\n  const artifactsEmittedPerJob = [];\n\n  for (let i = 0; i < sortedCompilationJobs.length; i++) {\n    const compilationJob = sortedCompilationJobs[i];\n    const {\n      artifactsEmittedPerFile\n    } = await run(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE_JOB, {\n      compilationJob,\n      compilationJobs: sortedCompilationJobs,\n      compilationJobIndex: i,\n      quiet\n    });\n    artifactsEmittedPerJob.push({\n      compilationJob,\n      artifactsEmittedPerFile\n    });\n  }\n\n  return {\n    artifactsEmittedPerJob\n  };\n});\n/**\n * Receives a compilation job and returns a CompilerInput.\n *\n * It's not recommended to override this task to modify the solc\n * configuration, override\n * TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE instead.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILER_INPUT).addParam(\"compilationJob\", undefined, undefined, config_env_1.types.any).setAction(async _ref16 => {\n  let {\n    compilationJob\n  } = _ref16;\n  return (0, compiler_input_1.getInputFromCompilationJob)(compilationJob);\n});\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_START).addParam(\"isCompilerDownloaded\", undefined, undefined, config_env_1.types.boolean).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).addParam(\"solcVersion\", undefined, undefined, config_env_1.types.string).setAction(async _ref17 => {\n  let {\n    isCompilerDownloaded,\n    solcVersion\n  } = _ref17;\n\n  if (isCompilerDownloaded) {\n    return;\n  }\n\n  console.log(`Downloading compiler ${solcVersion}`);\n});\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_END).addParam(\"isCompilerDownloaded\", undefined, undefined, config_env_1.types.boolean).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).addParam(\"solcVersion\", undefined, undefined, config_env_1.types.string).setAction(async _ref18 => {\n  let {} = _ref18;\n});\n/**\n * Receives a solc version and returns a path to a solc binary or to a\n * downloaded solcjs module. It also returns a flag indicating if the returned\n * path corresponds to solc or solcjs.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOLC_BUILD).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).addParam(\"solcVersion\", undefined, undefined, config_env_1.types.string).setAction(async (_ref19, _ref20) => {\n  let {\n    quiet,\n    solcVersion\n  } = _ref19;\n  let {\n    run\n  } = _ref20;\n  const compilersCache = await (0, global_dir_1.getCompilersDir)();\n  const downloader = new downloader_1.CompilerDownloader(compilersCache);\n  const isCompilerDownloaded = await downloader.isCompilerDownloaded(solcVersion);\n  const {\n    longVersion,\n    platform: desiredPlatform\n  } = await downloader.getCompilerBuild(solcVersion);\n  await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_START, {\n    solcVersion,\n    isCompilerDownloaded,\n    quiet\n  });\n  let compilerPath;\n  let platform;\n  let nativeBinaryFailed = false;\n  const compilerPathResult = await downloader.getDownloadedCompilerPath(solcVersion);\n\n  if (compilerPathResult === undefined) {\n    if (desiredPlatform === downloader_1.CompilerPlatform.WASM) {\n      // if we were trying to download solcjs and it failed, there's nothing\n      // we can do\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.SOLC.CANT_GET_COMPILER, {\n        version: solcVersion\n      });\n    }\n\n    nativeBinaryFailed = true;\n  } else {\n    compilerPath = compilerPathResult.compilerPath; // when using a native binary, check that it works correctly\n    // it it doesn't, force the downloader to use solcjs\n\n    if (compilerPathResult.platform !== downloader_1.CompilerPlatform.WASM) {\n      log(\"Checking native solc binary\");\n      const solcBinaryWorks = await checkSolcBinary(compilerPathResult.compilerPath);\n\n      if (!solcBinaryWorks) {\n        log(\"Native solc binary doesn't work, using solcjs instead\");\n        nativeBinaryFailed = true;\n      }\n    }\n  }\n\n  if (nativeBinaryFailed) {\n    const solcJsDownloader = new downloader_1.CompilerDownloader(compilersCache, {\n      forceSolcJs: true\n    });\n    const solcjsCompilerPath = await solcJsDownloader.getDownloadedCompilerPath(solcVersion);\n\n    if (solcjsCompilerPath === undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.SOLC.CANT_GET_COMPILER, {\n        version: solcVersion\n      });\n    }\n\n    compilerPath = solcjsCompilerPath.compilerPath;\n    platform = downloader_1.CompilerPlatform.WASM;\n  }\n\n  await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_END, {\n    solcVersion,\n    isCompilerDownloaded,\n    quiet\n  });\n  const isSolcJs = platform === downloader_1.CompilerPlatform.WASM;\n  (0, errors_1.assertHardhatInvariant)(compilerPath !== undefined, \"A compilerPath should be defined at this point\");\n  return {\n    compilerPath,\n    isSolcJs,\n    version: solcVersion,\n    longVersion\n  };\n});\n/**\n * Receives an absolute path to a solcjs module and the input to be compiled,\n * and returns the generated output\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_RUN_SOLCJS).addParam(\"input\", undefined, undefined, config_env_1.types.any).addParam(\"solcJsPath\", undefined, undefined, config_env_1.types.string).setAction(async _ref21 => {\n  let {\n    input,\n    solcJsPath\n  } = _ref21;\n  const compiler = new compiler_1.Compiler(solcJsPath);\n  const output = await compiler.compile(input);\n  return output;\n});\n/**\n * Receives an absolute path to a solc binary and the input to be compiled,\n * and returns the generated output\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_RUN_SOLC).addParam(\"input\", undefined, undefined, config_env_1.types.any).addParam(\"solcPath\", undefined, undefined, config_env_1.types.string).setAction(async _ref22 => {\n  let {\n    input,\n    solcPath\n  } = _ref22;\n  const compiler = new compiler_1.NativeCompiler(solcPath);\n  const output = await compiler.compile(input);\n  return output;\n});\n/**\n * Receives a CompilerInput and a solc version, compiles the input using a native\n * solc binary or, if that's not possible, using solcjs. Returns the generated\n * output.\n *\n * This task can be overriden to change how solc is obtained or used.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE_SOLC).addParam(\"input\", undefined, undefined, config_env_1.types.any).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).addParam(\"solcVersion\", undefined, undefined, config_env_1.types.string).addParam(\"compilationJob\", undefined, undefined, config_env_1.types.any).addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any).addParam(\"compilationJobIndex\", undefined, undefined, config_env_1.types.int).setAction(async (_ref23, _ref24) => {\n  let {\n    input,\n    quiet,\n    solcVersion,\n    compilationJob,\n    compilationJobs,\n    compilationJobIndex\n  } = _ref23;\n  let {\n    run\n  } = _ref24;\n\n  // versions older than 0.4.11 don't work with hardhat\n  // see issue https://github.com/nomiclabs/hardhat/issues/2004\n  if (semver_1.default.lt(solcVersion, COMPILE_TASK_FIRST_SOLC_VERSION_SUPPORTED)) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.COMPILE_TASK_UNSUPPORTED_SOLC_VERSION, {\n      version: solcVersion,\n      firstSupportedVersion: COMPILE_TASK_FIRST_SOLC_VERSION_SUPPORTED\n    });\n  }\n\n  const solcBuild = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOLC_BUILD, {\n    quiet,\n    solcVersion\n  });\n  await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_START, {\n    compilationJob,\n    compilationJobs,\n    compilationJobIndex,\n    quiet\n  });\n  let output;\n\n  if (solcBuild.isSolcJs) {\n    output = await run(task_names_1.TASK_COMPILE_SOLIDITY_RUN_SOLCJS, {\n      input,\n      solcJsPath: solcBuild.compilerPath\n    });\n  } else {\n    output = await run(task_names_1.TASK_COMPILE_SOLIDITY_RUN_SOLC, {\n      input,\n      solcPath: solcBuild.compilerPath\n    });\n  }\n\n  await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_END, {\n    compilationJob,\n    compilationJobs,\n    compilationJobIndex,\n    output,\n    quiet\n  });\n  return {\n    output,\n    solcBuild\n  };\n});\n/**\n * This task is just a proxy to the task that compiles with solc.\n *\n * Override this to use a different task to compile a job.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE, async (taskArgs, _ref25) => {\n  let {\n    run\n  } = _ref25;\n  return run(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE_SOLC, taskArgs);\n});\n/**\n * Receives a compilation output and prints its errors and any other\n * information useful to the user.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_LOG_COMPILATION_ERRORS).addParam(\"output\", undefined, undefined, config_env_1.types.any).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).setAction(async _ref26 => {\n  let {\n    output\n  } = _ref26;\n\n  var _a;\n\n  if ((output === null || output === void 0 ? void 0 : output.errors) === undefined) {\n    return;\n  }\n\n  for (const error of output.errors) {\n    if (error.severity === \"error\") {\n      const errorMessage = (_a = getFormattedInternalCompilerErrorMessage(error)) !== null && _a !== void 0 ? _a : error.formattedMessage;\n      console.error(chalk_1.default.red(errorMessage));\n    } else {\n      console.warn(chalk_1.default.yellow(error.formattedMessage));\n    }\n  }\n\n  const hasConsoleErrors = output.errors.some(isConsoleLogError);\n\n  if (hasConsoleErrors) {\n    console.error(chalk_1.default.red(`The console.log call you made isnâ€™t supported. See https://hardhat.org/console-log for the list of supported methods.`));\n    console.log();\n  }\n});\n/**\n * Receives a solc output and checks if there are errors. Throws if there are\n * errors.\n *\n * Override this task to avoid interrupting the compilation process if some\n * job has compilation errors.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_CHECK_ERRORS).addParam(\"output\", undefined, undefined, config_env_1.types.any).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).setAction(async (_ref27, _ref28) => {\n  let {\n    output,\n    quiet\n  } = _ref27;\n  let {\n    run\n  } = _ref28;\n  await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_COMPILATION_ERRORS, {\n    output,\n    quiet\n  });\n\n  if (hasCompilationErrors(output)) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.COMPILE_FAILURE);\n  }\n});\n/**\n * Saves to disk the artifacts for a compilation job. These artifacts\n * include the main artifacts, the debug files, and the build info.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_EMIT_ARTIFACTS).addParam(\"compilationJob\", undefined, undefined, config_env_1.types.any).addParam(\"input\", undefined, undefined, config_env_1.types.any).addParam(\"output\", undefined, undefined, config_env_1.types.any).addParam(\"solcBuild\", undefined, undefined, config_env_1.types.any).setAction(async (_ref29, _ref30) => {\n  let {\n    compilationJob,\n    input,\n    output,\n    solcBuild\n  } = _ref29;\n  let {\n    artifacts,\n    run\n  } = _ref30;\n\n  var _a, _b;\n\n  const pathToBuildInfo = await artifacts.saveBuildInfo(compilationJob.getSolcConfig().version, solcBuild.longVersion, input, output);\n  const artifactsEmittedPerFile = [];\n\n  for (const file of compilationJob.getResolvedFiles()) {\n    log(`Emitting artifacts for file '${file.sourceName}'`);\n\n    if (!compilationJob.emitsArtifacts(file)) {\n      continue;\n    }\n\n    const artifactsEmitted = [];\n\n    for (const [contractName, contractOutput] of Object.entries((_b = (_a = output.contracts) === null || _a === void 0 ? void 0 : _a[file.sourceName]) !== null && _b !== void 0 ? _b : {})) {\n      log(`Emitting artifact for contract '${contractName}'`);\n      const artifact = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_ARTIFACT_FROM_COMPILATION_OUTPUT, {\n        sourceName: file.sourceName,\n        contractName,\n        contractOutput\n      });\n      await artifacts.saveArtifactAndDebugFile(artifact, pathToBuildInfo);\n      artifactsEmitted.push(artifact.contractName);\n    }\n\n    artifactsEmittedPerFile.push({\n      file,\n      artifactsEmitted\n    });\n  }\n\n  return {\n    artifactsEmittedPerFile\n  };\n});\n/**\n * Generates the artifact for contract `contractName` given its compilation\n * output.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_ARTIFACT_FROM_COMPILATION_OUTPUT).addParam(\"sourceName\", undefined, undefined, config_env_1.types.string).addParam(\"contractName\", undefined, undefined, config_env_1.types.string).addParam(\"contractOutput\", undefined, undefined, config_env_1.types.any).setAction(async _ref31 => {\n  let {\n    sourceName,\n    contractName,\n    contractOutput\n  } = _ref31;\n  return (0, artifacts_1.getArtifactFromContractOutput)(sourceName, contractName, contractOutput);\n});\n/**\n * Prints a message before running soljs with some input.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_START).addParam(\"compilationJob\", undefined, undefined, config_env_1.types.any).addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any).addParam(\"compilationJobIndex\", undefined, undefined, config_env_1.types.int).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).setAction(async _ref32 => {\n  let {\n    compilationJobs,\n    compilationJobIndex\n  } = _ref32;\n  const solcVersion = compilationJobs[compilationJobIndex].getSolcConfig().version; // we log if this is the first job, or if the previous job has a\n  // different solc version\n\n  const shouldLog = compilationJobIndex === 0 || compilationJobs[compilationJobIndex - 1].getSolcConfig().version !== solcVersion;\n\n  if (!shouldLog) {\n    return;\n  } // count how many files emit artifacts for this version\n\n\n  let count = 0;\n\n  for (let i = compilationJobIndex; i < compilationJobs.length; i++) {\n    const job = compilationJobs[i];\n\n    if (job.getSolcConfig().version !== solcVersion) {\n      break;\n    }\n\n    count += job.getResolvedFiles().filter(file => job.emitsArtifacts(file)).length;\n  }\n\n  console.log(`Compiling ${count} ${(0, strings_1.pluralize)(count, \"file\")} with ${solcVersion}`);\n});\n/**\n * Prints a message after compiling some input\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_END).addParam(\"compilationJob\", undefined, undefined, config_env_1.types.any).addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any).addParam(\"compilationJobIndex\", undefined, undefined, config_env_1.types.int).addParam(\"output\", undefined, undefined, config_env_1.types.any).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).setAction(async _ref33 => {\n  let {} = _ref33;\n});\n/**\n * This is an orchestrator task that uses other subtasks to compile a\n * compilation job.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE_JOB).addParam(\"compilationJob\", undefined, undefined, config_env_1.types.any).addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any).addParam(\"compilationJobIndex\", undefined, undefined, config_env_1.types.int).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).addOptionalParam(\"emitsArtifacts\", undefined, true, config_env_1.types.boolean).setAction(async (_ref34, _ref35) => {\n  let {\n    compilationJob,\n    compilationJobs,\n    compilationJobIndex,\n    quiet,\n    emitsArtifacts\n  } = _ref34;\n  let {\n    run\n  } = _ref35;\n  log(`Compiling job with version '${compilationJob.getSolcConfig().version}'`);\n  const input = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILER_INPUT, {\n    compilationJob\n  });\n  const {\n    output,\n    solcBuild\n  } = await run(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE, {\n    solcVersion: compilationJob.getSolcConfig().version,\n    input,\n    quiet,\n    compilationJob,\n    compilationJobs,\n    compilationJobIndex\n  });\n  await run(task_names_1.TASK_COMPILE_SOLIDITY_CHECK_ERRORS, {\n    output,\n    quiet\n  });\n  let artifactsEmittedPerFile = [];\n\n  if (emitsArtifacts) {\n    artifactsEmittedPerFile = (await run(task_names_1.TASK_COMPILE_SOLIDITY_EMIT_ARTIFACTS, {\n      compilationJob,\n      input,\n      output,\n      solcBuild\n    })).artifactsEmittedPerFile;\n  }\n\n  return {\n    artifactsEmittedPerFile,\n    compilationJob,\n    input,\n    output,\n    solcBuild\n  };\n});\n/**\n * Receives a list of CompilationJobsFailure and throws an error if it's not\n * empty.\n *\n * This task could be overriden to avoid interrupting the compilation if\n * there's some part of the project that can't be compiled.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_HANDLE_COMPILATION_JOBS_FAILURES).addParam(\"compilationJobsCreationErrors\", undefined, undefined, config_env_1.types.any).setAction(async (_ref36, _ref37) => {\n  let {\n    compilationJobsCreationErrors\n  } = _ref36;\n  let {\n    run\n  } = _ref37;\n  const hasErrors = compilationJobsCreationErrors.length > 0;\n\n  if (hasErrors) {\n    log(`There were errors creating the compilation jobs, throwing`);\n    const reasons = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS_FAILURE_REASONS, {\n      compilationJobsCreationErrors\n    });\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.COMPILATION_JOBS_CREATION_FAILURE, {\n      reasons\n    });\n  }\n});\n/**\n * Receives a list of CompilationJobsFailure and returns an error message\n * that describes the failure.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS_FAILURE_REASONS).addParam(\"compilationJobsCreationErrors\", undefined, undefined, config_env_1.types.any).setAction(async _ref38 => {\n  let {\n    compilationJobsCreationErrors: errors\n  } = _ref38;\n\n  var _a, _b, _c, _d;\n\n  const noCompatibleSolc = [];\n  const incompatibleOverridenSolc = [];\n  const directlyImportsIncompatibleFile = [];\n  const indirectlyImportsIncompatibleFile = [];\n  const other = [];\n\n  for (const error of errors) {\n    if (error.reason === builtin_tasks_1.CompilationJobCreationErrorReason.NO_COMPATIBLE_SOLC_VERSION_FOUND) {\n      noCompatibleSolc.push(error);\n    } else if (error.reason === builtin_tasks_1.CompilationJobCreationErrorReason.INCOMPATIBLE_OVERRIDEN_SOLC_VERSION) {\n      incompatibleOverridenSolc.push(error);\n    } else if (error.reason === builtin_tasks_1.CompilationJobCreationErrorReason.DIRECTLY_IMPORTS_INCOMPATIBLE_FILE) {\n      directlyImportsIncompatibleFile.push(error);\n    } else if (error.reason === builtin_tasks_1.CompilationJobCreationErrorReason.INDIRECTLY_IMPORTS_INCOMPATIBLE_FILE) {\n      indirectlyImportsIncompatibleFile.push(error);\n    } else if (error.reason === builtin_tasks_1.CompilationJobCreationErrorReason.OTHER_ERROR) {\n      other.push(error);\n    } else {\n      // add unrecognized errors to `other`\n      other.push(error);\n    }\n  }\n\n  let errorMessage = \"\";\n\n  if (incompatibleOverridenSolc.length > 0) {\n    errorMessage += `The compiler version for the following files is fixed through an override in your config file to a version that is incompatible with their Solidity version pragmas.\n\n`;\n\n    for (const error of incompatibleOverridenSolc) {\n      const {\n        sourceName\n      } = error.file;\n      const {\n        versionPragmas\n      } = error.file.content;\n      const versionsRange = versionPragmas.join(\" \");\n      log(`File ${sourceName} has an incompatible overriden compiler`);\n      errorMessage += `  * ${sourceName} (${versionsRange})\\n`;\n    }\n\n    errorMessage += \"\\n\";\n  }\n\n  if (noCompatibleSolc.length > 0) {\n    errorMessage += `The Solidity version pragma statement in these files doesn't match any of the configured compilers in your config. Change the pragma or configure additional compiler versions in your hardhat config.\n\n`;\n\n    for (const error of noCompatibleSolc) {\n      const {\n        sourceName\n      } = error.file;\n      const {\n        versionPragmas\n      } = error.file.content;\n      const versionsRange = versionPragmas.join(\" \");\n      log(`File ${sourceName} doesn't match any of the configured compilers`);\n      errorMessage += `  * ${sourceName} (${versionsRange})\\n`;\n    }\n\n    errorMessage += \"\\n\";\n  }\n\n  if (directlyImportsIncompatibleFile.length > 0) {\n    errorMessage += `These files import other files that use a different and incompatible version of Solidity:\n\n`;\n\n    for (const error of directlyImportsIncompatibleFile) {\n      const {\n        sourceName\n      } = error.file;\n      const {\n        versionPragmas\n      } = error.file.content;\n      const versionsRange = versionPragmas.join(\" \");\n      const incompatibleDirectImportsFiles = (_b = (_a = error.extra) === null || _a === void 0 ? void 0 : _a.incompatibleDirectImports) !== null && _b !== void 0 ? _b : [];\n      const incompatibleDirectImports = incompatibleDirectImportsFiles.map(x => `${x.sourceName} (${x.content.versionPragmas.join(\" \")})`);\n      log(`File ${sourceName} imports files ${incompatibleDirectImportsFiles.map(x => x.sourceName).join(\", \")} that use an incompatible version of Solidity`);\n      let directImportsText = \"\";\n\n      if (incompatibleDirectImports.length === 1) {\n        directImportsText = ` imports ${incompatibleDirectImports[0]}`;\n      } else if (incompatibleDirectImports.length === 2) {\n        directImportsText = ` imports ${incompatibleDirectImports[0]} and ${incompatibleDirectImports[1]}`;\n      } else if (incompatibleDirectImports.length > 2) {\n        const otherImportsCount = incompatibleDirectImports.length - 2;\n        directImportsText = ` imports ${incompatibleDirectImports[0]}, ${incompatibleDirectImports[1]} and ${otherImportsCount} other ${(0, strings_1.pluralize)(otherImportsCount, \"file\")}. Use --verbose to see the full list.`;\n      }\n\n      errorMessage += `  * ${sourceName} (${versionsRange})${directImportsText}\\n`;\n    }\n\n    errorMessage += \"\\n\";\n  }\n\n  if (indirectlyImportsIncompatibleFile.length > 0) {\n    errorMessage += `These files depend on other files that use a different and incompatible version of Solidity:\n\n`;\n\n    for (const error of indirectlyImportsIncompatibleFile) {\n      const {\n        sourceName\n      } = error.file;\n      const {\n        versionPragmas\n      } = error.file.content;\n      const versionsRange = versionPragmas.join(\" \");\n      const incompatibleIndirectImports = (_d = (_c = error.extra) === null || _c === void 0 ? void 0 : _c.incompatibleIndirectImports) !== null && _d !== void 0 ? _d : [];\n      const incompatibleImports = incompatibleIndirectImports.map(_ref39 => {\n        let {\n          dependency\n        } = _ref39;\n        return `${dependency.sourceName} (${dependency.content.versionPragmas.join(\" \")})`;\n      });\n\n      for (const {\n        dependency,\n        path: dependencyPath\n      } of incompatibleIndirectImports) {\n        const dependencyPathText = [sourceName, ...dependencyPath.map(x => x.sourceName), dependency.sourceName].join(\" -> \");\n        log(`File ${sourceName} depends on file ${dependency.sourceName} that uses an incompatible version of Solidity\nThe dependency path is ${dependencyPathText}\n`);\n      }\n\n      let indirectImportsText = \"\";\n\n      if (incompatibleImports.length === 1) {\n        indirectImportsText = ` depends on ${incompatibleImports[0]}`;\n      } else if (incompatibleImports.length === 2) {\n        indirectImportsText = ` depends on ${incompatibleImports[0]} and ${incompatibleImports[1]}`;\n      } else if (incompatibleImports.length > 2) {\n        const otherImportsCount = incompatibleImports.length - 2;\n        indirectImportsText = ` depends on ${incompatibleImports[0]}, ${incompatibleImports[1]} and ${otherImportsCount} other ${(0, strings_1.pluralize)(otherImportsCount, \"file\")}. Use --verbose to see the full list.`;\n      }\n\n      errorMessage += `  * ${sourceName} (${versionsRange})${indirectImportsText}\\n`;\n    }\n\n    errorMessage += \"\\n\";\n  }\n\n  if (other.length > 0) {\n    errorMessage += `These files and its dependencies cannot be compiled with your config. This can happen because they have incompatible Solidity pragmas, or don't match any of your configured Solidity compilers.\n\n${other.map(x => `  * ${x.file.sourceName}`).join(\"\\n\")}\n\n`;\n  }\n\n  errorMessage += `To learn more, run the command again with --verbose\n\nRead about compiler configuration at https://hardhat.org/config\n`;\n  return errorMessage;\n});\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY_LOG_COMPILATION_RESULT).addParam(\"compilationJobs\", undefined, undefined, config_env_1.types.any).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).setAction(async _ref40 => {\n  let {\n    compilationJobs\n  } = _ref40;\n\n  if (compilationJobs.length > 0) {\n    console.log(\"Solidity compilation finished successfully\");\n  }\n});\n/**\n * Main task for compiling the solidity files in the project.\n *\n * The main responsibility of this task is to orchestrate and connect most of\n * the subtasks related to compiling solidity.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_SOLIDITY).addParam(\"force\", undefined, undefined, config_env_1.types.boolean).addParam(\"quiet\", undefined, undefined, config_env_1.types.boolean).setAction(async (_ref41, _ref42) => {\n  let {\n    force,\n    quiet\n  } = _ref41;\n  let {\n    artifacts,\n    config,\n    run\n  } = _ref42;\n  const sourcePaths = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS);\n  const sourceNames = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES, {\n    sourcePaths\n  });\n  const solidityFilesCachePath = (0, solidity_files_cache_1.getSolidityFilesCachePath)(config.paths);\n  let solidityFilesCache = await solidity_files_cache_1.SolidityFilesCache.readFromFile(solidityFilesCachePath);\n  const dependencyGraph = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH, {\n    sourceNames,\n    solidityFilesCache\n  });\n  solidityFilesCache = await invalidateCacheMissingArtifacts(solidityFilesCache, artifacts, dependencyGraph.getResolvedFiles());\n  const compilationJobsCreationResult = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS, {\n    dependencyGraph,\n    solidityFilesCache\n  });\n  await run(task_names_1.TASK_COMPILE_SOLIDITY_HANDLE_COMPILATION_JOBS_FAILURES, {\n    compilationJobsCreationErrors: compilationJobsCreationResult.errors\n  });\n  const compilationJobs = compilationJobsCreationResult.jobs;\n  const filteredCompilationJobs = await run(task_names_1.TASK_COMPILE_SOLIDITY_FILTER_COMPILATION_JOBS, {\n    compilationJobs,\n    force,\n    solidityFilesCache\n  });\n  const mergedCompilationJobs = await run(task_names_1.TASK_COMPILE_SOLIDITY_MERGE_COMPILATION_JOBS, {\n    compilationJobs: filteredCompilationJobs\n  });\n  const {\n    artifactsEmittedPerJob\n  } = await run(task_names_1.TASK_COMPILE_SOLIDITY_COMPILE_JOBS, {\n    compilationJobs: mergedCompilationJobs,\n    quiet\n  }); // update cache using the information about the emitted artifacts\n\n  for (const {\n    compilationJob: compilationJob,\n    artifactsEmittedPerFile: artifactsEmittedPerFile\n  } of artifactsEmittedPerJob) {\n    for (const {\n      file,\n      artifactsEmitted\n    } of artifactsEmittedPerFile) {\n      solidityFilesCache.addFile(file.absolutePath, {\n        lastModificationDate: file.lastModificationDate.valueOf(),\n        contentHash: file.contentHash,\n        sourceName: file.sourceName,\n        solcConfig: compilationJob.getSolcConfig(),\n        imports: file.content.imports,\n        versionPragmas: file.content.versionPragmas,\n        artifacts: artifactsEmitted\n      });\n    }\n  }\n\n  const allArtifactsEmittedPerFile = solidityFilesCache.getEntries(); // We know this is the actual implementation, so we use some\n  // non-public methods here.\n\n  const artifactsImpl = artifacts;\n  artifactsImpl.addValidArtifacts(allArtifactsEmittedPerFile);\n  await solidityFilesCache.writeToFile(solidityFilesCachePath);\n  await run(task_names_1.TASK_COMPILE_SOLIDITY_LOG_COMPILATION_RESULT, {\n    compilationJobs: mergedCompilationJobs,\n    quiet\n  });\n});\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_REMOVE_OBSOLETE_ARTIFACTS, async (_, _ref43) => {\n  let {\n    artifacts\n  } = _ref43;\n  // We know this is the actual implementation, so we use some\n  // non-public methods here.\n  const artifactsImpl = artifacts;\n  await artifactsImpl.removeObsoleteArtifacts();\n});\n/**\n * Returns a list of compilation tasks.\n *\n * This is the task to override to add support for other languages.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_COMPILE_GET_COMPILATION_TASKS, async () => {\n  return [task_names_1.TASK_COMPILE_SOLIDITY];\n});\n/**\n * Main compile task.\n *\n * This is a meta-task that just gets all the compilation tasks and runs them.\n * Right now there's only a \"compile solidity\" task.\n */\n\n(0, config_env_1.task)(task_names_1.TASK_COMPILE, \"Compiles the entire project, building all artifacts\").addFlag(\"force\", \"Force compilation ignoring cache\").addFlag(\"quiet\", \"Makes the compilation process less verbose\").setAction(async (compilationArgs, _ref44) => {\n  let {\n    run\n  } = _ref44;\n  const compilationTasks = await run(task_names_1.TASK_COMPILE_GET_COMPILATION_TASKS);\n\n  for (const compilationTask of compilationTasks) {\n    await run(compilationTask, compilationArgs);\n  }\n\n  await run(task_names_1.TASK_COMPILE_REMOVE_OBSOLETE_ARTIFACTS);\n});\n/**\n * If a file is present in the cache, but some of its artifacts are missing on\n * disk, we remove it from the cache to force it to be recompiled.\n */\n\nasync function invalidateCacheMissingArtifacts(solidityFilesCache, artifacts, resolvedFiles) {\n  for (const file of resolvedFiles) {\n    const cacheEntry = solidityFilesCache.getEntry(file.absolutePath);\n\n    if (cacheEntry === undefined) {\n      continue;\n    }\n\n    const {\n      artifacts: emittedArtifacts\n    } = cacheEntry;\n\n    for (const emittedArtifact of emittedArtifacts) {\n      const artifactExists = await artifacts.artifactExists((0, contract_names_1.getFullyQualifiedName)(file.sourceName, emittedArtifact));\n\n      if (!artifactExists) {\n        log(`Invalidate cache for '${file.absolutePath}' because artifact '${emittedArtifact}' doesn't exist`);\n        solidityFilesCache.removeEntry(file.absolutePath);\n        break;\n      }\n    }\n  }\n\n  return solidityFilesCache;\n}\n/**\n * Checks if the given compilation job needs to be done.\n */\n\n\nfunction needsCompilation(job, cache) {\n  for (const file of job.getResolvedFiles()) {\n    const hasChanged = cache.hasFileChanged(file.absolutePath, file.contentHash, // we only check if the solcConfig is different for files that\n    // emit artifacts\n    job.emitsArtifacts(file) ? job.getSolcConfig() : undefined);\n\n    if (hasChanged) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction hasCompilationErrors(output) {\n  return output.errors && output.errors.some(x => x.severity === \"error\");\n}\n\nasync function checkSolcBinary(solcPath) {\n  return new Promise(resolve => {\n    const process = (0, child_process_1.exec)(`${solcPath} --version`);\n    process.on(\"exit\", code => {\n      resolve(code === 0);\n    });\n  });\n}\n/**\n * This function returns a properly formatted Internal Compiler Error message.\n *\n * This is present due to a bug in Solidity. See: https://github.com/ethereum/solidity/issues/9926\n *\n * If the error is not an ICE, or if it's properly formatted, this function returns undefined.\n */\n\n\nfunction getFormattedInternalCompilerErrorMessage(error) {\n  if (error.formattedMessage.trim() !== \"InternalCompilerError:\") {\n    return;\n  } // We trim any final `:`, as we found some at the end of the error messages,\n  // and then trim just in case a blank space was left\n\n\n  return `${error.type}: ${error.message}`.replace(/[:\\s]*$/g, \"\").trim();\n}","map":{"version":3,"mappings":"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","names":["isConsoleLogError","error","type","message","includes","log","COMPILE_TASK_FIRST_SOLC_VERSION_SUPPORTED","task_names_1","_","config","paths","path_1","join","sources","addParam","undefined","config_env_1","any","setAction","sourcePaths","sourceNames","Promise","all","map","p","root","string","absolutePath","content","fs_extra_1","readFile","encoding","addOptionalParam","solidityFilesCache","run","parser","parse_1","resolver","resolver_1","resolvedFiles","sn","resolveSourceName","dependencyGraph","dependencyGraph_1","createFromResolvedFiles","file","solidity","connectedComponents","getConnectedComponents","length","compilationJobsCreationResults","graph","jobs","errors","result","concat","boolean","compilationJobs","force","neededCompilationJobs","filter","job","needsCompilation","jobsFilteredOutCount","quiet","console","artifactsEmittedPerJob","sortedCompilationJobs","slice","sort","job1","job2","semver_1","compare","getSolcConfig","version","i","compilationJob","artifactsEmittedPerFile","compilationJobIndex","push","isCompilerDownloaded","solcVersion","compilersCache","downloader","downloader_1","longVersion","platform","desiredPlatform","getCompilerBuild","compilerPath","nativeBinaryFailed","compilerPathResult","getDownloadedCompilerPath","WASM","errors_1","errors_list_1","SOLC","CANT_GET_COMPILER","solcBinaryWorks","checkSolcBinary","solcJsDownloader","forceSolcJs","solcjsCompilerPath","isSolcJs","input","solcJsPath","compiler","compiler_1","output","compile","solcPath","int","lt","BUILTIN_TASKS","COMPILE_TASK_UNSUPPORTED_SOLC_VERSION","firstSupportedVersion","solcBuild","taskArgs","severity","errorMessage","_a","formattedMessage","chalk_1","red","warn","yellow","hasConsoleErrors","some","hasCompilationErrors","COMPILE_FAILURE","artifacts","pathToBuildInfo","saveBuildInfo","getResolvedFiles","sourceName","emitsArtifacts","artifactsEmitted","contractName","contractOutput","Object","entries","contracts","_b","artifact","saveArtifactAndDebugFile","shouldLog","count","compilationJobsCreationErrors","hasErrors","reasons","COMPILATION_JOBS_CREATION_FAILURE","noCompatibleSolc","incompatibleOverridenSolc","directlyImportsIncompatibleFile","indirectlyImportsIncompatibleFile","other","reason","builtin_tasks_1","NO_COMPATIBLE_SOLC_VERSION_FOUND","INCOMPATIBLE_OVERRIDEN_SOLC_VERSION","DIRECTLY_IMPORTS_INCOMPATIBLE_FILE","INDIRECTLY_IMPORTS_INCOMPATIBLE_FILE","OTHER_ERROR","versionPragmas","versionsRange","incompatibleDirectImportsFiles","extra","incompatibleDirectImports","x","directImportsText","otherImportsCount","incompatibleIndirectImports","_c","_d","incompatibleImports","dependency","path","dependencyPath","dependencyPathText","indirectImportsText","solidityFilesCachePath","solidity_files_cache_1","readFromFile","invalidateCacheMissingArtifacts","compilationJobsCreationResult","filteredCompilationJobs","mergedCompilationJobs","addFile","lastModificationDate","valueOf","contentHash","solcConfig","imports","allArtifactsEmittedPerFile","getEntries","artifactsImpl","addValidArtifacts","writeToFile","removeObsoleteArtifacts","addFlag","compilationArgs","compilationTasks","compilationTask","cacheEntry","getEntry","emittedArtifacts","emittedArtifact","artifactExists","removeEntry","cache","hasChanged","hasFileChanged","resolve","process","on","code","getFormattedInternalCompilerErrorMessage","trim","replace"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/builtin-tasks/compile.ts"],"sourcesContent":["import chalk from \"chalk\";\nimport { exec } from \"child_process\";\nimport debug from \"debug\";\nimport fsExtra from \"fs-extra\";\nimport path from \"path\";\nimport semver from \"semver\";\n\nimport {\n  Artifacts as ArtifactsImpl,\n  getArtifactFromContractOutput,\n} from \"../internal/artifacts\";\nimport { subtask, task, types } from \"../internal/core/config/config-env\";\nimport { assertHardhatInvariant, HardhatError } from \"../internal/core/errors\";\nimport { ERRORS } from \"../internal/core/errors-list\";\nimport {\n  createCompilationJobFromFile,\n  createCompilationJobsFromConnectedComponent,\n  mergeCompilationJobsWithoutBug,\n} from \"../internal/solidity/compilation-job\";\nimport { Compiler, NativeCompiler } from \"../internal/solidity/compiler\";\nimport { getInputFromCompilationJob } from \"../internal/solidity/compiler/compiler-input\";\nimport {\n  CompilerDownloader,\n  CompilerPlatform,\n} from \"../internal/solidity/compiler/downloader\";\nimport { DependencyGraph } from \"../internal/solidity/dependencyGraph\";\nimport { Parser } from \"../internal/solidity/parse\";\nimport { ResolvedFile, Resolver } from \"../internal/solidity/resolver\";\nimport { glob } from \"../internal/util/glob\";\nimport { getCompilersDir } from \"../internal/util/global-dir\";\nimport { pluralize } from \"../internal/util/strings\";\nimport { Artifacts, CompilerInput, CompilerOutput, SolcBuild } from \"../types\";\nimport * as taskTypes from \"../types/builtin-tasks\";\nimport {\n  CompilationJob,\n  CompilationJobCreationError,\n  CompilationJobCreationErrorReason,\n  CompilationJobsCreationResult,\n} from \"../types/builtin-tasks\";\nimport { getFullyQualifiedName } from \"../utils/contract-names\";\nimport { localPathToSourceName } from \"../utils/source-names\";\n\nimport {\n  TASK_COMPILE,\n  TASK_COMPILE_GET_COMPILATION_TASKS,\n  TASK_COMPILE_SOLIDITY,\n  TASK_COMPILE_SOLIDITY_CHECK_ERRORS,\n  TASK_COMPILE_SOLIDITY_COMPILE,\n  TASK_COMPILE_SOLIDITY_COMPILE_JOB,\n  TASK_COMPILE_SOLIDITY_COMPILE_JOBS,\n  TASK_COMPILE_SOLIDITY_COMPILE_SOLC,\n  TASK_COMPILE_SOLIDITY_EMIT_ARTIFACTS,\n  TASK_COMPILE_SOLIDITY_FILTER_COMPILATION_JOBS,\n  TASK_COMPILE_SOLIDITY_GET_ARTIFACT_FROM_COMPILATION_OUTPUT,\n  TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE,\n  TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS,\n  TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS_FAILURE_REASONS,\n  TASK_COMPILE_SOLIDITY_GET_COMPILER_INPUT,\n  TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH,\n  TASK_COMPILE_SOLIDITY_GET_SOLC_BUILD,\n  TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES,\n  TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS,\n  TASK_COMPILE_SOLIDITY_HANDLE_COMPILATION_JOBS_FAILURES,\n  TASK_COMPILE_SOLIDITY_LOG_COMPILATION_ERRORS,\n  TASK_COMPILE_SOLIDITY_LOG_COMPILATION_RESULT,\n  TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_END,\n  TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_START,\n  TASK_COMPILE_SOLIDITY_LOG_NOTHING_TO_COMPILE,\n  TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_END,\n  TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_START,\n  TASK_COMPILE_SOLIDITY_MERGE_COMPILATION_JOBS,\n  TASK_COMPILE_SOLIDITY_READ_FILE,\n  TASK_COMPILE_SOLIDITY_RUN_SOLC,\n  TASK_COMPILE_SOLIDITY_RUN_SOLCJS,\n  TASK_COMPILE_REMOVE_OBSOLETE_ARTIFACTS,\n} from \"./task-names\";\nimport {\n  getSolidityFilesCachePath,\n  SolidityFilesCache,\n} from \"./utils/solidity-files-cache\";\n\ntype ArtifactsEmittedPerFile = Array<{\n  file: taskTypes.ResolvedFile;\n  artifactsEmitted: string[];\n}>;\n\ntype ArtifactsEmittedPerJob = Array<{\n  compilationJob: CompilationJob;\n  artifactsEmittedPerFile: ArtifactsEmittedPerFile;\n}>;\n\nfunction isConsoleLogError(error: any): boolean {\n  return (\n    error.type === \"TypeError\" &&\n    typeof error.message === \"string\" &&\n    error.message.includes(\"log\") &&\n    error.message.includes(\"type(library console)\")\n  );\n}\n\nconst log = debug(\"hardhat:core:tasks:compile\");\n\nconst COMPILE_TASK_FIRST_SOLC_VERSION_SUPPORTED = \"0.4.11\";\n\n/**\n * Returns a list of absolute paths to all the solidity files in the project.\n * This list doesn't include dependencies, for example solidity files inside\n * node_modules.\n *\n * This is the right task to override to change how the solidity files of the\n * project are obtained.\n */\nsubtask(\n  TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS,\n  async (_, { config }): Promise<string[]> => {\n    const paths = await glob(path.join(config.paths.sources, \"**/*.sol\"));\n\n    return paths;\n  }\n);\n\n/**\n * Receives a list of absolute paths and returns a list of source names\n * corresponding to each path. For example, receives\n * [\"/home/user/project/contracts/Foo.sol\"] and returns\n * [\"contracts/Foo.sol\"]. These source names will be used when the solc input\n * is generated.\n */\nsubtask(TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES)\n  .addParam(\"sourcePaths\", undefined, undefined, types.any)\n  .setAction(\n    async (\n      { sourcePaths }: { sourcePaths: string[] },\n      { config }\n    ): Promise<string[]> => {\n      const sourceNames = await Promise.all(\n        sourcePaths.map((p) => localPathToSourceName(config.paths.root, p))\n      );\n\n      return sourceNames;\n    }\n  );\n\nsubtask(TASK_COMPILE_SOLIDITY_READ_FILE)\n  .addParam(\"absolutePath\", undefined, undefined, types.string)\n  .setAction(\n    async ({ absolutePath }: { absolutePath: string }): Promise<string> => {\n      const content = await fsExtra.readFile(absolutePath, {\n        encoding: \"utf8\",\n      });\n\n      return content;\n    }\n  );\n\n/**\n * Receives a list of source names and returns a dependency graph. This task\n * is responsible for both resolving dependencies (like getting files from\n * node_modules) and generating the graph.\n */\nsubtask(TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH)\n  .addParam(\"sourceNames\", undefined, undefined, types.any)\n  .addOptionalParam(\"solidityFilesCache\", undefined, undefined, types.any)\n  .setAction(\n    async (\n      {\n        sourceNames,\n        solidityFilesCache,\n      }: { sourceNames: string[]; solidityFilesCache?: SolidityFilesCache },\n      { config, run }\n    ): Promise<taskTypes.DependencyGraph> => {\n      const parser = new Parser(solidityFilesCache);\n      const resolver = new Resolver(\n        config.paths.root,\n        parser,\n        (absolutePath: string) =>\n          run(TASK_COMPILE_SOLIDITY_READ_FILE, { absolutePath })\n      );\n\n      const resolvedFiles = await Promise.all(\n        sourceNames.map((sn) => resolver.resolveSourceName(sn))\n      );\n      const dependencyGraph = await DependencyGraph.createFromResolvedFiles(\n        resolver,\n        resolvedFiles\n      );\n\n      return dependencyGraph;\n    }\n  );\n\n/**\n * Receives a dependency graph and a file in it, and returns the compilation\n * job for that file. The compilation job should have everything that is\n * necessary to compile that file: a compiler config to be used and a list of\n * files to use as input of the compilation.\n *\n * If the file cannot be compiled, a MatchingCompilerFailure should be\n * returned instead.\n *\n * This is the right task to override to change the compiler configuration.\n * For example, if you want to change the compiler settings when targetting\n * rinkeby, you could do something like this:\n *\n *   const compilationJob = await runSuper();\n *   if (config.network.name === 'rinkeby') {\n *     compilationJob.solidityConfig.settings = newSettings;\n *   }\n *   return compilationJob;\n *\n */\nsubtask(TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE)\n  .addParam(\"dependencyGraph\", undefined, undefined, types.any)\n  .addParam(\"file\", undefined, undefined, types.any)\n  .addOptionalParam(\"solidityFilesCache\", undefined, undefined, types.any)\n  .setAction(\n    async (\n      {\n        dependencyGraph,\n        file,\n      }: {\n        dependencyGraph: taskTypes.DependencyGraph;\n        file: taskTypes.ResolvedFile;\n        solidityFilesCache?: SolidityFilesCache;\n      },\n      { config }\n    ): Promise<CompilationJob | CompilationJobCreationError> => {\n      return createCompilationJobFromFile(\n        dependencyGraph,\n        file,\n        config.solidity\n      );\n    }\n  );\n\n/**\n * Receives a dependency graph and returns a tuple with two arrays. The first\n * array is a list of CompilationJobsSuccess, where each item has a list of\n * compilation jobs. The second array is a list of CompilationJobsFailure,\n * where each item has a list of files that couldn't be compiled, grouped by\n * the reason for the failure.\n */\nsubtask(TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS)\n  .addParam(\"dependencyGraph\", undefined, undefined, types.any)\n  .addOptionalParam(\"solidityFilesCache\", undefined, undefined, types.any)\n  .setAction(\n    async (\n      {\n        dependencyGraph,\n        solidityFilesCache,\n      }: {\n        dependencyGraph: taskTypes.DependencyGraph;\n        solidityFilesCache?: SolidityFilesCache;\n      },\n      { run }\n    ): Promise<CompilationJobsCreationResult> => {\n      const connectedComponents = dependencyGraph.getConnectedComponents();\n\n      log(\n        `The dependency graph was divided in '${connectedComponents.length}' connected components`\n      );\n\n      const compilationJobsCreationResults = await Promise.all(\n        connectedComponents.map((graph) =>\n          createCompilationJobsFromConnectedComponent(\n            graph,\n            (file: taskTypes.ResolvedFile) =>\n              run(TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE, {\n                file,\n                dependencyGraph,\n                solidityFilesCache,\n              })\n          )\n        )\n      );\n\n      let jobs: CompilationJob[] = [];\n      let errors: CompilationJobCreationError[] = [];\n\n      for (const result of compilationJobsCreationResults) {\n        jobs = jobs.concat(result.jobs);\n        errors = errors.concat(result.errors);\n      }\n\n      return { jobs, errors };\n    }\n  );\n\n/**\n * Receives a list of compilation jobs and returns a new list where some of\n * the compilation jobs might've been removed.\n *\n * This task can be overriden to change the way the cache is used, or to use\n * a different approach to filtering out compilation jobs.\n */\nsubtask(TASK_COMPILE_SOLIDITY_FILTER_COMPILATION_JOBS)\n  .addParam(\"compilationJobs\", undefined, undefined, types.any)\n  .addParam(\"force\", undefined, undefined, types.boolean)\n  .addOptionalParam(\"solidityFilesCache\", undefined, undefined, types.any)\n  .setAction(\n    async ({\n      compilationJobs,\n      force,\n      solidityFilesCache,\n    }: {\n      compilationJobs: CompilationJob[];\n      force: boolean;\n      solidityFilesCache?: SolidityFilesCache;\n    }): Promise<CompilationJob[]> => {\n      assertHardhatInvariant(\n        solidityFilesCache !== undefined,\n        \"The implementation of this task needs a defined solidityFilesCache\"\n      );\n\n      if (force) {\n        log(`force flag enabled, not filtering`);\n        return compilationJobs;\n      }\n\n      const neededCompilationJobs = compilationJobs.filter((job) =>\n        needsCompilation(job, solidityFilesCache)\n      );\n\n      const jobsFilteredOutCount =\n        compilationJobs.length - neededCompilationJobs.length;\n      log(`'${jobsFilteredOutCount}' jobs were filtered out`);\n\n      return neededCompilationJobs;\n    }\n  );\n\n/**\n * Receives a list of compilation jobs and returns a new list where some of\n * the jobs might've been merged.\n */\nsubtask(TASK_COMPILE_SOLIDITY_MERGE_COMPILATION_JOBS)\n  .addParam(\"compilationJobs\", undefined, undefined, types.any)\n  .setAction(\n    async ({\n      compilationJobs,\n    }: {\n      compilationJobs: CompilationJob[];\n    }): Promise<CompilationJob[]> => {\n      return mergeCompilationJobsWithoutBug(compilationJobs);\n    }\n  );\n\n/**\n * Prints a message when there's nothing to compile.\n */\nsubtask(TASK_COMPILE_SOLIDITY_LOG_NOTHING_TO_COMPILE)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .setAction(async ({ quiet }: { quiet: boolean }) => {\n    if (!quiet) {\n      console.log(\"Nothing to compile\");\n    }\n  });\n\n/**\n * Receives a list of compilation jobs and sends each one to be compiled.\n */\nsubtask(TASK_COMPILE_SOLIDITY_COMPILE_JOBS)\n  .addParam(\"compilationJobs\", undefined, undefined, types.any)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .setAction(\n    async (\n      {\n        compilationJobs,\n        quiet,\n      }: {\n        compilationJobs: CompilationJob[];\n        quiet: boolean;\n      },\n      { run }\n    ): Promise<{ artifactsEmittedPerJob: ArtifactsEmittedPerJob }> => {\n      if (compilationJobs.length === 0) {\n        log(`No compilation jobs to compile`);\n        await run(TASK_COMPILE_SOLIDITY_LOG_NOTHING_TO_COMPILE, { quiet });\n        return { artifactsEmittedPerJob: [] };\n      }\n\n      // sort compilation jobs by compiler version\n      const sortedCompilationJobs = compilationJobs\n        .slice()\n        .sort((job1, job2) => {\n          return semver.compare(\n            job1.getSolcConfig().version,\n            job2.getSolcConfig().version\n          );\n        });\n\n      log(`Compiling ${sortedCompilationJobs.length} jobs`);\n\n      const artifactsEmittedPerJob: ArtifactsEmittedPerJob = [];\n      for (let i = 0; i < sortedCompilationJobs.length; i++) {\n        const compilationJob = sortedCompilationJobs[i];\n\n        const { artifactsEmittedPerFile } = await run(\n          TASK_COMPILE_SOLIDITY_COMPILE_JOB,\n          {\n            compilationJob,\n            compilationJobs: sortedCompilationJobs,\n            compilationJobIndex: i,\n            quiet,\n          }\n        );\n\n        artifactsEmittedPerJob.push({\n          compilationJob,\n          artifactsEmittedPerFile,\n        });\n      }\n\n      return { artifactsEmittedPerJob };\n    }\n  );\n\n/**\n * Receives a compilation job and returns a CompilerInput.\n *\n * It's not recommended to override this task to modify the solc\n * configuration, override\n * TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOB_FOR_FILE instead.\n */\nsubtask(TASK_COMPILE_SOLIDITY_GET_COMPILER_INPUT)\n  .addParam(\"compilationJob\", undefined, undefined, types.any)\n  .setAction(\n    async ({\n      compilationJob,\n    }: {\n      compilationJob: CompilationJob;\n    }): Promise<CompilerInput> => {\n      return getInputFromCompilationJob(compilationJob);\n    }\n  );\n\nsubtask(TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_START)\n  .addParam(\"isCompilerDownloaded\", undefined, undefined, types.boolean)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .addParam(\"solcVersion\", undefined, undefined, types.string)\n  .setAction(\n    async ({\n      isCompilerDownloaded,\n      solcVersion,\n    }: {\n      isCompilerDownloaded: boolean;\n      quiet: boolean;\n      solcVersion: string;\n    }) => {\n      if (isCompilerDownloaded) {\n        return;\n      }\n\n      console.log(`Downloading compiler ${solcVersion}`);\n    }\n  );\n\nsubtask(TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_END)\n  .addParam(\"isCompilerDownloaded\", undefined, undefined, types.boolean)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .addParam(\"solcVersion\", undefined, undefined, types.string)\n  .setAction(\n    async ({}: {\n      isCompilerDownloaded: boolean;\n      quiet: boolean;\n      solcVersion: string;\n    }) => {}\n  );\n\n/**\n * Receives a solc version and returns a path to a solc binary or to a\n * downloaded solcjs module. It also returns a flag indicating if the returned\n * path corresponds to solc or solcjs.\n */\nsubtask(TASK_COMPILE_SOLIDITY_GET_SOLC_BUILD)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .addParam(\"solcVersion\", undefined, undefined, types.string)\n  .setAction(\n    async (\n      {\n        quiet,\n        solcVersion,\n      }: {\n        quiet: boolean;\n        solcVersion: string;\n      },\n      { run }\n    ): Promise<SolcBuild> => {\n      const compilersCache = await getCompilersDir();\n      const downloader = new CompilerDownloader(compilersCache);\n\n      const isCompilerDownloaded = await downloader.isCompilerDownloaded(\n        solcVersion\n      );\n\n      const { longVersion, platform: desiredPlatform } =\n        await downloader.getCompilerBuild(solcVersion);\n\n      await run(TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_START, {\n        solcVersion,\n        isCompilerDownloaded,\n        quiet,\n      });\n\n      let compilerPath: string | undefined;\n      let platform: CompilerPlatform | undefined;\n      let nativeBinaryFailed = false;\n\n      const compilerPathResult = await downloader.getDownloadedCompilerPath(\n        solcVersion\n      );\n\n      if (compilerPathResult === undefined) {\n        if (desiredPlatform === CompilerPlatform.WASM) {\n          // if we were trying to download solcjs and it failed, there's nothing\n          // we can do\n          throw new HardhatError(ERRORS.SOLC.CANT_GET_COMPILER, {\n            version: solcVersion,\n          });\n        }\n\n        nativeBinaryFailed = true;\n      } else {\n        compilerPath = compilerPathResult.compilerPath;\n\n        // when using a native binary, check that it works correctly\n        // it it doesn't, force the downloader to use solcjs\n        if (compilerPathResult.platform !== CompilerPlatform.WASM) {\n          log(\"Checking native solc binary\");\n\n          const solcBinaryWorks = await checkSolcBinary(\n            compilerPathResult.compilerPath\n          );\n          if (!solcBinaryWorks) {\n            log(\"Native solc binary doesn't work, using solcjs instead\");\n            nativeBinaryFailed = true;\n          }\n        }\n      }\n\n      if (nativeBinaryFailed) {\n        const solcJsDownloader = new CompilerDownloader(compilersCache, {\n          forceSolcJs: true,\n        });\n\n        const solcjsCompilerPath =\n          await solcJsDownloader.getDownloadedCompilerPath(solcVersion);\n\n        if (solcjsCompilerPath === undefined) {\n          throw new HardhatError(ERRORS.SOLC.CANT_GET_COMPILER, {\n            version: solcVersion,\n          });\n        }\n\n        compilerPath = solcjsCompilerPath.compilerPath;\n        platform = CompilerPlatform.WASM;\n      }\n\n      await run(TASK_COMPILE_SOLIDITY_LOG_DOWNLOAD_COMPILER_END, {\n        solcVersion,\n        isCompilerDownloaded,\n        quiet,\n      });\n\n      const isSolcJs = platform === CompilerPlatform.WASM;\n\n      assertHardhatInvariant(\n        compilerPath !== undefined,\n        \"A compilerPath should be defined at this point\"\n      );\n\n      return { compilerPath, isSolcJs, version: solcVersion, longVersion };\n    }\n  );\n\n/**\n * Receives an absolute path to a solcjs module and the input to be compiled,\n * and returns the generated output\n */\nsubtask(TASK_COMPILE_SOLIDITY_RUN_SOLCJS)\n  .addParam(\"input\", undefined, undefined, types.any)\n  .addParam(\"solcJsPath\", undefined, undefined, types.string)\n  .setAction(\n    async ({\n      input,\n      solcJsPath,\n    }: {\n      input: CompilerInput;\n      solcJsPath: string;\n    }) => {\n      const compiler = new Compiler(solcJsPath);\n\n      const output = await compiler.compile(input);\n\n      return output;\n    }\n  );\n\n/**\n * Receives an absolute path to a solc binary and the input to be compiled,\n * and returns the generated output\n */\nsubtask(TASK_COMPILE_SOLIDITY_RUN_SOLC)\n  .addParam(\"input\", undefined, undefined, types.any)\n  .addParam(\"solcPath\", undefined, undefined, types.string)\n  .setAction(\n    async ({ input, solcPath }: { input: CompilerInput; solcPath: string }) => {\n      const compiler = new NativeCompiler(solcPath);\n\n      const output = await compiler.compile(input);\n\n      return output;\n    }\n  );\n\n/**\n * Receives a CompilerInput and a solc version, compiles the input using a native\n * solc binary or, if that's not possible, using solcjs. Returns the generated\n * output.\n *\n * This task can be overriden to change how solc is obtained or used.\n */\nsubtask(TASK_COMPILE_SOLIDITY_COMPILE_SOLC)\n  .addParam(\"input\", undefined, undefined, types.any)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .addParam(\"solcVersion\", undefined, undefined, types.string)\n  .addParam(\"compilationJob\", undefined, undefined, types.any)\n  .addParam(\"compilationJobs\", undefined, undefined, types.any)\n  .addParam(\"compilationJobIndex\", undefined, undefined, types.int)\n  .setAction(\n    async (\n      {\n        input,\n        quiet,\n        solcVersion,\n        compilationJob,\n        compilationJobs,\n        compilationJobIndex,\n      }: {\n        input: CompilerInput;\n        quiet: boolean;\n        solcVersion: string;\n        compilationJob: CompilationJob;\n        compilationJobs: CompilationJob[];\n        compilationJobIndex: number;\n      },\n      { run }\n    ): Promise<{ output: CompilerOutput; solcBuild: SolcBuild }> => {\n      // versions older than 0.4.11 don't work with hardhat\n      // see issue https://github.com/nomiclabs/hardhat/issues/2004\n      if (semver.lt(solcVersion, COMPILE_TASK_FIRST_SOLC_VERSION_SUPPORTED)) {\n        throw new HardhatError(\n          ERRORS.BUILTIN_TASKS.COMPILE_TASK_UNSUPPORTED_SOLC_VERSION,\n          {\n            version: solcVersion,\n            firstSupportedVersion: COMPILE_TASK_FIRST_SOLC_VERSION_SUPPORTED,\n          }\n        );\n      }\n\n      const solcBuild: SolcBuild = await run(\n        TASK_COMPILE_SOLIDITY_GET_SOLC_BUILD,\n        {\n          quiet,\n          solcVersion,\n        }\n      );\n\n      await run(TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_START, {\n        compilationJob,\n        compilationJobs,\n        compilationJobIndex,\n        quiet,\n      });\n\n      let output;\n      if (solcBuild.isSolcJs) {\n        output = await run(TASK_COMPILE_SOLIDITY_RUN_SOLCJS, {\n          input,\n          solcJsPath: solcBuild.compilerPath,\n        });\n      } else {\n        output = await run(TASK_COMPILE_SOLIDITY_RUN_SOLC, {\n          input,\n          solcPath: solcBuild.compilerPath,\n        });\n      }\n\n      await run(TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_END, {\n        compilationJob,\n        compilationJobs,\n        compilationJobIndex,\n        output,\n        quiet,\n      });\n\n      return { output, solcBuild };\n    }\n  );\n\n/**\n * This task is just a proxy to the task that compiles with solc.\n *\n * Override this to use a different task to compile a job.\n */\nsubtask(TASK_COMPILE_SOLIDITY_COMPILE, async (taskArgs: any, { run }) => {\n  return run(TASK_COMPILE_SOLIDITY_COMPILE_SOLC, taskArgs);\n});\n\n/**\n * Receives a compilation output and prints its errors and any other\n * information useful to the user.\n */\nsubtask(TASK_COMPILE_SOLIDITY_LOG_COMPILATION_ERRORS)\n  .addParam(\"output\", undefined, undefined, types.any)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .setAction(async ({ output }: { output: any; quiet: boolean }) => {\n    if (output?.errors === undefined) {\n      return;\n    }\n\n    for (const error of output.errors) {\n      if (error.severity === \"error\") {\n        const errorMessage =\n          getFormattedInternalCompilerErrorMessage(error) ??\n          error.formattedMessage;\n\n        console.error(chalk.red(errorMessage));\n      } else {\n        console.warn(chalk.yellow(error.formattedMessage));\n      }\n    }\n\n    const hasConsoleErrors = output.errors.some(isConsoleLogError);\n    if (hasConsoleErrors) {\n      console.error(\n        chalk.red(\n          `The console.log call you made isnâ€™t supported. See https://hardhat.org/console-log for the list of supported methods.`\n        )\n      );\n      console.log();\n    }\n  });\n\n/**\n * Receives a solc output and checks if there are errors. Throws if there are\n * errors.\n *\n * Override this task to avoid interrupting the compilation process if some\n * job has compilation errors.\n */\nsubtask(TASK_COMPILE_SOLIDITY_CHECK_ERRORS)\n  .addParam(\"output\", undefined, undefined, types.any)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .setAction(\n    async ({ output, quiet }: { output: any; quiet: boolean }, { run }) => {\n      await run(TASK_COMPILE_SOLIDITY_LOG_COMPILATION_ERRORS, {\n        output,\n        quiet,\n      });\n\n      if (hasCompilationErrors(output)) {\n        throw new HardhatError(ERRORS.BUILTIN_TASKS.COMPILE_FAILURE);\n      }\n    }\n  );\n\n/**\n * Saves to disk the artifacts for a compilation job. These artifacts\n * include the main artifacts, the debug files, and the build info.\n */\nsubtask(TASK_COMPILE_SOLIDITY_EMIT_ARTIFACTS)\n  .addParam(\"compilationJob\", undefined, undefined, types.any)\n  .addParam(\"input\", undefined, undefined, types.any)\n  .addParam(\"output\", undefined, undefined, types.any)\n  .addParam(\"solcBuild\", undefined, undefined, types.any)\n  .setAction(\n    async (\n      {\n        compilationJob,\n        input,\n        output,\n        solcBuild,\n      }: {\n        compilationJob: CompilationJob;\n        input: CompilerInput;\n        output: CompilerOutput;\n        solcBuild: SolcBuild;\n      },\n      { artifacts, run }\n    ): Promise<{\n      artifactsEmittedPerFile: ArtifactsEmittedPerFile;\n    }> => {\n      const pathToBuildInfo = await artifacts.saveBuildInfo(\n        compilationJob.getSolcConfig().version,\n        solcBuild.longVersion,\n        input,\n        output\n      );\n\n      const artifactsEmittedPerFile: ArtifactsEmittedPerFile = [];\n      for (const file of compilationJob.getResolvedFiles()) {\n        log(`Emitting artifacts for file '${file.sourceName}'`);\n        if (!compilationJob.emitsArtifacts(file)) {\n          continue;\n        }\n\n        const artifactsEmitted = [];\n        for (const [contractName, contractOutput] of Object.entries(\n          output.contracts?.[file.sourceName] ?? {}\n        )) {\n          log(`Emitting artifact for contract '${contractName}'`);\n\n          const artifact = await run(\n            TASK_COMPILE_SOLIDITY_GET_ARTIFACT_FROM_COMPILATION_OUTPUT,\n            {\n              sourceName: file.sourceName,\n              contractName,\n              contractOutput,\n            }\n          );\n\n          await artifacts.saveArtifactAndDebugFile(artifact, pathToBuildInfo);\n\n          artifactsEmitted.push(artifact.contractName);\n        }\n\n        artifactsEmittedPerFile.push({\n          file,\n          artifactsEmitted,\n        });\n      }\n\n      return { artifactsEmittedPerFile };\n    }\n  );\n\n/**\n * Generates the artifact for contract `contractName` given its compilation\n * output.\n */\nsubtask(TASK_COMPILE_SOLIDITY_GET_ARTIFACT_FROM_COMPILATION_OUTPUT)\n  .addParam(\"sourceName\", undefined, undefined, types.string)\n  .addParam(\"contractName\", undefined, undefined, types.string)\n  .addParam(\"contractOutput\", undefined, undefined, types.any)\n  .setAction(\n    async ({\n      sourceName,\n      contractName,\n      contractOutput,\n    }: {\n      sourceName: string;\n      contractName: string;\n      contractOutput: any;\n    }): Promise<any> => {\n      return getArtifactFromContractOutput(\n        sourceName,\n        contractName,\n        contractOutput\n      );\n    }\n  );\n\n/**\n * Prints a message before running soljs with some input.\n */\nsubtask(TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_START)\n  .addParam(\"compilationJob\", undefined, undefined, types.any)\n  .addParam(\"compilationJobs\", undefined, undefined, types.any)\n  .addParam(\"compilationJobIndex\", undefined, undefined, types.int)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .setAction(\n    async ({\n      compilationJobs,\n      compilationJobIndex,\n    }: {\n      compilationJob: CompilationJob;\n      compilationJobs: CompilationJob[];\n      compilationJobIndex: number;\n    }) => {\n      const solcVersion =\n        compilationJobs[compilationJobIndex].getSolcConfig().version;\n\n      // we log if this is the first job, or if the previous job has a\n      // different solc version\n      const shouldLog =\n        compilationJobIndex === 0 ||\n        compilationJobs[compilationJobIndex - 1].getSolcConfig().version !==\n          solcVersion;\n\n      if (!shouldLog) {\n        return;\n      }\n\n      // count how many files emit artifacts for this version\n      let count = 0;\n      for (let i = compilationJobIndex; i < compilationJobs.length; i++) {\n        const job = compilationJobs[i];\n        if (job.getSolcConfig().version !== solcVersion) {\n          break;\n        }\n\n        count += job\n          .getResolvedFiles()\n          .filter((file) => job.emitsArtifacts(file)).length;\n      }\n\n      console.log(\n        `Compiling ${count} ${pluralize(count, \"file\")} with ${solcVersion}`\n      );\n    }\n  );\n\n/**\n * Prints a message after compiling some input\n */\nsubtask(TASK_COMPILE_SOLIDITY_LOG_RUN_COMPILER_END)\n  .addParam(\"compilationJob\", undefined, undefined, types.any)\n  .addParam(\"compilationJobs\", undefined, undefined, types.any)\n  .addParam(\"compilationJobIndex\", undefined, undefined, types.int)\n  .addParam(\"output\", undefined, undefined, types.any)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .setAction(\n    async ({}: {\n      compilationJob: CompilationJob;\n      compilationJobs: CompilationJob[];\n      compilationJobIndex: number;\n      output: any;\n      quiet: boolean;\n    }) => {}\n  );\n\n/**\n * This is an orchestrator task that uses other subtasks to compile a\n * compilation job.\n */\nsubtask(TASK_COMPILE_SOLIDITY_COMPILE_JOB)\n  .addParam(\"compilationJob\", undefined, undefined, types.any)\n  .addParam(\"compilationJobs\", undefined, undefined, types.any)\n  .addParam(\"compilationJobIndex\", undefined, undefined, types.int)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .addOptionalParam(\"emitsArtifacts\", undefined, true, types.boolean)\n  .setAction(\n    async (\n      {\n        compilationJob,\n        compilationJobs,\n        compilationJobIndex,\n        quiet,\n        emitsArtifacts,\n      }: {\n        compilationJob: CompilationJob;\n        compilationJobs: CompilationJob[];\n        compilationJobIndex: number;\n        quiet: boolean;\n        emitsArtifacts: boolean;\n      },\n      { run }\n    ): Promise<{\n      artifactsEmittedPerFile: ArtifactsEmittedPerFile;\n      compilationJob: taskTypes.CompilationJob;\n      input: CompilerInput;\n      output: CompilerOutput;\n      solcBuild: any;\n    }> => {\n      log(\n        `Compiling job with version '${compilationJob.getSolcConfig().version}'`\n      );\n      const input: CompilerInput = await run(\n        TASK_COMPILE_SOLIDITY_GET_COMPILER_INPUT,\n        {\n          compilationJob,\n        }\n      );\n\n      const { output, solcBuild } = await run(TASK_COMPILE_SOLIDITY_COMPILE, {\n        solcVersion: compilationJob.getSolcConfig().version,\n        input,\n        quiet,\n        compilationJob,\n        compilationJobs,\n        compilationJobIndex,\n      });\n\n      await run(TASK_COMPILE_SOLIDITY_CHECK_ERRORS, { output, quiet });\n\n      let artifactsEmittedPerFile = [];\n      if (emitsArtifacts) {\n        artifactsEmittedPerFile = (\n          await run(TASK_COMPILE_SOLIDITY_EMIT_ARTIFACTS, {\n            compilationJob,\n            input,\n            output,\n            solcBuild,\n          })\n        ).artifactsEmittedPerFile;\n      }\n\n      return {\n        artifactsEmittedPerFile,\n        compilationJob,\n        input,\n        output,\n        solcBuild,\n      };\n    }\n  );\n\n/**\n * Receives a list of CompilationJobsFailure and throws an error if it's not\n * empty.\n *\n * This task could be overriden to avoid interrupting the compilation if\n * there's some part of the project that can't be compiled.\n */\nsubtask(TASK_COMPILE_SOLIDITY_HANDLE_COMPILATION_JOBS_FAILURES)\n  .addParam(\"compilationJobsCreationErrors\", undefined, undefined, types.any)\n  .setAction(\n    async (\n      {\n        compilationJobsCreationErrors,\n      }: {\n        compilationJobsCreationErrors: CompilationJobCreationError[];\n      },\n      { run }\n    ) => {\n      const hasErrors = compilationJobsCreationErrors.length > 0;\n\n      if (hasErrors) {\n        log(`There were errors creating the compilation jobs, throwing`);\n        const reasons: string = await run(\n          TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS_FAILURE_REASONS,\n          { compilationJobsCreationErrors }\n        );\n\n        throw new HardhatError(\n          ERRORS.BUILTIN_TASKS.COMPILATION_JOBS_CREATION_FAILURE,\n          {\n            reasons,\n          }\n        );\n      }\n    }\n  );\n\n/**\n * Receives a list of CompilationJobsFailure and returns an error message\n * that describes the failure.\n */\nsubtask(TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS_FAILURE_REASONS)\n  .addParam(\"compilationJobsCreationErrors\", undefined, undefined, types.any)\n  .setAction(\n    async ({\n      compilationJobsCreationErrors: errors,\n    }: {\n      compilationJobsCreationErrors: CompilationJobCreationError[];\n    }): Promise<string> => {\n      const noCompatibleSolc: CompilationJobCreationError[] = [];\n      const incompatibleOverridenSolc: CompilationJobCreationError[] = [];\n      const directlyImportsIncompatibleFile: CompilationJobCreationError[] = [];\n      const indirectlyImportsIncompatibleFile: CompilationJobCreationError[] =\n        [];\n      const other: CompilationJobCreationError[] = [];\n\n      for (const error of errors) {\n        if (\n          error.reason ===\n          CompilationJobCreationErrorReason.NO_COMPATIBLE_SOLC_VERSION_FOUND\n        ) {\n          noCompatibleSolc.push(error);\n        } else if (\n          error.reason ===\n          CompilationJobCreationErrorReason.INCOMPATIBLE_OVERRIDEN_SOLC_VERSION\n        ) {\n          incompatibleOverridenSolc.push(error);\n        } else if (\n          error.reason ===\n          CompilationJobCreationErrorReason.DIRECTLY_IMPORTS_INCOMPATIBLE_FILE\n        ) {\n          directlyImportsIncompatibleFile.push(error);\n        } else if (\n          error.reason ===\n          CompilationJobCreationErrorReason.INDIRECTLY_IMPORTS_INCOMPATIBLE_FILE\n        ) {\n          indirectlyImportsIncompatibleFile.push(error);\n        } else if (\n          error.reason === CompilationJobCreationErrorReason.OTHER_ERROR\n        ) {\n          other.push(error);\n        } else {\n          // add unrecognized errors to `other`\n          other.push(error);\n        }\n      }\n\n      let errorMessage = \"\";\n      if (incompatibleOverridenSolc.length > 0) {\n        errorMessage += `The compiler version for the following files is fixed through an override in your config file to a version that is incompatible with their Solidity version pragmas.\n\n`;\n\n        for (const error of incompatibleOverridenSolc) {\n          const { sourceName } = error.file;\n          const { versionPragmas } = error.file.content;\n          const versionsRange = versionPragmas.join(\" \");\n\n          log(`File ${sourceName} has an incompatible overriden compiler`);\n\n          errorMessage += `  * ${sourceName} (${versionsRange})\\n`;\n        }\n\n        errorMessage += \"\\n\";\n      }\n\n      if (noCompatibleSolc.length > 0) {\n        errorMessage += `The Solidity version pragma statement in these files doesn't match any of the configured compilers in your config. Change the pragma or configure additional compiler versions in your hardhat config.\n\n`;\n\n        for (const error of noCompatibleSolc) {\n          const { sourceName } = error.file;\n          const { versionPragmas } = error.file.content;\n          const versionsRange = versionPragmas.join(\" \");\n\n          log(\n            `File ${sourceName} doesn't match any of the configured compilers`\n          );\n\n          errorMessage += `  * ${sourceName} (${versionsRange})\\n`;\n        }\n\n        errorMessage += \"\\n\";\n      }\n\n      if (directlyImportsIncompatibleFile.length > 0) {\n        errorMessage += `These files import other files that use a different and incompatible version of Solidity:\n\n`;\n\n        for (const error of directlyImportsIncompatibleFile) {\n          const { sourceName } = error.file;\n          const { versionPragmas } = error.file.content;\n          const versionsRange = versionPragmas.join(\" \");\n\n          const incompatibleDirectImportsFiles: ResolvedFile[] =\n            error.extra?.incompatibleDirectImports ?? [];\n\n          const incompatibleDirectImports = incompatibleDirectImportsFiles.map(\n            (x: ResolvedFile) =>\n              `${x.sourceName} (${x.content.versionPragmas.join(\" \")})`\n          );\n\n          log(\n            `File ${sourceName} imports files ${incompatibleDirectImportsFiles\n              .map((x) => x.sourceName)\n              .join(\", \")} that use an incompatible version of Solidity`\n          );\n\n          let directImportsText = \"\";\n          if (incompatibleDirectImports.length === 1) {\n            directImportsText = ` imports ${incompatibleDirectImports[0]}`;\n          } else if (incompatibleDirectImports.length === 2) {\n            directImportsText = ` imports ${incompatibleDirectImports[0]} and ${incompatibleDirectImports[1]}`;\n          } else if (incompatibleDirectImports.length > 2) {\n            const otherImportsCount = incompatibleDirectImports.length - 2;\n            directImportsText = ` imports ${incompatibleDirectImports[0]}, ${\n              incompatibleDirectImports[1]\n            } and ${otherImportsCount} other ${pluralize(\n              otherImportsCount,\n              \"file\"\n            )}. Use --verbose to see the full list.`;\n          }\n\n          errorMessage += `  * ${sourceName} (${versionsRange})${directImportsText}\\n`;\n        }\n\n        errorMessage += \"\\n\";\n      }\n\n      if (indirectlyImportsIncompatibleFile.length > 0) {\n        errorMessage += `These files depend on other files that use a different and incompatible version of Solidity:\n\n`;\n\n        for (const error of indirectlyImportsIncompatibleFile) {\n          const { sourceName } = error.file;\n          const { versionPragmas } = error.file.content;\n          const versionsRange = versionPragmas.join(\" \");\n\n          const incompatibleIndirectImports: taskTypes.TransitiveDependency[] =\n            error.extra?.incompatibleIndirectImports ?? [];\n\n          const incompatibleImports = incompatibleIndirectImports.map(\n            ({ dependency }) =>\n              `${\n                dependency.sourceName\n              } (${dependency.content.versionPragmas.join(\" \")})`\n          );\n\n          for (const {\n            dependency,\n            path: dependencyPath,\n          } of incompatibleIndirectImports) {\n            const dependencyPathText = [\n              sourceName,\n              ...dependencyPath.map((x) => x.sourceName),\n              dependency.sourceName,\n            ].join(\" -> \");\n\n            log(\n              `File ${sourceName} depends on file ${dependency.sourceName} that uses an incompatible version of Solidity\nThe dependency path is ${dependencyPathText}\n`\n            );\n          }\n\n          let indirectImportsText = \"\";\n          if (incompatibleImports.length === 1) {\n            indirectImportsText = ` depends on ${incompatibleImports[0]}`;\n          } else if (incompatibleImports.length === 2) {\n            indirectImportsText = ` depends on ${incompatibleImports[0]} and ${incompatibleImports[1]}`;\n          } else if (incompatibleImports.length > 2) {\n            const otherImportsCount = incompatibleImports.length - 2;\n            indirectImportsText = ` depends on ${incompatibleImports[0]}, ${\n              incompatibleImports[1]\n            } and ${otherImportsCount} other ${pluralize(\n              otherImportsCount,\n              \"file\"\n            )}. Use --verbose to see the full list.`;\n          }\n\n          errorMessage += `  * ${sourceName} (${versionsRange})${indirectImportsText}\\n`;\n        }\n\n        errorMessage += \"\\n\";\n      }\n\n      if (other.length > 0) {\n        errorMessage += `These files and its dependencies cannot be compiled with your config. This can happen because they have incompatible Solidity pragmas, or don't match any of your configured Solidity compilers.\n\n${other.map((x) => `  * ${x.file.sourceName}`).join(\"\\n\")}\n\n`;\n      }\n\n      errorMessage += `To learn more, run the command again with --verbose\n\nRead about compiler configuration at https://hardhat.org/config\n`;\n\n      return errorMessage;\n    }\n  );\n\nsubtask(TASK_COMPILE_SOLIDITY_LOG_COMPILATION_RESULT)\n  .addParam(\"compilationJobs\", undefined, undefined, types.any)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .setAction(\n    async ({ compilationJobs }: { compilationJobs: CompilationJob[] }) => {\n      if (compilationJobs.length > 0) {\n        console.log(\"Solidity compilation finished successfully\");\n      }\n    }\n  );\n\n/**\n * Main task for compiling the solidity files in the project.\n *\n * The main responsibility of this task is to orchestrate and connect most of\n * the subtasks related to compiling solidity.\n */\nsubtask(TASK_COMPILE_SOLIDITY)\n  .addParam(\"force\", undefined, undefined, types.boolean)\n  .addParam(\"quiet\", undefined, undefined, types.boolean)\n  .setAction(\n    async (\n      { force, quiet }: { force: boolean; quiet: boolean },\n      { artifacts, config, run }\n    ) => {\n      const sourcePaths: string[] = await run(\n        TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS\n      );\n\n      const sourceNames: string[] = await run(\n        TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES,\n        {\n          sourcePaths,\n        }\n      );\n\n      const solidityFilesCachePath = getSolidityFilesCachePath(config.paths);\n      let solidityFilesCache = await SolidityFilesCache.readFromFile(\n        solidityFilesCachePath\n      );\n\n      const dependencyGraph: taskTypes.DependencyGraph = await run(\n        TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH,\n        { sourceNames, solidityFilesCache }\n      );\n\n      solidityFilesCache = await invalidateCacheMissingArtifacts(\n        solidityFilesCache,\n        artifacts,\n        dependencyGraph.getResolvedFiles()\n      );\n\n      const compilationJobsCreationResult: CompilationJobsCreationResult =\n        await run(TASK_COMPILE_SOLIDITY_GET_COMPILATION_JOBS, {\n          dependencyGraph,\n          solidityFilesCache,\n        });\n\n      await run(TASK_COMPILE_SOLIDITY_HANDLE_COMPILATION_JOBS_FAILURES, {\n        compilationJobsCreationErrors: compilationJobsCreationResult.errors,\n      });\n\n      const compilationJobs = compilationJobsCreationResult.jobs;\n\n      const filteredCompilationJobs: CompilationJob[] = await run(\n        TASK_COMPILE_SOLIDITY_FILTER_COMPILATION_JOBS,\n        { compilationJobs, force, solidityFilesCache }\n      );\n\n      const mergedCompilationJobs: CompilationJob[] = await run(\n        TASK_COMPILE_SOLIDITY_MERGE_COMPILATION_JOBS,\n        { compilationJobs: filteredCompilationJobs }\n      );\n\n      const {\n        artifactsEmittedPerJob,\n      }: { artifactsEmittedPerJob: ArtifactsEmittedPerJob } = await run(\n        TASK_COMPILE_SOLIDITY_COMPILE_JOBS,\n        {\n          compilationJobs: mergedCompilationJobs,\n          quiet,\n        }\n      );\n\n      // update cache using the information about the emitted artifacts\n      for (const {\n        compilationJob: compilationJob,\n        artifactsEmittedPerFile: artifactsEmittedPerFile,\n      } of artifactsEmittedPerJob) {\n        for (const { file, artifactsEmitted } of artifactsEmittedPerFile) {\n          solidityFilesCache.addFile(file.absolutePath, {\n            lastModificationDate: file.lastModificationDate.valueOf(),\n            contentHash: file.contentHash,\n            sourceName: file.sourceName,\n            solcConfig: compilationJob.getSolcConfig(),\n            imports: file.content.imports,\n            versionPragmas: file.content.versionPragmas,\n            artifacts: artifactsEmitted,\n          });\n        }\n      }\n\n      const allArtifactsEmittedPerFile = solidityFilesCache.getEntries();\n\n      // We know this is the actual implementation, so we use some\n      // non-public methods here.\n      const artifactsImpl = artifacts as ArtifactsImpl;\n      artifactsImpl.addValidArtifacts(allArtifactsEmittedPerFile);\n\n      await solidityFilesCache.writeToFile(solidityFilesCachePath);\n\n      await run(TASK_COMPILE_SOLIDITY_LOG_COMPILATION_RESULT, {\n        compilationJobs: mergedCompilationJobs,\n        quiet,\n      });\n    }\n  );\n\nsubtask(TASK_COMPILE_REMOVE_OBSOLETE_ARTIFACTS, async (_, { artifacts }) => {\n  // We know this is the actual implementation, so we use some\n  // non-public methods here.\n  const artifactsImpl = artifacts as ArtifactsImpl;\n  await artifactsImpl.removeObsoleteArtifacts();\n});\n\n/**\n * Returns a list of compilation tasks.\n *\n * This is the task to override to add support for other languages.\n */\nsubtask(TASK_COMPILE_GET_COMPILATION_TASKS, async (): Promise<string[]> => {\n  return [TASK_COMPILE_SOLIDITY];\n});\n\n/**\n * Main compile task.\n *\n * This is a meta-task that just gets all the compilation tasks and runs them.\n * Right now there's only a \"compile solidity\" task.\n */\ntask(TASK_COMPILE, \"Compiles the entire project, building all artifacts\")\n  .addFlag(\"force\", \"Force compilation ignoring cache\")\n  .addFlag(\"quiet\", \"Makes the compilation process less verbose\")\n  .setAction(async (compilationArgs: any, { run }) => {\n    const compilationTasks: string[] = await run(\n      TASK_COMPILE_GET_COMPILATION_TASKS\n    );\n\n    for (const compilationTask of compilationTasks) {\n      await run(compilationTask, compilationArgs);\n    }\n\n    await run(TASK_COMPILE_REMOVE_OBSOLETE_ARTIFACTS);\n  });\n\n/**\n * If a file is present in the cache, but some of its artifacts are missing on\n * disk, we remove it from the cache to force it to be recompiled.\n */\nasync function invalidateCacheMissingArtifacts(\n  solidityFilesCache: SolidityFilesCache,\n  artifacts: Artifacts,\n  resolvedFiles: ResolvedFile[]\n): Promise<SolidityFilesCache> {\n  for (const file of resolvedFiles) {\n    const cacheEntry = solidityFilesCache.getEntry(file.absolutePath);\n\n    if (cacheEntry === undefined) {\n      continue;\n    }\n\n    const { artifacts: emittedArtifacts } = cacheEntry;\n\n    for (const emittedArtifact of emittedArtifacts) {\n      const artifactExists = await artifacts.artifactExists(\n        getFullyQualifiedName(file.sourceName, emittedArtifact)\n      );\n      if (!artifactExists) {\n        log(\n          `Invalidate cache for '${file.absolutePath}' because artifact '${emittedArtifact}' doesn't exist`\n        );\n        solidityFilesCache.removeEntry(file.absolutePath);\n        break;\n      }\n    }\n  }\n\n  return solidityFilesCache;\n}\n\n/**\n * Checks if the given compilation job needs to be done.\n */\nfunction needsCompilation(\n  job: taskTypes.CompilationJob,\n  cache: SolidityFilesCache\n): boolean {\n  for (const file of job.getResolvedFiles()) {\n    const hasChanged = cache.hasFileChanged(\n      file.absolutePath,\n      file.contentHash,\n      // we only check if the solcConfig is different for files that\n      // emit artifacts\n      job.emitsArtifacts(file) ? job.getSolcConfig() : undefined\n    );\n\n    if (hasChanged) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction hasCompilationErrors(output: any): boolean {\n  return (\n    output.errors && output.errors.some((x: any) => x.severity === \"error\")\n  );\n}\n\nasync function checkSolcBinary(solcPath: string): Promise<boolean> {\n  return new Promise((resolve) => {\n    const process = exec(`${solcPath} --version`);\n    process.on(\"exit\", (code) => {\n      resolve(code === 0);\n    });\n  });\n}\n\n/**\n * This function returns a properly formatted Internal Compiler Error message.\n *\n * This is present due to a bug in Solidity. See: https://github.com/ethereum/solidity/issues/9926\n *\n * If the error is not an ICE, or if it's properly formatted, this function returns undefined.\n */\nfunction getFormattedInternalCompilerErrorMessage(error: {\n  formattedMessage: string;\n  message: string;\n  type: string;\n}): string | undefined {\n  if (error.formattedMessage.trim() !== \"InternalCompilerError:\") {\n    return;\n  }\n\n  // We trim any final `:`, as we found some at the end of the error messages,\n  // and then trim just in case a blank space was left\n  return `${error.type}: ${error.message}`.replace(/[:\\s]*$/g, \"\").trim();\n}\n"]},"metadata":{},"sourceType":"script"}