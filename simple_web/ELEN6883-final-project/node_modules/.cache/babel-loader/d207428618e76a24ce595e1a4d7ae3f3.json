{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.replaceBackslashes = exports.isAbsolutePathSourceName = exports.normalizeSourceName = exports.localSourceNameToPath = exports.localPathToSourceName = exports.validateSourceNameExistenceAndCasing = exports.isLocalSourceName = exports.validateSourceNameFormat = void 0;\n\nconst path_1 = __importDefault(require(\"path\"));\n\nconst errors_1 = require(\"../internal/core/errors\");\n\nconst errors_list_1 = require(\"../internal/core/errors-list\");\n\nconst NODE_MODULES = \"node_modules\";\n/**\n * This function validates the source name's format.\n *\n * It throws if the format is invalid.\n * If it doesn't throw all you know is that the format is valid.\n */\n\nfunction validateSourceNameFormat(sourceName) {\n  if (isAbsolutePathSourceName(sourceName)) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_ABSOLUTE_PATH, {\n      name: sourceName\n    });\n  }\n\n  if (isExplicitRelativePath(sourceName)) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_RELATIVE_PATH, {\n      name: sourceName\n    });\n  } // We check this before normalizing so we are sure that the difference\n  // comes from slash vs backslash\n\n\n  if (replaceBackslashes(sourceName) !== sourceName) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_BACKSLASHES, {\n      name: sourceName\n    });\n  }\n\n  if (normalizeSourceName(sourceName) !== sourceName) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.INVALID_SOURCE_NOT_NORMALIZED, {\n      name: sourceName\n    });\n  }\n}\n\nexports.validateSourceNameFormat = validateSourceNameFormat;\n/**\n * This function returns true if the sourceName is, potentially, from a local\n * file. It doesn't validate that the file actually exists.\n *\n * The source name must be in a valid format.\n */\n\nasync function isLocalSourceName(projectRoot, sourceName) {\n  // Note that we consider \"hardhat/console.sol\" as a special case here.\n  // This lets someone have a \"hardhat\" directory within their project without\n  // it impacting their use of `console.log`.\n  // See issue https://github.com/nomiclabs/hardhat/issues/998\n  if (sourceName.includes(NODE_MODULES) || sourceName === \"hardhat/console.sol\") {\n    return false;\n  }\n\n  const slashIndex = sourceName.indexOf(\"/\");\n  const firstDirOrFileName = slashIndex !== -1 ? sourceName.substring(0, slashIndex) : sourceName;\n\n  try {\n    await getPathTrueCase(projectRoot, firstDirOrFileName);\n  } catch (error) {\n    if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.SOURCE_NAMES.FILE_NOT_FOUND)) {\n      return false;\n    } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n    throw error;\n  }\n\n  return true;\n}\n\nexports.isLocalSourceName = isLocalSourceName;\n/**\n * Validates that a source name exists, starting from `fromDir`, and has the\n * right casing.\n *\n * The source name must be in a valid format.\n */\n\nasync function validateSourceNameExistenceAndCasing(fromDir, sourceName) {\n  const trueCaseSourceName = await getPathTrueCase(fromDir, sourceName);\n\n  if (trueCaseSourceName !== sourceName) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.WRONG_CASING, {\n      incorrect: sourceName,\n      correct: trueCaseSourceName\n    });\n  }\n}\n\nexports.validateSourceNameExistenceAndCasing = validateSourceNameExistenceAndCasing;\n/**\n * Returns the source name of an existing local file's absolute path.\n *\n * Throws is the file doesn't exist, it's not inside the project, or belongs\n * to a library.\n */\n\nasync function localPathToSourceName(projectRoot, localFileAbsolutePath) {\n  const relativePath = path_1.default.relative(projectRoot, localFileAbsolutePath);\n  const normalized = normalizeSourceName(relativePath);\n\n  if (normalized.startsWith(\"..\")) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.EXTERNAL_AS_LOCAL, {\n      path: localFileAbsolutePath\n    });\n  }\n\n  if (normalized.includes(NODE_MODULES)) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.NODE_MODULES_AS_LOCAL, {\n      path: localFileAbsolutePath\n    });\n  }\n\n  return getPathTrueCase(projectRoot, relativePath);\n}\n\nexports.localPathToSourceName = localPathToSourceName;\n/**\n * This function takes a valid local source name and returns its path. The\n * source name doesn't need to point to an existing file.\n */\n\nfunction localSourceNameToPath(projectRoot, sourceName) {\n  return path_1.default.join(projectRoot, sourceName);\n}\n\nexports.localSourceNameToPath = localSourceNameToPath;\n/**\n * Normalizes the source name, for example, by replacing `a/./b` with `a/b`.\n *\n * The sourceName param doesn't have to be a valid source name. It can,\n * for example, be denormalized.\n */\n\nfunction normalizeSourceName(sourceName) {\n  return replaceBackslashes(path_1.default.normalize(sourceName));\n}\n\nexports.normalizeSourceName = normalizeSourceName;\n/**\n * This function returns true if the sourceName is a unix absolute path or a\n * platform-dependent one.\n *\n * This function is used instead of just `path.isAbsolute` to ensure that\n * source names never start with `/`, even on Windows.\n */\n\nfunction isAbsolutePathSourceName(sourceName) {\n  return path_1.default.isAbsolute(sourceName) || sourceName.startsWith(\"/\");\n}\n\nexports.isAbsolutePathSourceName = isAbsolutePathSourceName;\n/**\n * This function returns true if the sourceName is a unix path that is based on\n * the current directory `./`.\n */\n\nfunction isExplicitRelativePath(sourceName) {\n  const [base] = sourceName.split(\"/\", 1);\n  return base === \".\" || base === \"..\";\n}\n/**\n * This function replaces backslashes (\\\\) with slashes (/).\n *\n * Note that a source name must not contain backslashes.\n */\n\n\nfunction replaceBackslashes(str) {\n  const slash = require(\"slash\");\n\n  return slash(str);\n}\n\nexports.replaceBackslashes = replaceBackslashes;\n/**\n * Returns the true casing of `p` as a relative path from `fromDir`. Throws if\n * `p` doesn't exist. `p` MUST be in source name format.\n */\n\nasync function getPathTrueCase(fromDir, p) {\n  const {\n    trueCasePath\n  } = await Promise.resolve().then(() => __importStar(require(\"true-case-path\")));\n\n  try {\n    const tcp = await trueCasePath(p, fromDir);\n    return normalizeSourceName(path_1.default.relative(fromDir, tcp));\n  } catch (error) {\n    if (error instanceof Error) {\n      if (typeof error.message === \"string\" && error.message.includes(\"no matching file exists\")) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.FILE_NOT_FOUND, {\n          name: p\n        }, error);\n      }\n    } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n    throw error;\n  }\n}","map":{"version":3,"mappings":"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","names":["NODE_MODULES","validateSourceNameFormat","sourceName","isAbsolutePathSourceName","errors_1","errors_list_1","SOURCE_NAMES","INVALID_SOURCE_NAME_ABSOLUTE_PATH","name","isExplicitRelativePath","INVALID_SOURCE_NAME_RELATIVE_PATH","replaceBackslashes","INVALID_SOURCE_NAME_BACKSLASHES","normalizeSourceName","INVALID_SOURCE_NOT_NORMALIZED","exports","isLocalSourceName","projectRoot","includes","slashIndex","indexOf","firstDirOrFileName","substring","getPathTrueCase","error","isHardhatErrorType","FILE_NOT_FOUND","validateSourceNameExistenceAndCasing","fromDir","trueCaseSourceName","WRONG_CASING","incorrect","correct","localPathToSourceName","localFileAbsolutePath","relativePath","path_1","relative","normalized","startsWith","EXTERNAL_AS_LOCAL","path","NODE_MODULES_AS_LOCAL","localSourceNameToPath","join","normalize","isAbsolute","base","split","str","slash","require","p","trueCasePath","tcp","Error","message"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/utils/source-names.ts"],"sourcesContent":["import path from \"path\";\n\nimport { HardhatError } from \"../internal/core/errors\";\nimport { ERRORS } from \"../internal/core/errors-list\";\n\nconst NODE_MODULES = \"node_modules\";\n\n/**\n * This function validates the source name's format.\n *\n * It throws if the format is invalid.\n * If it doesn't throw all you know is that the format is valid.\n */\nexport function validateSourceNameFormat(sourceName: string) {\n  if (isAbsolutePathSourceName(sourceName)) {\n    throw new HardhatError(\n      ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_ABSOLUTE_PATH,\n      {\n        name: sourceName,\n      }\n    );\n  }\n\n  if (isExplicitRelativePath(sourceName)) {\n    throw new HardhatError(\n      ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_RELATIVE_PATH,\n      {\n        name: sourceName,\n      }\n    );\n  }\n\n  // We check this before normalizing so we are sure that the difference\n  // comes from slash vs backslash\n  if (replaceBackslashes(sourceName) !== sourceName) {\n    throw new HardhatError(\n      ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_BACKSLASHES,\n      {\n        name: sourceName,\n      }\n    );\n  }\n\n  if (normalizeSourceName(sourceName) !== sourceName) {\n    throw new HardhatError(ERRORS.SOURCE_NAMES.INVALID_SOURCE_NOT_NORMALIZED, {\n      name: sourceName,\n    });\n  }\n}\n\n/**\n * This function returns true if the sourceName is, potentially, from a local\n * file. It doesn't validate that the file actually exists.\n *\n * The source name must be in a valid format.\n */\nexport async function isLocalSourceName(\n  projectRoot: string,\n  sourceName: string\n): Promise<boolean> {\n  // Note that we consider \"hardhat/console.sol\" as a special case here.\n  // This lets someone have a \"hardhat\" directory within their project without\n  // it impacting their use of `console.log`.\n  // See issue https://github.com/nomiclabs/hardhat/issues/998\n  if (\n    sourceName.includes(NODE_MODULES) ||\n    sourceName === \"hardhat/console.sol\"\n  ) {\n    return false;\n  }\n\n  const slashIndex = sourceName.indexOf(\"/\");\n  const firstDirOrFileName =\n    slashIndex !== -1 ? sourceName.substring(0, slashIndex) : sourceName;\n\n  try {\n    await getPathTrueCase(projectRoot, firstDirOrFileName);\n  } catch (error) {\n    if (\n      HardhatError.isHardhatErrorType(error, ERRORS.SOURCE_NAMES.FILE_NOT_FOUND)\n    ) {\n      return false;\n    }\n\n    // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n\n  return true;\n}\n\n/**\n * Validates that a source name exists, starting from `fromDir`, and has the\n * right casing.\n *\n * The source name must be in a valid format.\n */\nexport async function validateSourceNameExistenceAndCasing(\n  fromDir: string,\n  sourceName: string\n) {\n  const trueCaseSourceName = await getPathTrueCase(fromDir, sourceName);\n\n  if (trueCaseSourceName !== sourceName) {\n    throw new HardhatError(ERRORS.SOURCE_NAMES.WRONG_CASING, {\n      incorrect: sourceName,\n      correct: trueCaseSourceName,\n    });\n  }\n}\n\n/**\n * Returns the source name of an existing local file's absolute path.\n *\n * Throws is the file doesn't exist, it's not inside the project, or belongs\n * to a library.\n */\nexport async function localPathToSourceName(\n  projectRoot: string,\n  localFileAbsolutePath: string\n): Promise<string> {\n  const relativePath = path.relative(projectRoot, localFileAbsolutePath);\n  const normalized = normalizeSourceName(relativePath);\n\n  if (normalized.startsWith(\"..\")) {\n    throw new HardhatError(ERRORS.SOURCE_NAMES.EXTERNAL_AS_LOCAL, {\n      path: localFileAbsolutePath,\n    });\n  }\n\n  if (normalized.includes(NODE_MODULES)) {\n    throw new HardhatError(ERRORS.SOURCE_NAMES.NODE_MODULES_AS_LOCAL, {\n      path: localFileAbsolutePath,\n    });\n  }\n\n  return getPathTrueCase(projectRoot, relativePath);\n}\n\n/**\n * This function takes a valid local source name and returns its path. The\n * source name doesn't need to point to an existing file.\n */\nexport function localSourceNameToPath(\n  projectRoot: string,\n  sourceName: string\n): string {\n  return path.join(projectRoot, sourceName);\n}\n\n/**\n * Normalizes the source name, for example, by replacing `a/./b` with `a/b`.\n *\n * The sourceName param doesn't have to be a valid source name. It can,\n * for example, be denormalized.\n */\nexport function normalizeSourceName(sourceName: string): string {\n  return replaceBackslashes(path.normalize(sourceName));\n}\n\n/**\n * This function returns true if the sourceName is a unix absolute path or a\n * platform-dependent one.\n *\n * This function is used instead of just `path.isAbsolute` to ensure that\n * source names never start with `/`, even on Windows.\n */\nexport function isAbsolutePathSourceName(sourceName: string): boolean {\n  return path.isAbsolute(sourceName) || sourceName.startsWith(\"/\");\n}\n\n/**\n * This function returns true if the sourceName is a unix path that is based on\n * the current directory `./`.\n */\nfunction isExplicitRelativePath(sourceName: string): boolean {\n  const [base] = sourceName.split(\"/\", 1);\n  return base === \".\" || base === \"..\";\n}\n\n/**\n * This function replaces backslashes (\\\\) with slashes (/).\n *\n * Note that a source name must not contain backslashes.\n */\nexport function replaceBackslashes(str: string): string {\n  const slash = require(\"slash\");\n  return slash(str);\n}\n\n/**\n * Returns the true casing of `p` as a relative path from `fromDir`. Throws if\n * `p` doesn't exist. `p` MUST be in source name format.\n */\nasync function getPathTrueCase(fromDir: string, p: string): Promise<string> {\n  const { trueCasePath } = await import(\"true-case-path\");\n\n  try {\n    const tcp = await trueCasePath(p, fromDir);\n    return normalizeSourceName(path.relative(fromDir, tcp));\n  } catch (error) {\n    if (error instanceof Error) {\n      if (\n        typeof error.message === \"string\" &&\n        error.message.includes(\"no matching file exists\")\n      ) {\n        throw new HardhatError(\n          ERRORS.SOURCE_NAMES.FILE_NOT_FOUND,\n          {\n            name: p,\n          },\n          error\n        );\n      }\n    }\n\n    // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}