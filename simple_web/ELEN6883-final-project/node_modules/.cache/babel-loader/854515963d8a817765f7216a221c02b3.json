{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Environment = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst artifacts_1 = require(\"../artifacts\");\n\nconst lazy_1 = require(\"../util/lazy\");\n\nconst config_loading_1 = require(\"./config/config-loading\");\n\nconst errors_1 = require(\"./errors\");\n\nconst errors_list_1 = require(\"./errors-list\");\n\nconst construction_1 = require(\"./providers/construction\");\n\nconst task_definitions_1 = require(\"./tasks/task-definitions\");\n\nconst log = (0, debug_1.default)(\"hardhat:core:hre\");\n\nclass Environment {\n  /**\n   * Initializes the Hardhat Runtime Environment and the given\n   * extender functions.\n   *\n   * @remarks The extenders' execution order is given by the order\n   * of the requires in the hardhat's config file and its plugins.\n   *\n   * @param config The hardhat's config object.\n   * @param hardhatArguments The parsed hardhat's arguments.\n   * @param tasks A map of tasks.\n   * @param extenders A list of extenders.\n   */\n  constructor(config, hardhatArguments, tasks) {\n    var _this = this;\n\n    let extenders = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    let experimentalHardhatNetworkMessageTraceHooks = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n    this.config = config;\n    this.hardhatArguments = hardhatArguments;\n    this.tasks = tasks;\n    /**\n     * Executes the task with the given name.\n     *\n     * @param name The task's name.\n     * @param taskArguments A map of task's arguments.\n     *\n     * @throws a HH303 if there aren't any defined tasks with the given name.\n     * @returns a promise with the task's execution result.\n     */\n\n    this.run = async function (name) {\n      let taskArguments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      const taskDefinition = _this.tasks[name];\n      log(\"Running task %s\", name);\n\n      if (taskDefinition === undefined) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_TASK, {\n          task: name\n        });\n      }\n\n      const resolvedTaskArguments = _this._resolveValidTaskArguments(taskDefinition, taskArguments);\n\n      try {\n        return await _this._runTaskDefinition(taskDefinition, resolvedTaskArguments);\n      } catch (e) {\n        (0, config_loading_1.analyzeModuleNotFoundError)(e, _this.config.paths.configFile); // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n        throw e;\n      }\n    };\n\n    log(\"Creating HardhatRuntimeEnvironment\");\n    const networkName = hardhatArguments.network !== undefined ? hardhatArguments.network : config.defaultNetwork;\n    const networkConfig = config.networks[networkName];\n\n    if (networkConfig === undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.CONFIG_NOT_FOUND, {\n        network: networkName\n      });\n    }\n\n    this.artifacts = new artifacts_1.Artifacts(config.paths.artifacts);\n    const provider = (0, lazy_1.lazyObject)(() => {\n      log(`Creating provider for network ${networkName}`);\n      return (0, construction_1.createProvider)(networkName, networkConfig, this.config.paths, this.artifacts, experimentalHardhatNetworkMessageTraceHooks.map(hook => (trace, isCallMessageTrace) => hook(this, trace, isCallMessageTrace)));\n    });\n    this.network = {\n      name: networkName,\n      config: config.networks[networkName],\n      provider\n    };\n    this._extenders = extenders;\n    extenders.forEach(extender => extender(this));\n  }\n  /**\n   * Injects the properties of `this` (the Hardhat Runtime Environment) into the global scope.\n   *\n   * @param blacklist a list of property names that won't be injected.\n   *\n   * @returns a function that restores the previous environment.\n   */\n\n\n  injectToGlobal() {\n    let blacklist = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Environment._BLACKLISTED_PROPERTIES;\n    const globalAsAny = global;\n    const previousValues = {};\n    const previousHre = globalAsAny.hre;\n    globalAsAny.hre = this;\n\n    for (const [key, value] of Object.entries(this)) {\n      if (blacklist.includes(key)) {\n        continue;\n      }\n\n      previousValues[key] = globalAsAny[key];\n      globalAsAny[key] = value;\n    }\n\n    return () => {\n      for (const [key, _] of Object.entries(this)) {\n        if (blacklist.includes(key)) {\n          continue;\n        }\n\n        globalAsAny.hre = previousHre;\n        globalAsAny[key] = previousValues[key];\n      }\n    };\n  }\n\n  async _runTaskDefinition(taskDefinition, taskArguments) {\n    var _this2 = this;\n\n    let runSuperFunction;\n\n    if (taskDefinition instanceof task_definitions_1.OverriddenTaskDefinition) {\n      runSuperFunction = async function () {\n        let _taskArguments = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : taskArguments;\n\n        log(\"Running %s's super\", taskDefinition.name);\n        return _this2._runTaskDefinition(taskDefinition.parentTaskDefinition, _taskArguments);\n      };\n\n      runSuperFunction.isDefined = true;\n    } else {\n      runSuperFunction = async () => {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.TASK_DEFINITIONS.RUNSUPER_NOT_AVAILABLE, {\n          taskName: taskDefinition.name\n        });\n      };\n\n      runSuperFunction.isDefined = false;\n    }\n\n    const runSuper = runSuperFunction;\n    const globalAsAny = global;\n    const previousRunSuper = globalAsAny.runSuper;\n    globalAsAny.runSuper = runSuper;\n    const uninjectFromGlobal = this.injectToGlobal();\n\n    try {\n      return await taskDefinition.action(taskArguments, this, runSuper);\n    } finally {\n      uninjectFromGlobal();\n      globalAsAny.runSuper = previousRunSuper;\n    }\n  }\n  /**\n   * Check that task arguments are within TaskDefinition defined params constraints.\n   * Also, populate missing, non-mandatory arguments with default param values (if any).\n   *\n   * @private\n   * @throws HardhatError if any of the following are true:\n   *  > a required argument is missing\n   *  > an argument's value's type doesn't match the defined param type\n   *\n   * @param taskDefinition\n   * @param taskArguments\n   * @returns resolvedTaskArguments\n   */\n\n\n  _resolveValidTaskArguments(taskDefinition, taskArguments) {\n    const {\n      paramDefinitions,\n      positionalParamDefinitions\n    } = taskDefinition;\n    const nonPositionalParamDefinitions = Object.values(paramDefinitions); // gather all task param definitions\n\n    const allTaskParamDefinitions = [...nonPositionalParamDefinitions, ...positionalParamDefinitions];\n    const initResolvedArguments = {\n      errors: [],\n      values: {}\n    };\n    const resolvedArguments = allTaskParamDefinitions.reduce((_ref, paramDefinition) => {\n      let {\n        errors,\n        values\n      } = _ref;\n\n      try {\n        const paramName = paramDefinition.name;\n        const argumentValue = taskArguments[paramName];\n\n        const resolvedArgumentValue = this._resolveArgument(paramDefinition, argumentValue);\n\n        if (resolvedArgumentValue !== undefined) {\n          values[paramName] = resolvedArgumentValue;\n        }\n      } catch (error) {\n        if (errors_1.HardhatError.isHardhatError(error)) {\n          errors.push(error);\n        }\n      }\n\n      return {\n        errors,\n        values\n      };\n    }, initResolvedArguments);\n    const {\n      errors: resolveErrors,\n      values: resolvedValues\n    } = resolvedArguments; // if has argument errors, throw the first one\n\n    if (resolveErrors.length > 0) {\n      throw resolveErrors[0];\n    } // append the rest of arguments that where not in the task param definitions\n\n\n    const resolvedTaskArguments = Object.assign(Object.assign({}, taskArguments), resolvedValues);\n    return resolvedTaskArguments;\n  }\n  /**\n   * Resolves an argument according to a ParamDefinition rules.\n   *\n   * @param paramDefinition\n   * @param argumentValue\n   * @private\n   */\n\n\n  _resolveArgument(paramDefinition, argumentValue) {\n    const {\n      name,\n      isOptional,\n      defaultValue\n    } = paramDefinition;\n\n    if (argumentValue === undefined) {\n      if (isOptional) {\n        // undefined & optional argument -> return defaultValue\n        return defaultValue;\n      } // undefined & mandatory argument -> error\n\n\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n        param: name\n      });\n    } // arg was present -> validate type, if applicable\n\n\n    this._checkTypeValidation(paramDefinition, argumentValue);\n\n    return argumentValue;\n  }\n  /**\n   * Checks if value is valid for the specified param definition.\n   *\n   * @param paramDefinition {ParamDefinition} - the param definition for validation\n   * @param argumentValue - the value to be validated\n   * @private\n   * @throws HH301 if value is not valid for the param type\n   */\n\n\n  _checkTypeValidation(paramDefinition, argumentValue) {\n    const {\n      name: paramName,\n      type,\n      isVariadic\n    } = paramDefinition; // in case of variadic param, argValue is an array and the type validation must pass for all values.\n    // otherwise, it's a single value that is to be validated\n\n    const argumentValueContainer = isVariadic ? argumentValue : [argumentValue];\n\n    for (const value of argumentValueContainer) {\n      type.validate(paramName, value);\n    }\n  }\n\n}\n\nexports.Environment = Environment;\nEnvironment._BLACKLISTED_PROPERTIES = [\"injectToGlobal\", \"_runTaskDefinition\"];","map":{"version":3,"mappings":"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","names":["log","Environment","constructor","config","hardhatArguments","tasks","extenders","experimentalHardhatNetworkMessageTraceHooks","name","taskArguments","taskDefinition","undefined","errors_1","errors_list_1","ARGUMENTS","UNRECOGNIZED_TASK","task","resolvedTaskArguments","_resolveValidTaskArguments","_runTaskDefinition","e","paths","configFile","networkName","network","defaultNetwork","networkConfig","networks","NETWORK","CONFIG_NOT_FOUND","artifacts","artifacts_1","provider","map","hook","trace","isCallMessageTrace","_extenders","forEach","extender","injectToGlobal","blacklist","_BLACKLISTED_PROPERTIES","globalAsAny","global","previousValues","previousHre","hre","key","value","Object","entries","includes","_","runSuperFunction","task_definitions_1","_taskArguments","parentTaskDefinition","isDefined","TASK_DEFINITIONS","RUNSUPER_NOT_AVAILABLE","taskName","runSuper","previousRunSuper","uninjectFromGlobal","action","paramDefinitions","positionalParamDefinitions","nonPositionalParamDefinitions","values","allTaskParamDefinitions","initResolvedArguments","errors","resolvedArguments","reduce","paramDefinition","paramName","argumentValue","resolvedArgumentValue","_resolveArgument","error","isHardhatError","push","resolveErrors","resolvedValues","length","isOptional","defaultValue","MISSING_TASK_ARGUMENT","param","_checkTypeValidation","type","isVariadic","argumentValueContainer","validate","exports"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/internal/core/runtime-environment.ts"],"sourcesContent":["import debug from \"debug\";\n\nimport {\n  Artifacts as IArtifacts,\n  EnvironmentExtender,\n  ExperimentalHardhatNetworkMessageTraceHook,\n  HardhatArguments,\n  HardhatConfig,\n  HardhatRuntimeEnvironment,\n  Network,\n  ParamDefinition,\n  RunSuperFunction,\n  RunTaskFunction,\n  TaskArguments,\n  TaskDefinition,\n  TasksMap,\n} from \"../../types\";\nimport { Artifacts } from \"../artifacts\";\nimport { MessageTrace } from \"../hardhat-network/stack-traces/message-trace\";\nimport { lazyObject } from \"../util/lazy\";\n\nimport { analyzeModuleNotFoundError } from \"./config/config-loading\";\nimport { HardhatError } from \"./errors\";\nimport { ERRORS } from \"./errors-list\";\nimport { createProvider } from \"./providers/construction\";\nimport { OverriddenTaskDefinition } from \"./tasks/task-definitions\";\n\nconst log = debug(\"hardhat:core:hre\");\n\nexport class Environment implements HardhatRuntimeEnvironment {\n  private static readonly _BLACKLISTED_PROPERTIES: string[] = [\n    \"injectToGlobal\",\n    \"_runTaskDefinition\",\n  ];\n\n  public network: Network;\n\n  public artifacts: IArtifacts;\n\n  private readonly _extenders: EnvironmentExtender[];\n\n  /**\n   * Initializes the Hardhat Runtime Environment and the given\n   * extender functions.\n   *\n   * @remarks The extenders' execution order is given by the order\n   * of the requires in the hardhat's config file and its plugins.\n   *\n   * @param config The hardhat's config object.\n   * @param hardhatArguments The parsed hardhat's arguments.\n   * @param tasks A map of tasks.\n   * @param extenders A list of extenders.\n   */\n  constructor(\n    public readonly config: HardhatConfig,\n    public readonly hardhatArguments: HardhatArguments,\n    public readonly tasks: TasksMap,\n    extenders: EnvironmentExtender[] = [],\n    experimentalHardhatNetworkMessageTraceHooks: ExperimentalHardhatNetworkMessageTraceHook[] = []\n  ) {\n    log(\"Creating HardhatRuntimeEnvironment\");\n\n    const networkName =\n      hardhatArguments.network !== undefined\n        ? hardhatArguments.network\n        : config.defaultNetwork;\n\n    const networkConfig = config.networks[networkName];\n\n    if (networkConfig === undefined) {\n      throw new HardhatError(ERRORS.NETWORK.CONFIG_NOT_FOUND, {\n        network: networkName,\n      });\n    }\n\n    this.artifacts = new Artifacts(config.paths.artifacts);\n\n    const provider = lazyObject(() => {\n      log(`Creating provider for network ${networkName}`);\n      return createProvider(\n        networkName,\n        networkConfig,\n        this.config.paths,\n        this.artifacts,\n        experimentalHardhatNetworkMessageTraceHooks.map(\n          (hook) => (trace: MessageTrace, isCallMessageTrace: boolean) =>\n            hook(this, trace, isCallMessageTrace)\n        )\n      );\n    });\n\n    this.network = {\n      name: networkName,\n      config: config.networks[networkName],\n      provider,\n    };\n\n    this._extenders = extenders;\n\n    extenders.forEach((extender) => extender(this));\n  }\n\n  /**\n   * Executes the task with the given name.\n   *\n   * @param name The task's name.\n   * @param taskArguments A map of task's arguments.\n   *\n   * @throws a HH303 if there aren't any defined tasks with the given name.\n   * @returns a promise with the task's execution result.\n   */\n  public readonly run: RunTaskFunction = async (name, taskArguments = {}) => {\n    const taskDefinition = this.tasks[name];\n\n    log(\"Running task %s\", name);\n\n    if (taskDefinition === undefined) {\n      throw new HardhatError(ERRORS.ARGUMENTS.UNRECOGNIZED_TASK, {\n        task: name,\n      });\n    }\n\n    const resolvedTaskArguments = this._resolveValidTaskArguments(\n      taskDefinition,\n      taskArguments\n    );\n\n    try {\n      return await this._runTaskDefinition(\n        taskDefinition,\n        resolvedTaskArguments\n      );\n    } catch (e) {\n      analyzeModuleNotFoundError(e, this.config.paths.configFile);\n\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw e;\n    }\n  };\n\n  /**\n   * Injects the properties of `this` (the Hardhat Runtime Environment) into the global scope.\n   *\n   * @param blacklist a list of property names that won't be injected.\n   *\n   * @returns a function that restores the previous environment.\n   */\n  public injectToGlobal(\n    blacklist: string[] = Environment._BLACKLISTED_PROPERTIES\n  ): () => void {\n    const globalAsAny = global as any;\n\n    const previousValues: { [name: string]: any } = {};\n    const previousHre = globalAsAny.hre;\n\n    globalAsAny.hre = this;\n\n    for (const [key, value] of Object.entries(this)) {\n      if (blacklist.includes(key)) {\n        continue;\n      }\n\n      previousValues[key] = globalAsAny[key];\n      globalAsAny[key] = value;\n    }\n\n    return () => {\n      for (const [key, _] of Object.entries(this)) {\n        if (blacklist.includes(key)) {\n          continue;\n        }\n\n        globalAsAny.hre = previousHre;\n        globalAsAny[key] = previousValues[key];\n      }\n    };\n  }\n\n  private async _runTaskDefinition(\n    taskDefinition: TaskDefinition,\n    taskArguments: TaskArguments\n  ) {\n    let runSuperFunction: any;\n\n    if (taskDefinition instanceof OverriddenTaskDefinition) {\n      runSuperFunction = async (\n        _taskArguments: TaskArguments = taskArguments\n      ) => {\n        log(\"Running %s's super\", taskDefinition.name);\n\n        return this._runTaskDefinition(\n          taskDefinition.parentTaskDefinition,\n          _taskArguments\n        );\n      };\n\n      runSuperFunction.isDefined = true;\n    } else {\n      runSuperFunction = async () => {\n        throw new HardhatError(ERRORS.TASK_DEFINITIONS.RUNSUPER_NOT_AVAILABLE, {\n          taskName: taskDefinition.name,\n        });\n      };\n\n      runSuperFunction.isDefined = false;\n    }\n\n    const runSuper: RunSuperFunction<TaskArguments> = runSuperFunction;\n\n    const globalAsAny = global as any;\n    const previousRunSuper: any = globalAsAny.runSuper;\n    globalAsAny.runSuper = runSuper;\n\n    const uninjectFromGlobal = this.injectToGlobal();\n\n    try {\n      return await taskDefinition.action(taskArguments, this, runSuper);\n    } finally {\n      uninjectFromGlobal();\n      globalAsAny.runSuper = previousRunSuper;\n    }\n  }\n\n  /**\n   * Check that task arguments are within TaskDefinition defined params constraints.\n   * Also, populate missing, non-mandatory arguments with default param values (if any).\n   *\n   * @private\n   * @throws HardhatError if any of the following are true:\n   *  > a required argument is missing\n   *  > an argument's value's type doesn't match the defined param type\n   *\n   * @param taskDefinition\n   * @param taskArguments\n   * @returns resolvedTaskArguments\n   */\n  private _resolveValidTaskArguments(\n    taskDefinition: TaskDefinition,\n    taskArguments: TaskArguments\n  ): TaskArguments {\n    const { paramDefinitions, positionalParamDefinitions } = taskDefinition;\n\n    const nonPositionalParamDefinitions = Object.values(paramDefinitions);\n\n    // gather all task param definitions\n    const allTaskParamDefinitions = [\n      ...nonPositionalParamDefinitions,\n      ...positionalParamDefinitions,\n    ];\n\n    const initResolvedArguments: {\n      errors: HardhatError[];\n      values: TaskArguments;\n    } = { errors: [], values: {} };\n\n    const resolvedArguments = allTaskParamDefinitions.reduce(\n      ({ errors, values }, paramDefinition) => {\n        try {\n          const paramName = paramDefinition.name;\n          const argumentValue = taskArguments[paramName];\n          const resolvedArgumentValue = this._resolveArgument(\n            paramDefinition,\n            argumentValue\n          );\n          if (resolvedArgumentValue !== undefined) {\n            values[paramName] = resolvedArgumentValue;\n          }\n        } catch (error) {\n          if (HardhatError.isHardhatError(error)) {\n            errors.push(error);\n          }\n        }\n        return { errors, values };\n      },\n      initResolvedArguments\n    );\n\n    const { errors: resolveErrors, values: resolvedValues } = resolvedArguments;\n\n    // if has argument errors, throw the first one\n    if (resolveErrors.length > 0) {\n      throw resolveErrors[0];\n    }\n\n    // append the rest of arguments that where not in the task param definitions\n    const resolvedTaskArguments = { ...taskArguments, ...resolvedValues };\n\n    return resolvedTaskArguments;\n  }\n\n  /**\n   * Resolves an argument according to a ParamDefinition rules.\n   *\n   * @param paramDefinition\n   * @param argumentValue\n   * @private\n   */\n  private _resolveArgument(\n    paramDefinition: ParamDefinition<any>,\n    argumentValue: any\n  ) {\n    const { name, isOptional, defaultValue } = paramDefinition;\n\n    if (argumentValue === undefined) {\n      if (isOptional) {\n        // undefined & optional argument -> return defaultValue\n        return defaultValue;\n      }\n\n      // undefined & mandatory argument -> error\n      throw new HardhatError(ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n        param: name,\n      });\n    }\n\n    // arg was present -> validate type, if applicable\n    this._checkTypeValidation(paramDefinition, argumentValue);\n\n    return argumentValue;\n  }\n\n  /**\n   * Checks if value is valid for the specified param definition.\n   *\n   * @param paramDefinition {ParamDefinition} - the param definition for validation\n   * @param argumentValue - the value to be validated\n   * @private\n   * @throws HH301 if value is not valid for the param type\n   */\n  private _checkTypeValidation(\n    paramDefinition: ParamDefinition<any>,\n    argumentValue: any\n  ) {\n    const { name: paramName, type, isVariadic } = paramDefinition;\n\n    // in case of variadic param, argValue is an array and the type validation must pass for all values.\n    // otherwise, it's a single value that is to be validated\n    const argumentValueContainer = isVariadic ? argumentValue : [argumentValue];\n\n    for (const value of argumentValueContainer) {\n      type.validate(paramName, value);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}