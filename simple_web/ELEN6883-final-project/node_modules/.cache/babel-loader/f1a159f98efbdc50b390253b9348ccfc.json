{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { BaseBackend, getCurrentHub } from '@sentry/core';\nimport { Severity } from '@sentry/types';\nimport { addExceptionMechanism, addExceptionTypeValue, Dsn, extractExceptionKeysForMessage, isError, isPlainObject, normalizeToSize, SyncPromise } from '@sentry/utils';\nimport { extractStackFromError, parseError, parseStack, prepareFramesForEvent } from './parsers';\nimport { HTTPSTransport, HTTPTransport } from './transports';\n/**\n * The Sentry Node SDK Backend.\n * @hidden\n */\n\nvar NodeBackend =\n/** @class */\nfunction (_super) {\n  __extends(NodeBackend, _super);\n\n  function NodeBackend() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n\n\n  NodeBackend.prototype.eventFromException = function (exception, hint) {\n    var _this = this; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    var ex = exception;\n    var mechanism = {\n      handled: true,\n      type: 'generic'\n    };\n\n    if (!isError(exception)) {\n      if (isPlainObject(exception)) {\n        // This will allow us to group events based on top-level keys\n        // which is much better than creating new group when any key/value change\n        var message = \"Non-Error exception captured with keys: \" + extractExceptionKeysForMessage(exception);\n        getCurrentHub().configureScope(function (scope) {\n          scope.setExtra('__serialized__', normalizeToSize(exception));\n        });\n        ex = hint && hint.syntheticException || new Error(message);\n        ex.message = message;\n      } else {\n        // This handles when someone does: `throw \"something awesome\";`\n        // We use synthesized Error here so we can extract a (rough) stack trace.\n        ex = hint && hint.syntheticException || new Error(exception);\n        ex.message = exception;\n      }\n\n      mechanism.synthetic = true;\n    }\n\n    return new SyncPromise(function (resolve, reject) {\n      return parseError(ex, _this._options).then(function (event) {\n        addExceptionTypeValue(event, undefined, undefined);\n        addExceptionMechanism(event, mechanism);\n        resolve(__assign(__assign({}, event), {\n          event_id: hint && hint.event_id\n        }));\n      }).then(null, reject);\n    });\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  NodeBackend.prototype.eventFromMessage = function (message, level, hint) {\n    var _this = this;\n\n    if (level === void 0) {\n      level = Severity.Info;\n    }\n\n    var event = {\n      event_id: hint && hint.event_id,\n      level: level,\n      message: message\n    };\n    return new SyncPromise(function (resolve) {\n      if (_this._options.attachStacktrace && hint && hint.syntheticException) {\n        var stack = hint.syntheticException ? extractStackFromError(hint.syntheticException) : [];\n        parseStack(stack, _this._options).then(function (frames) {\n          event.stacktrace = {\n            frames: prepareFramesForEvent(frames)\n          };\n          resolve(event);\n        }).then(null, function () {\n          resolve(event);\n        });\n      } else {\n        resolve(event);\n      }\n    });\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  NodeBackend.prototype._setupTransport = function () {\n    if (!this._options.dsn) {\n      // We return the noop transport here in case there is no Dsn.\n      return _super.prototype._setupTransport.call(this);\n    }\n\n    var dsn = new Dsn(this._options.dsn);\n\n    var transportOptions = __assign(__assign(__assign(__assign(__assign({}, this._options.transportOptions), this._options.httpProxy && {\n      httpProxy: this._options.httpProxy\n    }), this._options.httpsProxy && {\n      httpsProxy: this._options.httpsProxy\n    }), this._options.caCerts && {\n      caCerts: this._options.caCerts\n    }), {\n      dsn: this._options.dsn\n    });\n\n    if (this._options.transport) {\n      return new this._options.transport(transportOptions);\n    }\n\n    if (dsn.protocol === 'http') {\n      return new HTTPTransport(transportOptions);\n    }\n\n    return new HTTPSTransport(transportOptions);\n  };\n\n  return NodeBackend;\n}(BaseBackend);\n\nexport { NodeBackend };","map":{"version":3,"mappings":";AAAA,SAASA,WAAT,EAAsBC,aAAtB,QAA2C,cAA3C;AACA,SAA+CC,QAA/C,QAA4F,eAA5F;AACA,SACEC,qBADF,EAEEC,qBAFF,EAGEC,GAHF,EAIEC,8BAJF,EAKEC,OALF,EAMEC,aANF,EAOEC,eAPF,EAQEC,WARF,QASO,eATP;AAWA,SAASC,qBAAT,EAAgCC,UAAhC,EAA4CC,UAA5C,EAAwDC,qBAAxD,QAAqF,WAArF;AACA,SAASC,cAAT,EAAyBC,aAAzB,QAA8C,cAA9C;AA6BA;;;;;AAIA;AAAA;AAAA;AAAiCC;;AAAjC;;AAyGC;AAxGC;;;AAGA;;;AACOC,6CAAP,UAA0BC,SAA1B,EAA0CC,IAA1C,EAA0D;AAA1D,qBAA0D,CACxD;;;AACA,QAAIC,EAAE,GAAQF,SAAd;AACA,QAAMG,SAAS,GAAc;AAC3BC,aAAO,EAAE,IADkB;AAE3BC,UAAI,EAAE;AAFqB,KAA7B;;AAKA,QAAI,CAACjB,OAAO,CAACY,SAAD,CAAZ,EAAyB;AACvB,UAAIX,aAAa,CAACW,SAAD,CAAjB,EAA8B;AAC5B;AACA;AACA,YAAMM,OAAO,GAAG,6CAA2CnB,8BAA8B,CAACa,SAAD,CAAzF;AAEAlB,qBAAa,GAAGyB,cAAhB,CAA+B,iBAAK;AAClCC,eAAK,CAACC,QAAN,CAAe,gBAAf,EAAiCnB,eAAe,CAACU,SAAD,CAAhD;AACD,SAFD;AAIAE,UAAE,GAAID,IAAI,IAAIA,IAAI,CAACS,kBAAd,IAAqC,IAAIC,KAAJ,CAAUL,OAAV,CAA1C;AACCJ,UAAY,CAACI,OAAb,GAAuBA,OAAvB;AACF,OAXD,MAWO;AACL;AACA;AACAJ,UAAE,GAAID,IAAI,IAAIA,IAAI,CAACS,kBAAd,IAAqC,IAAIC,KAAJ,CAAUX,SAAV,CAA1C;AACCE,UAAY,CAACI,OAAb,GAAuBN,SAAvB;AACF;;AACDG,eAAS,CAACS,SAAV,GAAsB,IAAtB;AACD;;AAED,WAAO,IAAIrB,WAAJ,CAAuB,UAACsB,OAAD,EAAUC,MAAV,EAAgB;AAC5C,uBAAU,CAACZ,EAAD,EAAca,KAAI,CAACC,QAAnB,CAAV,CACGC,IADH,CACQ,iBAAK;AACThC,6BAAqB,CAACiC,KAAD,EAAQC,SAAR,EAAmBA,SAAnB,CAArB;AACAnC,6BAAqB,CAACkC,KAAD,EAAQf,SAAR,CAArB;AAEAU,eAAO,uBACFK,KADE,GACG;AACRE,kBAAQ,EAAEnB,IAAI,IAAIA,IAAI,CAACmB;AADf,SADH,EAAP;AAID,OATH,EAUGH,IAVH,CAUQ,IAVR,EAUcH,MAVd;AAUqB,KAXhB,CAAP;AAaD,GA1CM;AA4CP;;;;;AAGOf,2CAAP,UAAwBO,OAAxB,EAAyCe,KAAzC,EAA0EpB,IAA1E,EAA0F;AAA1F;;AAAyC;AAAAoB,cAAkBtC,QAAQ,CAACuC,IAA3B;AAA+B;;AACtE,QAAMJ,KAAK,GAAU;AACnBE,cAAQ,EAAEnB,IAAI,IAAIA,IAAI,CAACmB,QADJ;AAEnBC,WAAK,OAFc;AAGnBf,aAAO;AAHY,KAArB;AAMA,WAAO,IAAIf,WAAJ,CAAuB,mBAAO;AACnC,UAAIwB,KAAI,CAACC,QAAL,CAAcO,gBAAd,IAAkCtB,IAAlC,IAA0CA,IAAI,CAACS,kBAAnD,EAAuE;AACrE,YAAMc,KAAK,GAAGvB,IAAI,CAACS,kBAAL,GAA0BlB,qBAAqB,CAACS,IAAI,CAACS,kBAAN,CAA/C,GAA2E,EAAzF;AACAhB,kBAAU,CAAC8B,KAAD,EAAQT,KAAI,CAACC,QAAb,CAAV,CACGC,IADH,CACQ,kBAAM;AACVC,eAAK,CAACO,UAAN,GAAmB;AACjBC,kBAAM,EAAE/B,qBAAqB,CAAC+B,MAAD;AADZ,WAAnB;AAGAb,iBAAO,CAACK,KAAD,CAAP;AACD,SANH,EAOGD,IAPH,CAOQ,IAPR,EAOc;AACVJ,iBAAO,CAACK,KAAD,CAAP;AACD,SATH;AAUD,OAZD,MAYO;AACLL,eAAO,CAACK,KAAD,CAAP;AACD;AACF,KAhBM,CAAP;AAiBD,GAxBM;AA0BP;;;;;AAGUnB,0CAAV;AACE,QAAI,CAAC,KAAKiB,QAAL,CAAcW,GAAnB,EAAwB;AACtB;AACA,aAAOC,iBAAMC,eAAN,CAAqBC,IAArB,CAAqB,IAArB,CAAP;AACD;;AAED,QAAMH,GAAG,GAAG,IAAIzC,GAAJ,CAAQ,KAAK8B,QAAL,CAAcW,GAAtB,CAAZ;;AAEA,QAAMI,gBAAgB,oDACjB,KAAKf,QAAL,CAAce,gBADG,GAEhB,KAAKf,QAAL,CAAcgB,SAAd,IAA2B;AAAEA,eAAS,EAAE,KAAKhB,QAAL,CAAcgB;AAA3B,KAFX,GAGhB,KAAKhB,QAAL,CAAciB,UAAd,IAA4B;AAAEA,gBAAU,EAAE,KAAKjB,QAAL,CAAciB;AAA5B,KAHZ,GAIhB,KAAKjB,QAAL,CAAckB,OAAd,IAAyB;AAAEA,aAAO,EAAE,KAAKlB,QAAL,CAAckB;AAAzB,KAJT,GAI4C;AAChEP,SAAG,EAAE,KAAKX,QAAL,CAAcW;AAD6C,KAJ5C,CAAtB;;AAQA,QAAI,KAAKX,QAAL,CAAcmB,SAAlB,EAA6B;AAC3B,aAAO,IAAI,KAAKnB,QAAL,CAAcmB,SAAlB,CAA4BJ,gBAA5B,CAAP;AACD;;AACD,QAAIJ,GAAG,CAACS,QAAJ,KAAiB,MAArB,EAA6B;AAC3B,aAAO,IAAIvC,aAAJ,CAAkBkC,gBAAlB,CAAP;AACD;;AACD,WAAO,IAAInC,cAAJ,CAAmBmC,gBAAnB,CAAP;AACD,GAvBS;;AAwBZ;AAzGA,EAAiClD,WAAjC","names":["BaseBackend","getCurrentHub","Severity","addExceptionMechanism","addExceptionTypeValue","Dsn","extractExceptionKeysForMessage","isError","isPlainObject","normalizeToSize","SyncPromise","extractStackFromError","parseError","parseStack","prepareFramesForEvent","HTTPSTransport","HTTPTransport","__extends","NodeBackend","exception","hint","ex","mechanism","handled","type","message","configureScope","scope","setExtra","syntheticException","Error","synthetic","resolve","reject","_this","_options","then","event","undefined","event_id","level","Info","attachStacktrace","stack","stacktrace","frames","dsn","_super","_setupTransport","call","transportOptions","httpProxy","httpsProxy","caCerts","transport","protocol"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/@sentry/node/src/backend.ts"],"sourcesContent":["import { BaseBackend, getCurrentHub } from '@sentry/core';\nimport { Event, EventHint, Mechanism, Options, Severity, Transport, TransportOptions } from '@sentry/types';\nimport {\n  addExceptionMechanism,\n  addExceptionTypeValue,\n  Dsn,\n  extractExceptionKeysForMessage,\n  isError,\n  isPlainObject,\n  normalizeToSize,\n  SyncPromise,\n} from '@sentry/utils';\n\nimport { extractStackFromError, parseError, parseStack, prepareFramesForEvent } from './parsers';\nimport { HTTPSTransport, HTTPTransport } from './transports';\n\n/**\n * Configuration options for the Sentry Node SDK.\n * @see NodeClient for more information.\n */\nexport interface NodeOptions extends Options {\n  /** Sets an optional server name (device name) */\n  serverName?: string;\n\n  /** Maximum time in milliseconds to wait to drain the request queue, before the process is allowed to exit. */\n  shutdownTimeout?: number;\n\n  /** Set a HTTP proxy that should be used for outbound requests. */\n  httpProxy?: string;\n\n  /** Set a HTTPS proxy that should be used for outbound requests. */\n  httpsProxy?: string;\n\n  /** HTTPS proxy certificates path */\n  caCerts?: string;\n\n  /** Sets the number of context lines for each frame when loading a file. */\n  frameContextLines?: number;\n\n  /** Callback that is executed when a fatal global error occurs. */\n  onFatalError?(error: Error): void;\n}\n\n/**\n * The Sentry Node SDK Backend.\n * @hidden\n */\nexport class NodeBackend extends BaseBackend<NodeOptions> {\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  public eventFromException(exception: any, hint?: EventHint): PromiseLike<Event> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let ex: any = exception;\n    const mechanism: Mechanism = {\n      handled: true,\n      type: 'generic',\n    };\n\n    if (!isError(exception)) {\n      if (isPlainObject(exception)) {\n        // This will allow us to group events based on top-level keys\n        // which is much better than creating new group when any key/value change\n        const message = `Non-Error exception captured with keys: ${extractExceptionKeysForMessage(exception)}`;\n\n        getCurrentHub().configureScope(scope => {\n          scope.setExtra('__serialized__', normalizeToSize(exception as Record<string, unknown>));\n        });\n\n        ex = (hint && hint.syntheticException) || new Error(message);\n        (ex as Error).message = message;\n      } else {\n        // This handles when someone does: `throw \"something awesome\";`\n        // We use synthesized Error here so we can extract a (rough) stack trace.\n        ex = (hint && hint.syntheticException) || new Error(exception as string);\n        (ex as Error).message = exception;\n      }\n      mechanism.synthetic = true;\n    }\n\n    return new SyncPromise<Event>((resolve, reject) =>\n      parseError(ex as Error, this._options)\n        .then(event => {\n          addExceptionTypeValue(event, undefined, undefined);\n          addExceptionMechanism(event, mechanism);\n\n          resolve({\n            ...event,\n            event_id: hint && hint.event_id,\n          });\n        })\n        .then(null, reject),\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public eventFromMessage(message: string, level: Severity = Severity.Info, hint?: EventHint): PromiseLike<Event> {\n    const event: Event = {\n      event_id: hint && hint.event_id,\n      level,\n      message,\n    };\n\n    return new SyncPromise<Event>(resolve => {\n      if (this._options.attachStacktrace && hint && hint.syntheticException) {\n        const stack = hint.syntheticException ? extractStackFromError(hint.syntheticException) : [];\n        parseStack(stack, this._options)\n          .then(frames => {\n            event.stacktrace = {\n              frames: prepareFramesForEvent(frames),\n            };\n            resolve(event);\n          })\n          .then(null, () => {\n            resolve(event);\n          });\n      } else {\n        resolve(event);\n      }\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  protected _setupTransport(): Transport {\n    if (!this._options.dsn) {\n      // We return the noop transport here in case there is no Dsn.\n      return super._setupTransport();\n    }\n\n    const dsn = new Dsn(this._options.dsn);\n\n    const transportOptions: TransportOptions = {\n      ...this._options.transportOptions,\n      ...(this._options.httpProxy && { httpProxy: this._options.httpProxy }),\n      ...(this._options.httpsProxy && { httpsProxy: this._options.httpsProxy }),\n      ...(this._options.caCerts && { caCerts: this._options.caCerts }),\n      dsn: this._options.dsn,\n    };\n\n    if (this._options.transport) {\n      return new this._options.transport(transportOptions);\n    }\n    if (dsn.protocol === 'http') {\n      return new HTTPTransport(transportOptions);\n    }\n    return new HTTPSTransport(transportOptions);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}