{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertHardhatInvariant = exports.applyErrorMessageTemplate = exports.NomicLabsHardhatPluginError = exports.HardhatPluginError = exports.HardhatError = exports.CustomError = void 0;\n\nconst caller_package_1 = require(\"../util/caller-package\");\n\nconst strings_1 = require(\"../util/strings\");\n\nconst errors_list_1 = require(\"./errors-list\");\n\nconst inspect = Symbol.for(\"nodejs.util.inspect.custom\");\n\nclass CustomError extends Error {\n  constructor(message, parent) {\n    // WARNING: Using super when extending a builtin class doesn't work well\n    // with TS if you are compiling to a version of JavaScript that doesn't have\n    // native classes. We don't do that in Hardhat.\n    //\n    // For more info about this, take a look at: https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    super(message);\n    this.parent = parent;\n    this.name = this.constructor.name; // We do this to avoid including the constructor in the stack trace\n\n    if (Error.captureStackTrace !== undefined) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n\n  [inspect]() {\n    var _a, _b, _c, _d, _e;\n\n    let str = this.stack;\n\n    if (this.parent !== undefined) {\n      const parentAsAny = this.parent;\n      const causeString = (_e = (_d = (_b = (_a = parentAsAny[inspect]) === null || _a === void 0 ? void 0 : _a.call(parentAsAny)) !== null && _b !== void 0 ? _b : (_c = parentAsAny.inspect) === null || _c === void 0 ? void 0 : _c.call(parentAsAny)) !== null && _d !== void 0 ? _d : parentAsAny.stack) !== null && _e !== void 0 ? _e : parentAsAny.toString();\n      const nestedCauseStr = causeString.split(\"\\n\").map(line => `    ${line}`).join(\"\\n\").trim();\n      str += `\n\n    Caused by: ${nestedCauseStr}`;\n    }\n\n    return str;\n  }\n\n}\n\nexports.CustomError = CustomError;\n\nclass HardhatError extends CustomError {\n  constructor(errorDescriptor) {\n    let messageArguments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let parentError = arguments.length > 2 ? arguments[2] : undefined;\n    const prefix = `${(0, errors_list_1.getErrorCode)(errorDescriptor)}: `;\n    const formattedMessage = applyErrorMessageTemplate(errorDescriptor.message, messageArguments);\n    super(prefix + formattedMessage, parentError);\n    this.errorDescriptor = errorDescriptor;\n    this.number = errorDescriptor.number;\n    this.messageArguments = messageArguments;\n    this._isHardhatError = true;\n    Object.setPrototypeOf(this, HardhatError.prototype);\n  }\n\n  static isHardhatError(other) {\n    return other !== undefined && other !== null && other._isHardhatError === true;\n  }\n\n  static isHardhatErrorType(other, descriptor) {\n    return HardhatError.isHardhatError(other) && other.errorDescriptor.number === descriptor.number;\n  }\n\n}\n\nexports.HardhatError = HardhatError;\n/**\n * This class is used to throw errors from hardhat plugins made by third parties.\n */\n\nclass HardhatPluginError extends CustomError {\n  constructor(pluginNameOrMessage, messageOrParent, parent) {\n    if (typeof messageOrParent === \"string\") {\n      super(messageOrParent, parent);\n      this.pluginName = pluginNameOrMessage;\n    } else {\n      super(pluginNameOrMessage, messageOrParent);\n      this.pluginName = (0, caller_package_1.getClosestCallerPackage)();\n    }\n\n    this._isHardhatPluginError = true;\n    Object.setPrototypeOf(this, HardhatPluginError.prototype);\n  }\n\n  static isHardhatPluginError(other) {\n    return other !== undefined && other !== null && other._isHardhatPluginError === true;\n  }\n\n}\n\nexports.HardhatPluginError = HardhatPluginError;\n\nclass NomicLabsHardhatPluginError extends HardhatPluginError {\n  /**\n   * This class is used to throw errors from *core* hardhat plugins. If you are\n   * developing a third-party plugin, use HardhatPluginError instead.\n   */\n  constructor(pluginName, message, parent) {\n    let shouldBeReported = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    super(pluginName, message, parent);\n    this.shouldBeReported = shouldBeReported;\n    this._isNomicLabsHardhatPluginError = true;\n    Object.setPrototypeOf(this, NomicLabsHardhatPluginError.prototype);\n  }\n\n  static isNomicLabsHardhatPluginError(other) {\n    return other !== undefined && other !== null && other._isNomicLabsHardhatPluginError === true;\n  }\n\n}\n\nexports.NomicLabsHardhatPluginError = NomicLabsHardhatPluginError;\n/**\n * This function applies error messages templates like this:\n *\n *  - Template is a string which contains a variable tags. A variable tag is a\n *    a variable name surrounded by %. Eg: %plugin1%\n *  - A variable name is a string of alphanumeric ascii characters.\n *  - Every variable tag is replaced by its value.\n *  - %% is replaced by %.\n *  - Values can't contain variable tags.\n *  - If a variable is not present in the template, but present in the values\n *    object, an error is thrown.\n *\n * @param template The template string.\n * @param values A map of variable names to their values.\n */\n\nfunction applyErrorMessageTemplate(template, values) {\n  return _applyErrorMessageTemplate(template, values, false);\n}\n\nexports.applyErrorMessageTemplate = applyErrorMessageTemplate;\n\nfunction _applyErrorMessageTemplate(template, values, isRecursiveCall) {\n  if (!isRecursiveCall) {\n    for (const variableName of Object.keys(values)) {\n      if (variableName.match(/^[a-zA-Z][a-zA-Z0-9]*$/) === null) {\n        throw new HardhatError(errors_list_1.ERRORS.INTERNAL.TEMPLATE_INVALID_VARIABLE_NAME, {\n          variable: variableName\n        });\n      }\n\n      const variableTag = `%${variableName}%`;\n\n      if (!template.includes(variableTag)) {\n        throw new HardhatError(errors_list_1.ERRORS.INTERNAL.TEMPLATE_VARIABLE_TAG_MISSING, {\n          variable: variableName\n        });\n      }\n    }\n  }\n\n  if (template.includes(\"%%\")) {\n    return template.split(\"%%\").map(part => _applyErrorMessageTemplate(part, values, true)).join(\"%\");\n  }\n\n  for (const variableName of Object.keys(values)) {\n    let value;\n\n    if (values[variableName] === undefined) {\n      value = \"undefined\";\n    } else if (values[variableName] === null) {\n      value = \"null\";\n    } else {\n      value = values[variableName].toString();\n    }\n\n    if (value === undefined) {\n      value = \"undefined\";\n    }\n\n    const variableTag = `%${variableName}%`;\n\n    if (value.match(/%([a-zA-Z][a-zA-Z0-9]*)?%/) !== null) {\n      throw new HardhatError(errors_list_1.ERRORS.INTERNAL.TEMPLATE_VALUE_CONTAINS_VARIABLE_TAG, {\n        variable: variableName\n      });\n    }\n\n    template = (0, strings_1.replaceAll)(template, variableTag, value);\n  }\n\n  return template;\n}\n\nfunction assertHardhatInvariant(invariant, message) {\n  if (!invariant) {\n    throw new HardhatError(errors_list_1.ERRORS.GENERAL.ASSERTION_ERROR, {\n      message\n    });\n  }\n}\n\nexports.assertHardhatInvariant = assertHardhatInvariant;","map":{"version":3,"mappings":"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","names":["inspect","Symbol","for","CustomError","Error","constructor","message","parent","name","captureStackTrace","undefined","str","stack","parentAsAny","causeString","_a","_b","_c","_d","_e","toString","nestedCauseStr","split","map","line","join","trim","exports","HardhatError","errorDescriptor","messageArguments","parentError","prefix","formattedMessage","applyErrorMessageTemplate","number","_isHardhatError","Object","setPrototypeOf","prototype","isHardhatError","other","isHardhatErrorType","descriptor","HardhatPluginError","pluginNameOrMessage","messageOrParent","pluginName","_isHardhatPluginError","isHardhatPluginError","NomicLabsHardhatPluginError","shouldBeReported","_isNomicLabsHardhatPluginError","isNomicLabsHardhatPluginError","template","values","_applyErrorMessageTemplate","isRecursiveCall","variableName","keys","match","errors_list_1","INTERNAL","TEMPLATE_INVALID_VARIABLE_NAME","variable","variableTag","includes","TEMPLATE_VARIABLE_TAG_MISSING","part","value","TEMPLATE_VALUE_CONTAINS_VARIABLE_TAG","assertHardhatInvariant","invariant","GENERAL","ASSERTION_ERROR"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/internal/core/errors.ts"],"sourcesContent":["import { getClosestCallerPackage } from \"../util/caller-package\";\nimport { replaceAll } from \"../util/strings\";\n\nimport { ErrorDescriptor, ERRORS, getErrorCode } from \"./errors-list\";\n\nconst inspect = Symbol.for(\"nodejs.util.inspect.custom\");\n\nexport class CustomError extends Error {\n  constructor(message: string, public readonly parent?: Error) {\n    // WARNING: Using super when extending a builtin class doesn't work well\n    // with TS if you are compiling to a version of JavaScript that doesn't have\n    // native classes. We don't do that in Hardhat.\n    //\n    // For more info about this, take a look at: https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    super(message);\n\n    this.name = this.constructor.name;\n\n    // We do this to avoid including the constructor in the stack trace\n    if ((Error as any).captureStackTrace !== undefined) {\n      (Error as any).captureStackTrace(this, this.constructor);\n    }\n  }\n\n  public [inspect]() {\n    let str = this.stack;\n    if (this.parent !== undefined) {\n      const parentAsAny = this.parent as any;\n      const causeString =\n        parentAsAny[inspect]?.() ??\n        parentAsAny.inspect?.() ??\n        parentAsAny.stack ??\n        parentAsAny.toString();\n      const nestedCauseStr = causeString\n        .split(\"\\n\")\n        .map((line: string) => `    ${line}`)\n        .join(\"\\n\")\n        .trim();\n      str += `\n\n    Caused by: ${nestedCauseStr}`;\n    }\n    return str;\n  }\n}\n\nexport class HardhatError extends CustomError {\n  public static isHardhatError(other: any): other is HardhatError {\n    return (\n      other !== undefined && other !== null && other._isHardhatError === true\n    );\n  }\n\n  public static isHardhatErrorType(\n    other: any,\n    descriptor: ErrorDescriptor\n  ): other is HardhatError {\n    return (\n      HardhatError.isHardhatError(other) &&\n      other.errorDescriptor.number === descriptor.number\n    );\n  }\n\n  public readonly errorDescriptor: ErrorDescriptor;\n  public readonly number: number;\n  public readonly messageArguments: Record<string, any>;\n\n  private readonly _isHardhatError: boolean;\n\n  constructor(\n    errorDescriptor: ErrorDescriptor,\n    messageArguments: Record<string, any> = {},\n    parentError?: Error\n  ) {\n    const prefix = `${getErrorCode(errorDescriptor)}: `;\n\n    const formattedMessage = applyErrorMessageTemplate(\n      errorDescriptor.message,\n      messageArguments\n    );\n\n    super(prefix + formattedMessage, parentError);\n\n    this.errorDescriptor = errorDescriptor;\n    this.number = errorDescriptor.number;\n    this.messageArguments = messageArguments;\n\n    this._isHardhatError = true;\n    Object.setPrototypeOf(this, HardhatError.prototype);\n  }\n}\n\n/**\n * This class is used to throw errors from hardhat plugins made by third parties.\n */\nexport class HardhatPluginError extends CustomError {\n  public static isHardhatPluginError(other: any): other is HardhatPluginError {\n    return (\n      other !== undefined &&\n      other !== null &&\n      other._isHardhatPluginError === true\n    );\n  }\n\n  public readonly pluginName: string;\n\n  private readonly _isHardhatPluginError: boolean;\n\n  /**\n   * Creates a HardhatPluginError.\n   *\n   * @param pluginName The name of the plugin.\n   * @param message An error message that will be shown to the user.\n   * @param parent The error that causes this error to be thrown.\n   */\n  constructor(pluginName: string, message: string, parent?: Error);\n\n  /**\n   * A DEPRECATED constructor that automatically obtains the caller package and\n   * use it as plugin name.\n   *\n   * @deprecated Use the above constructor.\n   *\n   * @param message An error message that will be shown to the user.\n   * @param parent The error that causes this error to be thrown.\n   */\n  constructor(message: string, parent?: Error);\n\n  constructor(\n    pluginNameOrMessage: string,\n    messageOrParent?: string | Error,\n    parent?: Error\n  ) {\n    if (typeof messageOrParent === \"string\") {\n      super(messageOrParent, parent);\n      this.pluginName = pluginNameOrMessage;\n    } else {\n      super(pluginNameOrMessage, messageOrParent);\n      this.pluginName = getClosestCallerPackage()!;\n    }\n\n    this._isHardhatPluginError = true;\n    Object.setPrototypeOf(this, HardhatPluginError.prototype);\n  }\n}\n\nexport class NomicLabsHardhatPluginError extends HardhatPluginError {\n  public static isNomicLabsHardhatPluginError(\n    other: any\n  ): other is NomicLabsHardhatPluginError {\n    return (\n      other !== undefined &&\n      other !== null &&\n      other._isNomicLabsHardhatPluginError === true\n    );\n  }\n\n  private readonly _isNomicLabsHardhatPluginError: boolean;\n\n  /**\n   * This class is used to throw errors from *core* hardhat plugins. If you are\n   * developing a third-party plugin, use HardhatPluginError instead.\n   */\n  constructor(\n    pluginName: string,\n    message: string,\n    parent?: Error,\n    public shouldBeReported = false\n  ) {\n    super(pluginName, message, parent);\n\n    this._isNomicLabsHardhatPluginError = true;\n    Object.setPrototypeOf(this, NomicLabsHardhatPluginError.prototype);\n  }\n}\n\n/**\n * This function applies error messages templates like this:\n *\n *  - Template is a string which contains a variable tags. A variable tag is a\n *    a variable name surrounded by %. Eg: %plugin1%\n *  - A variable name is a string of alphanumeric ascii characters.\n *  - Every variable tag is replaced by its value.\n *  - %% is replaced by %.\n *  - Values can't contain variable tags.\n *  - If a variable is not present in the template, but present in the values\n *    object, an error is thrown.\n *\n * @param template The template string.\n * @param values A map of variable names to their values.\n */\nexport function applyErrorMessageTemplate(\n  template: string,\n  values: { [templateVar: string]: any }\n): string {\n  return _applyErrorMessageTemplate(template, values, false);\n}\n\nfunction _applyErrorMessageTemplate(\n  template: string,\n  values: { [templateVar: string]: any },\n  isRecursiveCall: boolean\n): string {\n  if (!isRecursiveCall) {\n    for (const variableName of Object.keys(values)) {\n      if (variableName.match(/^[a-zA-Z][a-zA-Z0-9]*$/) === null) {\n        throw new HardhatError(ERRORS.INTERNAL.TEMPLATE_INVALID_VARIABLE_NAME, {\n          variable: variableName,\n        });\n      }\n\n      const variableTag = `%${variableName}%`;\n\n      if (!template.includes(variableTag)) {\n        throw new HardhatError(ERRORS.INTERNAL.TEMPLATE_VARIABLE_TAG_MISSING, {\n          variable: variableName,\n        });\n      }\n    }\n  }\n\n  if (template.includes(\"%%\")) {\n    return template\n      .split(\"%%\")\n      .map((part) => _applyErrorMessageTemplate(part, values, true))\n      .join(\"%\");\n  }\n\n  for (const variableName of Object.keys(values)) {\n    let value: string;\n\n    if (values[variableName] === undefined) {\n      value = \"undefined\";\n    } else if (values[variableName] === null) {\n      value = \"null\";\n    } else {\n      value = values[variableName].toString();\n    }\n\n    if (value === undefined) {\n      value = \"undefined\";\n    }\n\n    const variableTag = `%${variableName}%`;\n\n    if (value.match(/%([a-zA-Z][a-zA-Z0-9]*)?%/) !== null) {\n      throw new HardhatError(\n        ERRORS.INTERNAL.TEMPLATE_VALUE_CONTAINS_VARIABLE_TAG,\n        { variable: variableName }\n      );\n    }\n\n    template = replaceAll(template, variableTag, value);\n  }\n\n  return template;\n}\n\nexport function assertHardhatInvariant(\n  invariant: boolean,\n  message: string\n): asserts invariant {\n  if (!invariant) {\n    throw new HardhatError(ERRORS.GENERAL.ASSERTION_ERROR, { message });\n  }\n}\n"]},"metadata":{},"sourceType":"script"}