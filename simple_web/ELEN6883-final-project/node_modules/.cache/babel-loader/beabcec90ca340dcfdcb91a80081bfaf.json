{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SolidityTracer = exports.FIRST_SOLC_VERSION_SUPPORTED = exports.SUPPORTED_SOLIDITY_VERSION_RANGE = void 0;\n\nconst return_data_1 = require(\"../provider/return-data\");\n\nconst error_inferrer_1 = require(\"./error-inferrer\");\n\nconst mapped_inlined_internal_functions_heuristics_1 = require(\"./mapped-inlined-internal-functions-heuristics\");\n\nconst message_trace_1 = require(\"./message-trace\");\n\nconst model_1 = require(\"./model\");\n\nconst opcodes_1 = require(\"./opcodes\");\n\nconst solidity_stack_trace_1 = require(\"./solidity-stack-trace\");\n\nexports.SUPPORTED_SOLIDITY_VERSION_RANGE = \"<=0.8.9\";\nexports.FIRST_SOLC_VERSION_SUPPORTED = \"0.5.1\";\n\nclass SolidityTracer {\n  constructor() {\n    this._errorInferrer = new error_inferrer_1.ErrorInferrer();\n  }\n\n  getStackTrace(maybeDecodedMessageTrace) {\n    if (maybeDecodedMessageTrace.error === undefined) {\n      return [];\n    }\n\n    if ((0, message_trace_1.isPrecompileTrace)(maybeDecodedMessageTrace)) {\n      return this._getPrecompileMessageStackTrace(maybeDecodedMessageTrace);\n    }\n\n    if ((0, message_trace_1.isDecodedCreateTrace)(maybeDecodedMessageTrace)) {\n      return this._getCreateMessageStackTrace(maybeDecodedMessageTrace);\n    }\n\n    if ((0, message_trace_1.isDecodedCallTrace)(maybeDecodedMessageTrace)) {\n      return this._getCallMessageStackTrace(maybeDecodedMessageTrace);\n    }\n\n    return this._getUnrecognizedMessageStackTrace(maybeDecodedMessageTrace);\n  }\n\n  _getCallMessageStackTrace(trace) {\n    const inferredError = this._errorInferrer.inferBeforeTracingCallMessage(trace);\n\n    if (inferredError !== undefined) {\n      return inferredError;\n    }\n\n    return this._traceEvmExecution(trace);\n  }\n\n  _getUnrecognizedMessageStackTrace(trace) {\n    const subtrace = this._getLastSubtrace(trace);\n\n    if (subtrace !== undefined) {\n      // This is not a very exact heuristic, but most of the time it will be right, as solidity\n      // reverts if a call fails, and most contracts are in solidity\n      if (subtrace.error !== undefined && trace.returnData.equals(subtrace.returnData)) {\n        let unrecognizedEntry;\n\n        if ((0, message_trace_1.isCreateTrace)(trace)) {\n          unrecognizedEntry = {\n            type: solidity_stack_trace_1.StackTraceEntryType.UNRECOGNIZED_CREATE_CALLSTACK_ENTRY\n          };\n        } else {\n          unrecognizedEntry = {\n            type: solidity_stack_trace_1.StackTraceEntryType.UNRECOGNIZED_CONTRACT_CALLSTACK_ENTRY,\n            address: trace.address\n          };\n        }\n\n        return [unrecognizedEntry, ...this.getStackTrace(subtrace)];\n      }\n    }\n\n    if ((0, message_trace_1.isCreateTrace)(trace)) {\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.UNRECOGNIZED_CREATE_ERROR,\n        message: new return_data_1.ReturnData(trace.returnData)\n      }];\n    }\n\n    return [{\n      type: solidity_stack_trace_1.StackTraceEntryType.UNRECOGNIZED_CONTRACT_ERROR,\n      address: trace.address,\n      message: new return_data_1.ReturnData(trace.returnData)\n    }];\n  }\n\n  _getCreateMessageStackTrace(trace) {\n    const inferredError = this._errorInferrer.inferBeforeTracingCreateMessage(trace);\n\n    if (inferredError !== undefined) {\n      return inferredError;\n    }\n\n    return this._traceEvmExecution(trace);\n  }\n\n  _getPrecompileMessageStackTrace(trace) {\n    return [{\n      type: solidity_stack_trace_1.StackTraceEntryType.PRECOMPILE_ERROR,\n      precompile: trace.precompile\n    }];\n  }\n\n  _traceEvmExecution(trace) {\n    const stackTrace = this._rawTraceEvmExecution(trace);\n\n    if ((0, mapped_inlined_internal_functions_heuristics_1.stackTraceMayRequireAdjustments)(stackTrace, trace)) {\n      return (0, mapped_inlined_internal_functions_heuristics_1.adjustStackTrace)(stackTrace, trace);\n    }\n\n    return stackTrace;\n  }\n\n  _rawTraceEvmExecution(trace) {\n    const stacktrace = [];\n    let subtracesSeen = 0;\n    let jumpedIntoFunction = false;\n    const functionJumpdests = [];\n    let lastSubmessageData;\n\n    for (let stepIndex = 0; stepIndex < trace.steps.length; stepIndex++) {\n      const step = trace.steps[stepIndex];\n      const nextStep = trace.steps[stepIndex + 1];\n\n      if ((0, message_trace_1.isEvmStep)(step)) {\n        const inst = trace.bytecode.getInstruction(step.pc);\n\n        if (inst.jumpType === model_1.JumpType.INTO_FUNCTION) {\n          const nextEvmStep = nextStep; // A jump can't be followed by a subtrace\n\n          const nextInst = trace.bytecode.getInstruction(nextEvmStep.pc);\n\n          if (nextInst !== undefined && nextInst.opcode === opcodes_1.Opcode.JUMPDEST) {\n            stacktrace.push((0, error_inferrer_1.instructionToCallstackStackTraceEntry)(trace.bytecode, inst));\n\n            if (nextInst.location !== undefined) {\n              jumpedIntoFunction = true;\n            }\n\n            functionJumpdests.push(nextInst);\n          }\n        } else if (inst.jumpType === model_1.JumpType.OUTOF_FUNCTION) {\n          stacktrace.pop();\n          functionJumpdests.pop();\n        }\n      } else {\n        subtracesSeen += 1; // If there are more subtraces, this one didn't terminate the execution\n\n        if (subtracesSeen < trace.numberOfSubtraces) {\n          continue;\n        }\n\n        const submessageTrace = this.getStackTrace(step);\n        lastSubmessageData = {\n          messageTrace: step,\n          stepIndex,\n          stacktrace: submessageTrace\n        };\n      }\n    }\n\n    const stacktraceWithInferredError = this._errorInferrer.inferAfterTracing(trace, stacktrace, functionJumpdests, jumpedIntoFunction, lastSubmessageData);\n\n    return this._errorInferrer.filterRedundantFrames(stacktraceWithInferredError);\n  }\n\n  _getLastSubtrace(trace) {\n    if (trace.numberOfSubtraces < 1) {\n      return undefined;\n    }\n\n    let i = trace.steps.length - 1;\n\n    while ((0, message_trace_1.isEvmStep)(trace.steps[i])) {\n      i -= 1;\n    }\n\n    return trace.steps[i];\n  }\n\n}\n\nexports.SolidityTracer = SolidityTracer;","map":{"version":3,"mappings":"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","names":["exports","SolidityTracer","constructor","error_inferrer_1","getStackTrace","maybeDecodedMessageTrace","error","undefined","_getPrecompileMessageStackTrace","_getCreateMessageStackTrace","_getCallMessageStackTrace","_getUnrecognizedMessageStackTrace","trace","inferredError","_errorInferrer","inferBeforeTracingCallMessage","_traceEvmExecution","subtrace","_getLastSubtrace","returnData","equals","unrecognizedEntry","type","solidity_stack_trace_1","UNRECOGNIZED_CREATE_CALLSTACK_ENTRY","UNRECOGNIZED_CONTRACT_CALLSTACK_ENTRY","address","UNRECOGNIZED_CREATE_ERROR","message","return_data_1","UNRECOGNIZED_CONTRACT_ERROR","inferBeforeTracingCreateMessage","PRECOMPILE_ERROR","precompile","stackTrace","_rawTraceEvmExecution","stacktrace","subtracesSeen","jumpedIntoFunction","functionJumpdests","lastSubmessageData","stepIndex","steps","length","step","nextStep","inst","bytecode","getInstruction","pc","jumpType","model_1","INTO_FUNCTION","nextEvmStep","nextInst","opcode","opcodes_1","JUMPDEST","push","location","OUTOF_FUNCTION","pop","numberOfSubtraces","submessageTrace","messageTrace","stacktraceWithInferredError","inferAfterTracing","filterRedundantFrames","i"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/internal/hardhat-network/stack-traces/solidityTracer.ts"],"sourcesContent":["import { ReturnData } from \"../provider/return-data\";\n\nimport {\n  ErrorInferrer,\n  instructionToCallstackStackTraceEntry,\n  SubmessageData,\n} from \"./error-inferrer\";\nimport {\n  adjustStackTrace,\n  stackTraceMayRequireAdjustments,\n} from \"./mapped-inlined-internal-functions-heuristics\";\nimport {\n  DecodedCallMessageTrace,\n  DecodedCreateMessageTrace,\n  DecodedEvmMessageTrace,\n  EvmMessageTrace,\n  EvmStep,\n  isCreateTrace,\n  isDecodedCallTrace,\n  isDecodedCreateTrace,\n  isEvmStep,\n  isPrecompileTrace,\n  MessageTrace,\n  PrecompileMessageTrace,\n} from \"./message-trace\";\nimport { Instruction, JumpType } from \"./model\";\nimport { Opcode } from \"./opcodes\";\nimport {\n  SolidityStackTrace,\n  SolidityStackTraceEntry,\n  StackTraceEntryType,\n} from \"./solidity-stack-trace\";\n\nexport const SUPPORTED_SOLIDITY_VERSION_RANGE = \"<=0.8.9\";\nexport const FIRST_SOLC_VERSION_SUPPORTED = \"0.5.1\";\n\nexport class SolidityTracer {\n  private _errorInferrer = new ErrorInferrer();\n\n  public getStackTrace(\n    maybeDecodedMessageTrace: MessageTrace\n  ): SolidityStackTrace {\n    if (maybeDecodedMessageTrace.error === undefined) {\n      return [];\n    }\n\n    if (isPrecompileTrace(maybeDecodedMessageTrace)) {\n      return this._getPrecompileMessageStackTrace(maybeDecodedMessageTrace);\n    }\n\n    if (isDecodedCreateTrace(maybeDecodedMessageTrace)) {\n      return this._getCreateMessageStackTrace(maybeDecodedMessageTrace);\n    }\n\n    if (isDecodedCallTrace(maybeDecodedMessageTrace)) {\n      return this._getCallMessageStackTrace(maybeDecodedMessageTrace);\n    }\n\n    return this._getUnrecognizedMessageStackTrace(maybeDecodedMessageTrace);\n  }\n\n  private _getCallMessageStackTrace(\n    trace: DecodedCallMessageTrace\n  ): SolidityStackTrace {\n    const inferredError =\n      this._errorInferrer.inferBeforeTracingCallMessage(trace);\n\n    if (inferredError !== undefined) {\n      return inferredError;\n    }\n\n    return this._traceEvmExecution(trace);\n  }\n\n  private _getUnrecognizedMessageStackTrace(\n    trace: EvmMessageTrace\n  ): SolidityStackTrace {\n    const subtrace = this._getLastSubtrace(trace);\n\n    if (subtrace !== undefined) {\n      // This is not a very exact heuristic, but most of the time it will be right, as solidity\n      // reverts if a call fails, and most contracts are in solidity\n      if (\n        subtrace.error !== undefined &&\n        trace.returnData.equals(subtrace.returnData)\n      ) {\n        let unrecognizedEntry: SolidityStackTraceEntry;\n\n        if (isCreateTrace(trace)) {\n          unrecognizedEntry = {\n            type: StackTraceEntryType.UNRECOGNIZED_CREATE_CALLSTACK_ENTRY,\n          };\n        } else {\n          unrecognizedEntry = {\n            type: StackTraceEntryType.UNRECOGNIZED_CONTRACT_CALLSTACK_ENTRY,\n            address: trace.address,\n          };\n        }\n\n        return [unrecognizedEntry, ...this.getStackTrace(subtrace)];\n      }\n    }\n\n    if (isCreateTrace(trace)) {\n      return [\n        {\n          type: StackTraceEntryType.UNRECOGNIZED_CREATE_ERROR,\n          message: new ReturnData(trace.returnData),\n        },\n      ];\n    }\n\n    return [\n      {\n        type: StackTraceEntryType.UNRECOGNIZED_CONTRACT_ERROR,\n        address: trace.address,\n        message: new ReturnData(trace.returnData),\n      },\n    ];\n  }\n\n  private _getCreateMessageStackTrace(\n    trace: DecodedCreateMessageTrace\n  ): SolidityStackTrace {\n    const inferredError =\n      this._errorInferrer.inferBeforeTracingCreateMessage(trace);\n\n    if (inferredError !== undefined) {\n      return inferredError;\n    }\n\n    return this._traceEvmExecution(trace);\n  }\n\n  private _getPrecompileMessageStackTrace(\n    trace: PrecompileMessageTrace\n  ): SolidityStackTrace {\n    return [\n      {\n        type: StackTraceEntryType.PRECOMPILE_ERROR,\n        precompile: trace.precompile,\n      },\n    ];\n  }\n\n  private _traceEvmExecution(\n    trace: DecodedEvmMessageTrace\n  ): SolidityStackTrace {\n    const stackTrace = this._rawTraceEvmExecution(trace);\n\n    if (stackTraceMayRequireAdjustments(stackTrace, trace)) {\n      return adjustStackTrace(stackTrace, trace);\n    }\n\n    return stackTrace;\n  }\n\n  private _rawTraceEvmExecution(\n    trace: DecodedEvmMessageTrace\n  ): SolidityStackTrace {\n    const stacktrace: SolidityStackTrace = [];\n\n    let subtracesSeen = 0;\n    let jumpedIntoFunction = false;\n    const functionJumpdests: Instruction[] = [];\n\n    let lastSubmessageData: SubmessageData | undefined;\n\n    for (let stepIndex = 0; stepIndex < trace.steps.length; stepIndex++) {\n      const step = trace.steps[stepIndex];\n      const nextStep = trace.steps[stepIndex + 1];\n\n      if (isEvmStep(step)) {\n        const inst = trace.bytecode.getInstruction(step.pc);\n\n        if (inst.jumpType === JumpType.INTO_FUNCTION) {\n          const nextEvmStep = nextStep as EvmStep; // A jump can't be followed by a subtrace\n          const nextInst = trace.bytecode.getInstruction(nextEvmStep.pc);\n\n          if (nextInst !== undefined && nextInst.opcode === Opcode.JUMPDEST) {\n            stacktrace.push(\n              instructionToCallstackStackTraceEntry(trace.bytecode, inst)\n            );\n            if (nextInst.location !== undefined) {\n              jumpedIntoFunction = true;\n            }\n            functionJumpdests.push(nextInst);\n          }\n        } else if (inst.jumpType === JumpType.OUTOF_FUNCTION) {\n          stacktrace.pop();\n          functionJumpdests.pop();\n        }\n      } else {\n        subtracesSeen += 1;\n\n        // If there are more subtraces, this one didn't terminate the execution\n        if (subtracesSeen < trace.numberOfSubtraces) {\n          continue;\n        }\n\n        const submessageTrace = this.getStackTrace(step);\n\n        lastSubmessageData = {\n          messageTrace: step,\n          stepIndex,\n          stacktrace: submessageTrace,\n        };\n      }\n    }\n\n    const stacktraceWithInferredError = this._errorInferrer.inferAfterTracing(\n      trace,\n      stacktrace,\n      functionJumpdests,\n      jumpedIntoFunction,\n      lastSubmessageData\n    );\n\n    return this._errorInferrer.filterRedundantFrames(\n      stacktraceWithInferredError\n    );\n  }\n\n  private _getLastSubtrace(trace: EvmMessageTrace): MessageTrace | undefined {\n    if (trace.numberOfSubtraces < 1) {\n      return undefined;\n    }\n\n    let i = trace.steps.length - 1;\n\n    while (isEvmStep(trace.steps[i])) {\n      i -= 1;\n    }\n\n    return trace.steps[i] as MessageTrace;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}