{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst chalk_1 = __importDefault(require(\"chalk\"));\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\n\nconst constants_1 = require(\"../internal/constants\");\n\nconst config_env_1 = require(\"../internal/core/config/config-env\");\n\nconst errors_1 = require(\"../internal/core/errors\");\n\nconst errors_list_1 = require(\"../internal/core/errors-list\");\n\nconst construction_1 = require(\"../internal/core/providers/construction\");\n\nconst util_1 = require(\"../internal/core/providers/util\");\n\nconst server_1 = require(\"../internal/hardhat-network/jsonrpc/server\");\n\nconst reporter_1 = require(\"../internal/sentry/reporter\");\n\nconst default_config_1 = require(\"../internal/core/config/default-config\");\n\nconst task_names_1 = require(\"./task-names\");\n\nconst watch_1 = require(\"./utils/watch\");\n\nconst log = (0, debug_1.default)(\"hardhat:core:tasks:node\");\n\nfunction printDefaultConfigWarning() {\n  console.log(chalk_1.default.bold(\"WARNING: These accounts, and their private keys, are publicly known.\"));\n  console.log(chalk_1.default.bold(\"Any funds sent to them on Mainnet or any other live network WILL BE LOST.\"));\n}\n\nfunction logHardhatNetworkAccounts(networkConfig) {\n  const isDefaultConfig = !Array.isArray(networkConfig.accounts) && networkConfig.accounts.mnemonic === default_config_1.HARDHAT_NETWORK_MNEMONIC;\n\n  const {\n    BN,\n    bufferToHex,\n    privateToAddress,\n    toBuffer\n  } = require(\"ethereumjs-util\");\n\n  console.log(\"Accounts\");\n  console.log(\"========\");\n\n  if (isDefaultConfig) {\n    console.log();\n    printDefaultConfigWarning();\n    console.log();\n  }\n\n  const accounts = (0, util_1.normalizeHardhatNetworkAccountsConfig)(networkConfig.accounts);\n\n  for (const [index, account] of accounts.entries()) {\n    const address = bufferToHex(privateToAddress(toBuffer(account.privateKey)));\n    const balance = new BN(account.balance).div(new BN(10).pow(new BN(18))).toString(10);\n    let entry = `Account #${index}: ${address} (${balance} ETH)`;\n\n    if (isDefaultConfig) {\n      const privateKey = bufferToHex(toBuffer(account.privateKey));\n      entry += `\nPrivate Key: ${privateKey}`;\n    }\n\n    console.log(entry);\n    console.log();\n  }\n\n  if (isDefaultConfig) {\n    printDefaultConfigWarning();\n    console.log();\n  }\n}\n\n(0, config_env_1.subtask)(task_names_1.TASK_NODE_GET_PROVIDER).addOptionalParam(\"forkUrl\", undefined, undefined, config_env_1.types.string).addOptionalParam(\"forkBlockNumber\", undefined, undefined, config_env_1.types.int).setAction(async (_ref, _ref2) => {\n  let {\n    forkBlockNumber: forkBlockNumberParam,\n    forkUrl: forkUrlParam\n  } = _ref;\n  let {\n    artifacts,\n    config,\n    network\n  } = _ref2;\n\n  var _a, _b;\n\n  let provider = network.provider;\n\n  if (network.name !== constants_1.HARDHAT_NETWORK_NAME) {\n    const networkConfig = config.networks[constants_1.HARDHAT_NETWORK_NAME];\n    log(`Creating hardhat provider for JSON-RPC server`);\n    provider = (0, construction_1.createProvider)(constants_1.HARDHAT_NETWORK_NAME, networkConfig, config.paths, artifacts);\n  }\n\n  const hardhatNetworkConfig = config.networks[constants_1.HARDHAT_NETWORK_NAME];\n  const forkUrlConfig = (_a = hardhatNetworkConfig.forking) === null || _a === void 0 ? void 0 : _a.url;\n  const forkBlockNumberConfig = (_b = hardhatNetworkConfig.forking) === null || _b === void 0 ? void 0 : _b.blockNumber;\n  const forkUrl = forkUrlParam !== null && forkUrlParam !== void 0 ? forkUrlParam : forkUrlConfig;\n  const forkBlockNumber = forkBlockNumberParam !== null && forkBlockNumberParam !== void 0 ? forkBlockNumberParam : forkBlockNumberConfig; // we throw an error if the user specified a forkBlockNumber but not a\n  // forkUrl\n\n  if (forkBlockNumber !== undefined && forkUrl === undefined) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.NODE_FORK_BLOCK_NUMBER_WITHOUT_URL);\n  } // if the url or the block is different to the one in the configuration,\n  // we use hardhat_reset to set the fork\n\n\n  if (forkUrl !== forkUrlConfig || forkBlockNumber !== forkBlockNumberConfig) {\n    await provider.request({\n      method: \"hardhat_reset\",\n      params: [{\n        forking: {\n          jsonRpcUrl: forkUrl,\n          blockNumber: forkBlockNumber\n        }\n      }]\n    });\n  } // enable logging\n\n\n  await provider.request({\n    method: \"hardhat_setLoggingEnabled\",\n    params: [true]\n  });\n  return provider;\n});\n(0, config_env_1.subtask)(task_names_1.TASK_NODE_CREATE_SERVER).addParam(\"hostname\", undefined, undefined, config_env_1.types.string).addParam(\"port\", undefined, undefined, config_env_1.types.int).addParam(\"provider\", undefined, undefined, config_env_1.types.any).setAction(async _ref3 => {\n  let {\n    hostname,\n    port,\n    provider\n  } = _ref3;\n  const serverConfig = {\n    hostname,\n    port,\n    provider\n  };\n  const server = new server_1.JsonRpcServer(serverConfig);\n  return server;\n});\n/**\n * This task will be called when the server was successfully created, but it's\n * not ready for receiving requests yet.\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_NODE_SERVER_CREATED).addParam(\"hostname\", undefined, undefined, config_env_1.types.string).addParam(\"port\", undefined, undefined, config_env_1.types.int).addParam(\"provider\", undefined, undefined, config_env_1.types.any).addParam(\"server\", undefined, undefined, config_env_1.types.any).setAction(async _ref4 => {// this task is meant to be overriden by plugin writers\n\n  let {} = _ref4;\n});\n/**\n * This subtask will be run when the server is ready to accept requests\n */\n\n(0, config_env_1.subtask)(task_names_1.TASK_NODE_SERVER_READY).addParam(\"address\", undefined, undefined, config_env_1.types.string).addParam(\"port\", undefined, undefined, config_env_1.types.int).addParam(\"provider\", undefined, undefined, config_env_1.types.any).addParam(\"server\", undefined, undefined, config_env_1.types.any).setAction(async (_ref5, _ref6) => {\n  let {\n    address,\n    port\n  } = _ref5;\n  let {\n    config\n  } = _ref6;\n  console.log(chalk_1.default.green(`Started HTTP and WebSocket JSON-RPC server at http://${address}:${port}/`));\n  console.log();\n  const networkConfig = config.networks[constants_1.HARDHAT_NETWORK_NAME];\n  logHardhatNetworkAccounts(networkConfig);\n});\n(0, config_env_1.task)(task_names_1.TASK_NODE, \"Starts a JSON-RPC server on top of Hardhat Network\").addOptionalParam(\"hostname\", \"The host to which to bind to for new connections (Defaults to 127.0.0.1 running locally, and 0.0.0.0 in Docker)\", undefined, config_env_1.types.string).addOptionalParam(\"port\", \"The port on which to listen for new connections\", 8545, config_env_1.types.int).addOptionalParam(\"fork\", \"The URL of the JSON-RPC server to fork from\", undefined, config_env_1.types.string).addOptionalParam(\"forkBlockNumber\", \"The block number to fork from\", undefined, config_env_1.types.int).setAction(async (_ref7, _ref8) => {\n  let {\n    forkBlockNumber,\n    fork: forkUrl,\n    hostname: hostnameParam,\n    port\n  } = _ref7;\n  let {\n    config,\n    hardhatArguments,\n    network,\n    run\n  } = _ref8;\n\n  // we throw if the user specified a network argument and it's not hardhat\n  if (network.name !== constants_1.HARDHAT_NETWORK_NAME && hardhatArguments.network !== undefined) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.JSONRPC_UNSUPPORTED_NETWORK);\n  }\n\n  try {\n    const provider = await run(task_names_1.TASK_NODE_GET_PROVIDER, {\n      forkBlockNumber,\n      forkUrl\n    }); // the default hostname is \"127.0.0.1\" unless we are inside a docker\n    // container, in that case we use \"0.0.0.0\"\n\n    let hostname;\n\n    if (hostnameParam !== undefined) {\n      hostname = hostnameParam;\n    } else {\n      const insideDocker = fs_extra_1.default.existsSync(\"/.dockerenv\");\n\n      if (insideDocker) {\n        hostname = \"0.0.0.0\";\n      } else {\n        hostname = \"127.0.0.1\";\n      }\n    }\n\n    const server = await run(task_names_1.TASK_NODE_CREATE_SERVER, {\n      hostname,\n      port,\n      provider\n    });\n    await run(task_names_1.TASK_NODE_SERVER_CREATED, {\n      hostname,\n      port,\n      provider,\n      server\n    });\n    const {\n      port: actualPort,\n      address\n    } = await server.listen();\n\n    try {\n      await (0, watch_1.watchCompilerOutput)(provider, config.paths);\n    } catch (error) {\n      console.warn(chalk_1.default.yellow(\"There was a problem watching the compiler output, changes in the contracts won't be reflected in the Hardhat Network. Run Hardhat with --verbose to learn more.\"));\n      log(\"Compilation output can't be watched. Please report this to help us improve Hardhat.\\n\", error);\n\n      if (error instanceof Error) {\n        reporter_1.Reporter.reportError(error);\n      }\n    }\n\n    await run(task_names_1.TASK_NODE_SERVER_READY, {\n      address,\n      port: actualPort,\n      provider,\n      server\n    });\n    await server.waitUntilClosed();\n  } catch (error) {\n    if (errors_1.HardhatError.isHardhatError(error)) {\n      throw error;\n    }\n\n    if (error instanceof Error) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.JSONRPC_SERVER_ERROR, {\n        error: error.message\n      }, error);\n    } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n    throw error;\n  }\n});","map":{"version":3,"mappings":"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","names":["log","printDefaultConfigWarning","console","chalk_1","bold","logHardhatNetworkAccounts","networkConfig","isDefaultConfig","Array","isArray","accounts","mnemonic","default_config_1","BN","bufferToHex","privateToAddress","toBuffer","require","index","account","entries","address","privateKey","balance","div","pow","toString","entry","task_names_1","addOptionalParam","undefined","config_env_1","string","int","setAction","forkBlockNumber","forkBlockNumberParam","forkUrl","forkUrlParam","artifacts","config","network","provider","name","constants_1","networks","paths","hardhatNetworkConfig","forkUrlConfig","forking","_a","url","forkBlockNumberConfig","_b","blockNumber","errors_1","errors_list_1","BUILTIN_TASKS","NODE_FORK_BLOCK_NUMBER_WITHOUT_URL","request","method","params","jsonRpcUrl","addParam","any","hostname","port","serverConfig","server","server_1","green","fork","hostnameParam","hardhatArguments","run","JSONRPC_UNSUPPORTED_NETWORK","insideDocker","fs_extra_1","existsSync","actualPort","listen","error","warn","yellow","Error","reporter_1","reportError","waitUntilClosed","isHardhatError","JSONRPC_SERVER_ERROR","message"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/builtin-tasks/node.ts"],"sourcesContent":["import chalk from \"chalk\";\nimport debug from \"debug\";\nimport type EthereumjsUtilT from \"ethereumjs-util\";\nimport fsExtra from \"fs-extra\";\n\nimport { HARDHAT_NETWORK_NAME } from \"../internal/constants\";\nimport { subtask, task, types } from \"../internal/core/config/config-env\";\nimport { HardhatError } from \"../internal/core/errors\";\nimport { ERRORS } from \"../internal/core/errors-list\";\nimport { createProvider } from \"../internal/core/providers/construction\";\nimport { normalizeHardhatNetworkAccountsConfig } from \"../internal/core/providers/util\";\nimport {\n  JsonRpcServer as JsonRpcServerImpl,\n  JsonRpcServerConfig,\n} from \"../internal/hardhat-network/jsonrpc/server\";\nimport { Reporter } from \"../internal/sentry/reporter\";\nimport {\n  EthereumProvider,\n  HardhatNetworkConfig,\n  JsonRpcServer,\n} from \"../types\";\n\nimport { HARDHAT_NETWORK_MNEMONIC } from \"../internal/core/config/default-config\";\nimport {\n  TASK_NODE,\n  TASK_NODE_CREATE_SERVER,\n  TASK_NODE_GET_PROVIDER,\n  TASK_NODE_SERVER_CREATED,\n  TASK_NODE_SERVER_READY,\n} from \"./task-names\";\nimport { watchCompilerOutput } from \"./utils/watch\";\n\nconst log = debug(\"hardhat:core:tasks:node\");\n\nfunction printDefaultConfigWarning() {\n  console.log(\n    chalk.bold(\n      \"WARNING: These accounts, and their private keys, are publicly known.\"\n    )\n  );\n  console.log(\n    chalk.bold(\n      \"Any funds sent to them on Mainnet or any other live network WILL BE LOST.\"\n    )\n  );\n}\n\nfunction logHardhatNetworkAccounts(networkConfig: HardhatNetworkConfig) {\n  const isDefaultConfig =\n    !Array.isArray(networkConfig.accounts) &&\n    networkConfig.accounts.mnemonic === HARDHAT_NETWORK_MNEMONIC;\n\n  const { BN, bufferToHex, privateToAddress, toBuffer } =\n    require(\"ethereumjs-util\") as typeof EthereumjsUtilT;\n\n  console.log(\"Accounts\");\n  console.log(\"========\");\n\n  if (isDefaultConfig) {\n    console.log();\n    printDefaultConfigWarning();\n    console.log();\n  }\n\n  const accounts = normalizeHardhatNetworkAccountsConfig(\n    networkConfig.accounts\n  );\n\n  for (const [index, account] of accounts.entries()) {\n    const address = bufferToHex(privateToAddress(toBuffer(account.privateKey)));\n\n    const balance = new BN(account.balance)\n      .div(new BN(10).pow(new BN(18)))\n      .toString(10);\n\n    let entry = `Account #${index}: ${address} (${balance} ETH)`;\n\n    if (isDefaultConfig) {\n      const privateKey = bufferToHex(toBuffer(account.privateKey));\n      entry += `\nPrivate Key: ${privateKey}`;\n    }\n\n    console.log(entry);\n    console.log();\n  }\n\n  if (isDefaultConfig) {\n    printDefaultConfigWarning();\n    console.log();\n  }\n}\n\nsubtask(TASK_NODE_GET_PROVIDER)\n  .addOptionalParam(\"forkUrl\", undefined, undefined, types.string)\n  .addOptionalParam(\"forkBlockNumber\", undefined, undefined, types.int)\n  .setAction(\n    async (\n      {\n        forkBlockNumber: forkBlockNumberParam,\n        forkUrl: forkUrlParam,\n      }: {\n        forkBlockNumber?: number;\n        forkUrl?: string;\n      },\n      { artifacts, config, network }\n    ): Promise<EthereumProvider> => {\n      let provider = network.provider;\n\n      if (network.name !== HARDHAT_NETWORK_NAME) {\n        const networkConfig = config.networks[HARDHAT_NETWORK_NAME];\n\n        log(`Creating hardhat provider for JSON-RPC server`);\n        provider = createProvider(\n          HARDHAT_NETWORK_NAME,\n          networkConfig,\n          config.paths,\n          artifacts\n        );\n      }\n\n      const hardhatNetworkConfig = config.networks[HARDHAT_NETWORK_NAME];\n\n      const forkUrlConfig = hardhatNetworkConfig.forking?.url;\n      const forkBlockNumberConfig = hardhatNetworkConfig.forking?.blockNumber;\n\n      const forkUrl = forkUrlParam ?? forkUrlConfig;\n      const forkBlockNumber = forkBlockNumberParam ?? forkBlockNumberConfig;\n\n      // we throw an error if the user specified a forkBlockNumber but not a\n      // forkUrl\n      if (forkBlockNumber !== undefined && forkUrl === undefined) {\n        throw new HardhatError(\n          ERRORS.BUILTIN_TASKS.NODE_FORK_BLOCK_NUMBER_WITHOUT_URL\n        );\n      }\n\n      // if the url or the block is different to the one in the configuration,\n      // we use hardhat_reset to set the fork\n      if (\n        forkUrl !== forkUrlConfig ||\n        forkBlockNumber !== forkBlockNumberConfig\n      ) {\n        await provider.request({\n          method: \"hardhat_reset\",\n          params: [\n            {\n              forking: {\n                jsonRpcUrl: forkUrl,\n                blockNumber: forkBlockNumber,\n              },\n            },\n          ],\n        });\n      }\n\n      // enable logging\n      await provider.request({\n        method: \"hardhat_setLoggingEnabled\",\n        params: [true],\n      });\n\n      return provider;\n    }\n  );\n\nsubtask(TASK_NODE_CREATE_SERVER)\n  .addParam(\"hostname\", undefined, undefined, types.string)\n  .addParam(\"port\", undefined, undefined, types.int)\n  .addParam(\"provider\", undefined, undefined, types.any)\n  .setAction(\n    async ({\n      hostname,\n      port,\n      provider,\n    }: {\n      hostname: string;\n      port: number;\n      provider: EthereumProvider;\n    }): Promise<JsonRpcServer> => {\n      const serverConfig: JsonRpcServerConfig = {\n        hostname,\n        port,\n        provider,\n      };\n\n      const server = new JsonRpcServerImpl(serverConfig);\n\n      return server;\n    }\n  );\n\n/**\n * This task will be called when the server was successfully created, but it's\n * not ready for receiving requests yet.\n */\nsubtask(TASK_NODE_SERVER_CREATED)\n  .addParam(\"hostname\", undefined, undefined, types.string)\n  .addParam(\"port\", undefined, undefined, types.int)\n  .addParam(\"provider\", undefined, undefined, types.any)\n  .addParam(\"server\", undefined, undefined, types.any)\n  .setAction(\n    async ({}: {\n      hostname: string;\n      port: number;\n      provider: EthereumProvider;\n      server: JsonRpcServer;\n    }) => {\n      // this task is meant to be overriden by plugin writers\n    }\n  );\n\n/**\n * This subtask will be run when the server is ready to accept requests\n */\nsubtask(TASK_NODE_SERVER_READY)\n  .addParam(\"address\", undefined, undefined, types.string)\n  .addParam(\"port\", undefined, undefined, types.int)\n  .addParam(\"provider\", undefined, undefined, types.any)\n  .addParam(\"server\", undefined, undefined, types.any)\n  .setAction(\n    async (\n      {\n        address,\n        port,\n      }: {\n        address: string;\n        port: number;\n        provider: EthereumProvider;\n        server: JsonRpcServer;\n      },\n      { config }\n    ) => {\n      console.log(\n        chalk.green(\n          `Started HTTP and WebSocket JSON-RPC server at http://${address}:${port}/`\n        )\n      );\n\n      console.log();\n\n      const networkConfig = config.networks[HARDHAT_NETWORK_NAME];\n      logHardhatNetworkAccounts(networkConfig);\n    }\n  );\n\ntask(TASK_NODE, \"Starts a JSON-RPC server on top of Hardhat Network\")\n  .addOptionalParam(\n    \"hostname\",\n    \"The host to which to bind to for new connections (Defaults to 127.0.0.1 running locally, and 0.0.0.0 in Docker)\",\n    undefined,\n    types.string\n  )\n  .addOptionalParam(\n    \"port\",\n    \"The port on which to listen for new connections\",\n    8545,\n    types.int\n  )\n  .addOptionalParam(\n    \"fork\",\n    \"The URL of the JSON-RPC server to fork from\",\n    undefined,\n    types.string\n  )\n  .addOptionalParam(\n    \"forkBlockNumber\",\n    \"The block number to fork from\",\n    undefined,\n    types.int\n  )\n  .setAction(\n    async (\n      {\n        forkBlockNumber,\n        fork: forkUrl,\n        hostname: hostnameParam,\n        port,\n      }: {\n        forkBlockNumber?: number;\n        fork?: string;\n        hostname?: string;\n        port: number;\n      },\n      { config, hardhatArguments, network, run }\n    ) => {\n      // we throw if the user specified a network argument and it's not hardhat\n      if (\n        network.name !== HARDHAT_NETWORK_NAME &&\n        hardhatArguments.network !== undefined\n      ) {\n        throw new HardhatError(\n          ERRORS.BUILTIN_TASKS.JSONRPC_UNSUPPORTED_NETWORK\n        );\n      }\n\n      try {\n        const provider: EthereumProvider = await run(TASK_NODE_GET_PROVIDER, {\n          forkBlockNumber,\n          forkUrl,\n        });\n\n        // the default hostname is \"127.0.0.1\" unless we are inside a docker\n        // container, in that case we use \"0.0.0.0\"\n        let hostname: string;\n        if (hostnameParam !== undefined) {\n          hostname = hostnameParam;\n        } else {\n          const insideDocker = fsExtra.existsSync(\"/.dockerenv\");\n          if (insideDocker) {\n            hostname = \"0.0.0.0\";\n          } else {\n            hostname = \"127.0.0.1\";\n          }\n        }\n\n        const server: JsonRpcServer = await run(TASK_NODE_CREATE_SERVER, {\n          hostname,\n          port,\n          provider,\n        });\n\n        await run(TASK_NODE_SERVER_CREATED, {\n          hostname,\n          port,\n          provider,\n          server,\n        });\n\n        const { port: actualPort, address } = await server.listen();\n\n        try {\n          await watchCompilerOutput(provider, config.paths);\n        } catch (error) {\n          console.warn(\n            chalk.yellow(\n              \"There was a problem watching the compiler output, changes in the contracts won't be reflected in the Hardhat Network. Run Hardhat with --verbose to learn more.\"\n            )\n          );\n\n          log(\n            \"Compilation output can't be watched. Please report this to help us improve Hardhat.\\n\",\n            error\n          );\n\n          if (error instanceof Error) {\n            Reporter.reportError(error);\n          }\n        }\n\n        await run(TASK_NODE_SERVER_READY, {\n          address,\n          port: actualPort,\n          provider,\n          server,\n        });\n\n        await server.waitUntilClosed();\n      } catch (error) {\n        if (HardhatError.isHardhatError(error)) {\n          throw error;\n        }\n\n        if (error instanceof Error) {\n          throw new HardhatError(\n            ERRORS.BUILTIN_TASKS.JSONRPC_SERVER_ERROR,\n            {\n              error: error.message,\n            },\n            error\n          );\n        }\n\n        // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n        throw error;\n      }\n    }\n  );\n"]},"metadata":{},"sourceType":"script"}