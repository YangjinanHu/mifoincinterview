{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyProviderWrappers = exports.createProvider = exports.isHDAccountsConfig = void 0;\n\nconst constants_1 = require(\"../../constants\");\n\nconst logger_1 = require(\"../../hardhat-network/provider/modules/logger\");\n\nconst disk_cache_1 = require(\"../../hardhat-network/provider/utils/disk-cache\");\n\nconst date_1 = require(\"../../util/date\");\n\nconst util_1 = require(\"./util\");\n\nfunction isHDAccountsConfig(accounts) {\n  return accounts !== undefined && Object.keys(accounts).includes(\"mnemonic\");\n}\n\nexports.isHDAccountsConfig = isHDAccountsConfig;\n\nfunction isResolvedHttpNetworkConfig(netConfig) {\n  return \"url\" in netConfig;\n} // This function is let's you import a provider dynamically in a pretty\n// type-safe way.\n// `ProviderNameT` and `name` must be the same literal string. TS enforces it.\n// `ModuleT` and `filePath` must also be the same, but this is not enforced.\n\n\nfunction importProvider(filePath, name) {\n  const mod = require(filePath);\n\n  return mod[name];\n}\n\nfunction createProvider(networkName, networkConfig, paths, artifacts) {\n  let experimentalHardhatNetworkMessageTraceHooks = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n\n  var _a, _b, _c, _d;\n\n  let eip1193Provider;\n\n  if (networkName === constants_1.HARDHAT_NETWORK_NAME) {\n    const hardhatNetConfig = networkConfig;\n    const HardhatNetworkProvider = importProvider(\"../../hardhat-network/provider/provider\", \"HardhatNetworkProvider\");\n    let forkConfig;\n\n    if (((_a = hardhatNetConfig.forking) === null || _a === void 0 ? void 0 : _a.enabled) === true && ((_b = hardhatNetConfig.forking) === null || _b === void 0 ? void 0 : _b.url) !== undefined) {\n      forkConfig = {\n        jsonRpcUrl: (_c = hardhatNetConfig.forking) === null || _c === void 0 ? void 0 : _c.url,\n        blockNumber: (_d = hardhatNetConfig.forking) === null || _d === void 0 ? void 0 : _d.blockNumber\n      };\n    }\n\n    const accounts = (0, util_1.normalizeHardhatNetworkAccountsConfig)(hardhatNetConfig.accounts);\n    eip1193Provider = new HardhatNetworkProvider(hardhatNetConfig.hardfork, constants_1.HARDHAT_NETWORK_NAME, hardhatNetConfig.chainId, hardhatNetConfig.chainId, hardhatNetConfig.blockGasLimit, hardhatNetConfig.initialBaseFeePerGas, hardhatNetConfig.minGasPrice, hardhatNetConfig.throwOnTransactionFailures, hardhatNetConfig.throwOnCallFailures, hardhatNetConfig.mining.auto, hardhatNetConfig.mining.interval, // This cast is valid because of the config validation and resolution\n    hardhatNetConfig.mining.mempool.order, hardhatNetConfig.chains, new logger_1.ModulesLogger(hardhatNetConfig.loggingEnabled), accounts, artifacts, hardhatNetConfig.allowUnlimitedContractSize, hardhatNetConfig.initialDate !== undefined ? (0, date_1.parseDateString)(hardhatNetConfig.initialDate) : undefined, experimentalHardhatNetworkMessageTraceHooks, forkConfig, paths !== undefined ? (0, disk_cache_1.getForkCacheDirPath)(paths) : undefined, hardhatNetConfig.coinbase);\n  } else {\n    const HttpProvider = importProvider(\"./http\", \"HttpProvider\");\n    const httpNetConfig = networkConfig;\n    eip1193Provider = new HttpProvider(httpNetConfig.url, networkName, httpNetConfig.httpHeaders, httpNetConfig.timeout);\n  }\n\n  const wrappedProvider = applyProviderWrappers(eip1193Provider, networkConfig);\n  const BackwardsCompatibilityProviderAdapter = importProvider(\"./backwards-compatibility\", \"BackwardsCompatibilityProviderAdapter\");\n  return new BackwardsCompatibilityProviderAdapter(wrappedProvider);\n}\n\nexports.createProvider = createProvider;\n\nfunction applyProviderWrappers(provider, netConfig) {\n  // These dependencies are lazy-loaded because they are really big.\n  const LocalAccountsProvider = importProvider(\"./accounts\", \"LocalAccountsProvider\");\n  const HDWalletProvider = importProvider(\"./accounts\", \"HDWalletProvider\");\n  const FixedSenderProvider = importProvider(\"./accounts\", \"FixedSenderProvider\");\n  const AutomaticSenderProvider = importProvider(\"./accounts\", \"AutomaticSenderProvider\");\n  const AutomaticGasProvider = importProvider(\"./gas-providers\", \"AutomaticGasProvider\");\n  const FixedGasProvider = importProvider(\"./gas-providers\", \"FixedGasProvider\");\n  const AutomaticGasPriceProvider = importProvider(\"./gas-providers\", \"AutomaticGasPriceProvider\");\n  const FixedGasPriceProvider = importProvider(\"./gas-providers\", \"FixedGasPriceProvider\");\n  const GanacheGasMultiplierProvider = importProvider(\"./gas-providers\", \"GanacheGasMultiplierProvider\");\n  const ChainIdValidatorProvider = importProvider(\"./chainId\", \"ChainIdValidatorProvider\");\n\n  if (isResolvedHttpNetworkConfig(netConfig)) {\n    const accounts = netConfig.accounts;\n\n    if (Array.isArray(accounts)) {\n      provider = new LocalAccountsProvider(provider, accounts);\n    } else if (isHDAccountsConfig(accounts)) {\n      provider = new HDWalletProvider(provider, accounts.mnemonic, accounts.path, accounts.initialIndex, accounts.count);\n    } // TODO: Add some extension mechanism for account plugins here\n\n\n    if (typeof netConfig.gas !== \"number\") {\n      provider = new GanacheGasMultiplierProvider(provider);\n    }\n  }\n\n  if (netConfig.from !== undefined) {\n    provider = new FixedSenderProvider(provider, netConfig.from);\n  } else {\n    provider = new AutomaticSenderProvider(provider);\n  }\n\n  if (netConfig.gas === undefined || netConfig.gas === \"auto\") {\n    provider = new AutomaticGasProvider(provider, netConfig.gasMultiplier);\n  } else {\n    provider = new FixedGasProvider(provider, netConfig.gas);\n  }\n\n  if (netConfig.gasPrice === undefined || netConfig.gasPrice === \"auto\") {\n    // If you use a LocalAccountsProvider or HDWalletProvider, your transactions\n    // are signed locally. This requires having all of their fields available,\n    // including the gasPrice / maxFeePerGas & maxPriorityFeePerGas.\n    //\n    // We never use those providers when using Hardhat Network, but sign within\n    // Hardhat Network itself. This means that we don't need to provide all the\n    // fields, as the missing ones will be resolved there.\n    //\n    // Hardhat Network handles this in a more performant way, so we don't use\n    // the AutomaticGasPriceProvider for it.\n    if (isResolvedHttpNetworkConfig(netConfig)) {\n      provider = new AutomaticGasPriceProvider(provider);\n    }\n  } else {\n    provider = new FixedGasPriceProvider(provider, netConfig.gasPrice);\n  }\n\n  if (isResolvedHttpNetworkConfig(netConfig) && netConfig.chainId !== undefined) {\n    provider = new ChainIdValidatorProvider(provider, netConfig.chainId);\n  }\n\n  return provider;\n}\n\nexports.applyProviderWrappers = applyProviderWrappers;","map":{"version":3,"mappings":"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","names":["isHDAccountsConfig","accounts","undefined","Object","keys","includes","exports","isResolvedHttpNetworkConfig","netConfig","importProvider","filePath","name","mod","require","createProvider","networkName","networkConfig","paths","artifacts","experimentalHardhatNetworkMessageTraceHooks","eip1193Provider","constants_1","hardhatNetConfig","HardhatNetworkProvider","forkConfig","forking","_a","enabled","_b","url","jsonRpcUrl","_c","blockNumber","_d","hardfork","chainId","blockGasLimit","initialBaseFeePerGas","minGasPrice","throwOnTransactionFailures","throwOnCallFailures","mining","auto","interval","mempool","order","chains","logger_1","loggingEnabled","allowUnlimitedContractSize","initialDate","coinbase","HttpProvider","httpNetConfig","httpHeaders","timeout","wrappedProvider","applyProviderWrappers","BackwardsCompatibilityProviderAdapter","provider","LocalAccountsProvider","HDWalletProvider","FixedSenderProvider","AutomaticSenderProvider","AutomaticGasProvider","FixedGasProvider","AutomaticGasPriceProvider","FixedGasPriceProvider","GanacheGasMultiplierProvider","ChainIdValidatorProvider","Array","isArray","mnemonic","path","initialIndex","count","gas","from","gasMultiplier","gasPrice"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/internal/core/providers/construction.ts"],"sourcesContent":["import type {\n  Artifacts,\n  BoundExperimentalHardhatNetworkMessageTraceHook,\n  EIP1193Provider,\n  EthereumProvider,\n  HardhatNetworkConfig,\n  HDAccountsUserConfig,\n  HttpNetworkAccountsUserConfig,\n  HttpNetworkConfig,\n  HttpNetworkUserConfig,\n  NetworkConfig,\n  ProjectPathsConfig,\n} from \"../../../types\";\nimport { HARDHAT_NETWORK_NAME } from \"../../constants\";\nimport { ModulesLogger } from \"../../hardhat-network/provider/modules/logger\";\nimport {\n  ForkConfig,\n  MempoolOrder,\n} from \"../../hardhat-network/provider/node-types\";\nimport { getForkCacheDirPath } from \"../../hardhat-network/provider/utils/disk-cache\";\nimport { parseDateString } from \"../../util/date\";\n\nimport { normalizeHardhatNetworkAccountsConfig } from \"./util\";\n\nexport function isHDAccountsConfig(\n  accounts?: HttpNetworkAccountsUserConfig\n): accounts is HDAccountsUserConfig {\n  return accounts !== undefined && Object.keys(accounts).includes(\"mnemonic\");\n}\n\nfunction isResolvedHttpNetworkConfig(\n  netConfig: Partial<NetworkConfig>\n): netConfig is HttpNetworkConfig {\n  return \"url\" in netConfig;\n}\n\n// This function is let's you import a provider dynamically in a pretty\n// type-safe way.\n// `ProviderNameT` and `name` must be the same literal string. TS enforces it.\n// `ModuleT` and `filePath` must also be the same, but this is not enforced.\nfunction importProvider<ModuleT, ProviderNameT extends keyof ModuleT>(\n  filePath: string,\n  name: ProviderNameT\n): ModuleT[ProviderNameT] {\n  const mod = require(filePath);\n  return mod[name];\n}\n\nexport function createProvider(\n  networkName: string,\n  networkConfig: NetworkConfig,\n  paths?: ProjectPathsConfig,\n  artifacts?: Artifacts,\n  experimentalHardhatNetworkMessageTraceHooks: BoundExperimentalHardhatNetworkMessageTraceHook[] = []\n): EthereumProvider {\n  let eip1193Provider: EIP1193Provider;\n\n  if (networkName === HARDHAT_NETWORK_NAME) {\n    const hardhatNetConfig = networkConfig as HardhatNetworkConfig;\n\n    const HardhatNetworkProvider = importProvider<\n      typeof import(\"../../hardhat-network/provider/provider\"),\n      \"HardhatNetworkProvider\"\n    >(\"../../hardhat-network/provider/provider\", \"HardhatNetworkProvider\");\n\n    let forkConfig: ForkConfig | undefined;\n\n    if (\n      hardhatNetConfig.forking?.enabled === true &&\n      hardhatNetConfig.forking?.url !== undefined\n    ) {\n      forkConfig = {\n        jsonRpcUrl: hardhatNetConfig.forking?.url,\n        blockNumber: hardhatNetConfig.forking?.blockNumber,\n      };\n    }\n\n    const accounts = normalizeHardhatNetworkAccountsConfig(\n      hardhatNetConfig.accounts\n    );\n\n    eip1193Provider = new HardhatNetworkProvider(\n      hardhatNetConfig.hardfork,\n      HARDHAT_NETWORK_NAME,\n      hardhatNetConfig.chainId,\n      hardhatNetConfig.chainId,\n      hardhatNetConfig.blockGasLimit,\n      hardhatNetConfig.initialBaseFeePerGas,\n      hardhatNetConfig.minGasPrice,\n      hardhatNetConfig.throwOnTransactionFailures,\n      hardhatNetConfig.throwOnCallFailures,\n      hardhatNetConfig.mining.auto,\n      hardhatNetConfig.mining.interval,\n      // This cast is valid because of the config validation and resolution\n      hardhatNetConfig.mining.mempool.order as MempoolOrder,\n      hardhatNetConfig.chains,\n      new ModulesLogger(hardhatNetConfig.loggingEnabled),\n      accounts,\n      artifacts,\n      hardhatNetConfig.allowUnlimitedContractSize,\n      hardhatNetConfig.initialDate !== undefined\n        ? parseDateString(hardhatNetConfig.initialDate)\n        : undefined,\n      experimentalHardhatNetworkMessageTraceHooks,\n      forkConfig,\n      paths !== undefined ? getForkCacheDirPath(paths) : undefined,\n      hardhatNetConfig.coinbase\n    );\n  } else {\n    const HttpProvider = importProvider<\n      typeof import(\"./http\"),\n      \"HttpProvider\"\n    >(\"./http\", \"HttpProvider\");\n    const httpNetConfig = networkConfig as HttpNetworkUserConfig;\n\n    eip1193Provider = new HttpProvider(\n      httpNetConfig.url!,\n      networkName,\n      httpNetConfig.httpHeaders,\n      httpNetConfig.timeout\n    );\n  }\n\n  const wrappedProvider = applyProviderWrappers(eip1193Provider, networkConfig);\n\n  const BackwardsCompatibilityProviderAdapter = importProvider<\n    typeof import(\"./backwards-compatibility\"),\n    \"BackwardsCompatibilityProviderAdapter\"\n  >(\"./backwards-compatibility\", \"BackwardsCompatibilityProviderAdapter\");\n\n  return new BackwardsCompatibilityProviderAdapter(wrappedProvider);\n}\n\nexport function applyProviderWrappers(\n  provider: EIP1193Provider,\n  netConfig: Partial<NetworkConfig>\n): EIP1193Provider {\n  // These dependencies are lazy-loaded because they are really big.\n  const LocalAccountsProvider = importProvider<\n    typeof import(\"./accounts\"),\n    \"LocalAccountsProvider\"\n  >(\"./accounts\", \"LocalAccountsProvider\");\n  const HDWalletProvider = importProvider<\n    typeof import(\"./accounts\"),\n    \"HDWalletProvider\"\n  >(\"./accounts\", \"HDWalletProvider\");\n  const FixedSenderProvider = importProvider<\n    typeof import(\"./accounts\"),\n    \"FixedSenderProvider\"\n  >(\"./accounts\", \"FixedSenderProvider\");\n  const AutomaticSenderProvider = importProvider<\n    typeof import(\"./accounts\"),\n    \"AutomaticSenderProvider\"\n  >(\"./accounts\", \"AutomaticSenderProvider\");\n\n  const AutomaticGasProvider = importProvider<\n    typeof import(\"./gas-providers\"),\n    \"AutomaticGasProvider\"\n  >(\"./gas-providers\", \"AutomaticGasProvider\");\n  const FixedGasProvider = importProvider<\n    typeof import(\"./gas-providers\"),\n    \"FixedGasProvider\"\n  >(\"./gas-providers\", \"FixedGasProvider\");\n  const AutomaticGasPriceProvider = importProvider<\n    typeof import(\"./gas-providers\"),\n    \"AutomaticGasPriceProvider\"\n  >(\"./gas-providers\", \"AutomaticGasPriceProvider\");\n  const FixedGasPriceProvider = importProvider<\n    typeof import(\"./gas-providers\"),\n    \"FixedGasPriceProvider\"\n  >(\"./gas-providers\", \"FixedGasPriceProvider\");\n  const GanacheGasMultiplierProvider = importProvider<\n    typeof import(\"./gas-providers\"),\n    \"GanacheGasMultiplierProvider\"\n  >(\"./gas-providers\", \"GanacheGasMultiplierProvider\");\n\n  const ChainIdValidatorProvider = importProvider<\n    typeof import(\"./chainId\"),\n    \"ChainIdValidatorProvider\"\n  >(\"./chainId\", \"ChainIdValidatorProvider\");\n\n  if (isResolvedHttpNetworkConfig(netConfig)) {\n    const accounts = netConfig.accounts;\n\n    if (Array.isArray(accounts)) {\n      provider = new LocalAccountsProvider(provider, accounts);\n    } else if (isHDAccountsConfig(accounts)) {\n      provider = new HDWalletProvider(\n        provider,\n        accounts.mnemonic,\n        accounts.path,\n        accounts.initialIndex,\n        accounts.count\n      );\n    }\n\n    // TODO: Add some extension mechanism for account plugins here\n\n    if (typeof netConfig.gas !== \"number\") {\n      provider = new GanacheGasMultiplierProvider(provider);\n    }\n  }\n\n  if (netConfig.from !== undefined) {\n    provider = new FixedSenderProvider(provider, netConfig.from);\n  } else {\n    provider = new AutomaticSenderProvider(provider);\n  }\n\n  if (netConfig.gas === undefined || netConfig.gas === \"auto\") {\n    provider = new AutomaticGasProvider(provider, netConfig.gasMultiplier);\n  } else {\n    provider = new FixedGasProvider(provider, netConfig.gas);\n  }\n\n  if (netConfig.gasPrice === undefined || netConfig.gasPrice === \"auto\") {\n    // If you use a LocalAccountsProvider or HDWalletProvider, your transactions\n    // are signed locally. This requires having all of their fields available,\n    // including the gasPrice / maxFeePerGas & maxPriorityFeePerGas.\n    //\n    // We never use those providers when using Hardhat Network, but sign within\n    // Hardhat Network itself. This means that we don't need to provide all the\n    // fields, as the missing ones will be resolved there.\n    //\n    // Hardhat Network handles this in a more performant way, so we don't use\n    // the AutomaticGasPriceProvider for it.\n    if (isResolvedHttpNetworkConfig(netConfig)) {\n      provider = new AutomaticGasPriceProvider(provider);\n    }\n  } else {\n    provider = new FixedGasPriceProvider(provider, netConfig.gasPrice);\n  }\n\n  if (\n    isResolvedHttpNetworkConfig(netConfig) &&\n    netConfig.chainId !== undefined\n  ) {\n    provider = new ChainIdValidatorProvider(provider, netConfig.chainId);\n  }\n\n  return provider;\n}\n"]},"metadata":{},"sourceType":"script"}