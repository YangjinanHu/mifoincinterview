{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArgumentsParser = void 0;\n\nconst errors_1 = require(\"../core/errors\");\n\nconst errors_list_1 = require(\"../core/errors-list\");\n\nclass ArgumentsParser {\n  static paramNameToCLA(paramName) {\n    return ArgumentsParser.PARAM_PREFIX + paramName.split(/(?=[A-Z])/g).map(s => s.toLowerCase()).join(\"-\");\n  }\n\n  static cLAToParamName(cLA) {\n    if (cLA.toLowerCase() !== cLA) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.PARAM_NAME_INVALID_CASING, {\n        param: cLA\n      });\n    }\n\n    const parts = cLA.slice(ArgumentsParser.PARAM_PREFIX.length).split(\"-\").filter(x => x.length > 0);\n    return parts[0] + parts.slice(1).map(s => s[0].toUpperCase() + s.slice(1)).join(\"\");\n  }\n\n  parseHardhatArguments(hardhatParamDefinitions, envVariableArguments, rawCLAs) {\n    const hardhatArguments = {};\n    let taskName;\n    const unparsedCLAs = [];\n\n    for (let i = 0; i < rawCLAs.length; i++) {\n      const arg = rawCLAs[i];\n\n      if (taskName === undefined) {\n        if (!this._hasCLAParamNameFormat(arg)) {\n          taskName = arg;\n          continue;\n        }\n\n        if (!this._isCLAParamName(arg, hardhatParamDefinitions)) {\n          throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_COMMAND_LINE_ARG, {\n            argument: arg\n          });\n        }\n\n        i = this._parseArgumentAt(rawCLAs, i, hardhatParamDefinitions, hardhatArguments);\n      } else {\n        if (!this._isCLAParamName(arg, hardhatParamDefinitions)) {\n          unparsedCLAs.push(arg);\n          continue;\n        }\n\n        i = this._parseArgumentAt(rawCLAs, i, hardhatParamDefinitions, hardhatArguments);\n      }\n    }\n\n    return {\n      hardhatArguments: this._addHardhatDefaultArguments(hardhatParamDefinitions, envVariableArguments, hardhatArguments),\n      taskName,\n      unparsedCLAs\n    };\n  }\n\n  parseTaskArguments(taskDefinition, rawCLAs) {\n    const {\n      paramArguments,\n      rawPositionalArguments\n    } = this._parseTaskParamArguments(taskDefinition, rawCLAs);\n\n    const positionalArguments = this._parsePositionalParamArgs(rawPositionalArguments, taskDefinition.positionalParamDefinitions);\n\n    return Object.assign(Object.assign({}, paramArguments), positionalArguments);\n  }\n\n  _parseTaskParamArguments(taskDefinition, rawCLAs) {\n    const paramArguments = {};\n    const rawPositionalArguments = [];\n\n    for (let i = 0; i < rawCLAs.length; i++) {\n      const arg = rawCLAs[i];\n\n      if (!this._hasCLAParamNameFormat(arg)) {\n        rawPositionalArguments.push(arg);\n        continue;\n      }\n\n      if (!this._isCLAParamName(arg, taskDefinition.paramDefinitions)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_PARAM_NAME, {\n          param: arg\n        });\n      }\n\n      i = this._parseArgumentAt(rawCLAs, i, taskDefinition.paramDefinitions, paramArguments);\n    }\n\n    this._addTaskDefaultArguments(taskDefinition, paramArguments);\n\n    return {\n      paramArguments,\n      rawPositionalArguments\n    };\n  }\n\n  _addHardhatDefaultArguments(hardhatParamDefinitions, envVariableArguments, hardhatArguments) {\n    return Object.assign(Object.assign({}, envVariableArguments), hardhatArguments);\n  }\n\n  _addTaskDefaultArguments(taskDefinition, taskArguments) {\n    for (const paramName of Object.keys(taskDefinition.paramDefinitions)) {\n      const definition = taskDefinition.paramDefinitions[paramName];\n\n      if (taskArguments[paramName] !== undefined) {\n        continue;\n      }\n\n      if (!definition.isOptional) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n          param: ArgumentsParser.paramNameToCLA(paramName)\n        });\n      }\n\n      taskArguments[paramName] = definition.defaultValue;\n    }\n  }\n\n  _isCLAParamName(str, paramDefinitions) {\n    if (!this._hasCLAParamNameFormat(str)) {\n      return false;\n    }\n\n    const name = ArgumentsParser.cLAToParamName(str);\n    return paramDefinitions[name] !== undefined;\n  }\n\n  _hasCLAParamNameFormat(str) {\n    return str.startsWith(ArgumentsParser.PARAM_PREFIX);\n  }\n\n  _parseArgumentAt(rawCLAs, index, paramDefinitions, parsedArguments) {\n    const claArg = rawCLAs[index];\n    const paramName = ArgumentsParser.cLAToParamName(claArg);\n    const definition = paramDefinitions[paramName];\n\n    if (parsedArguments[paramName] !== undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.REPEATED_PARAM, {\n        param: claArg\n      });\n    }\n\n    if (definition.isFlag) {\n      parsedArguments[paramName] = true;\n    } else {\n      index++;\n      const value = rawCLAs[index];\n\n      if (value === undefined) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n          param: ArgumentsParser.paramNameToCLA(paramName)\n        });\n      } // We only parse the arguments of non-subtasks, and those only\n      // accept CLIArgumentTypes.\n\n\n      const type = definition.type;\n      parsedArguments[paramName] = type.parse(paramName, value);\n    }\n\n    return index;\n  }\n\n  _parsePositionalParamArgs(rawPositionalParamArgs, positionalParamDefinitions) {\n    const args = {};\n\n    for (let i = 0; i < positionalParamDefinitions.length; i++) {\n      const definition = positionalParamDefinitions[i]; // We only parse the arguments of non-subtasks, and those only\n      // accept CLIArgumentTypes.\n\n      const type = definition.type;\n      const rawArg = rawPositionalParamArgs[i];\n\n      if (rawArg === undefined) {\n        if (!definition.isOptional) {\n          throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.MISSING_POSITIONAL_ARG, {\n            param: definition.name\n          });\n        }\n\n        args[definition.name] = definition.defaultValue;\n      } else if (!definition.isVariadic) {\n        args[definition.name] = type.parse(definition.name, rawArg);\n      } else {\n        args[definition.name] = rawPositionalParamArgs.slice(i).map(raw => type.parse(definition.name, raw));\n      }\n    }\n\n    const lastDefinition = positionalParamDefinitions[positionalParamDefinitions.length - 1];\n    const hasVariadicParam = lastDefinition !== undefined && lastDefinition.isVariadic;\n\n    if (!hasVariadicParam && rawPositionalParamArgs.length > positionalParamDefinitions.length) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_POSITIONAL_ARG, {\n        argument: rawPositionalParamArgs[positionalParamDefinitions.length]\n      });\n    }\n\n    return args;\n  }\n\n}\n\nexports.ArgumentsParser = ArgumentsParser;\nArgumentsParser.PARAM_PREFIX = \"--\";","map":{"version":3,"mappings":";;;;;;;AASA;;AACA;;AAEA,MAAaA,eAAb,CAA4B;AAGE,SAAdC,cAAc,CAACC,SAAD,EAAkB;AAC5C,WACEF,eAAe,CAACG,YAAhB,GACAD,SAAS,CACNE,KADH,CACS,YADT,EAEGC,GAFH,CAEQC,CAAD,IAAOA,CAAC,CAACC,WAAF,EAFd,EAGGC,IAHH,CAGQ,GAHR,CAFF;AAOD;;AAE2B,SAAdC,cAAc,CAACC,GAAD,EAAY;AACtC,QAAIA,GAAG,CAACH,WAAJ,OAAsBG,GAA1B,EAA+B;AAC7B,YAAM,IAAIC,qBAAJ,CAAiBC,qBAAOC,SAAP,CAAiBC,yBAAlC,EAA6D;AACjEC,aAAK,EAAEL;AAD0D,OAA7D,CAAN;AAGD;;AAED,UAAMM,KAAK,GAAGN,GAAG,CACdO,KADW,CACLjB,eAAe,CAACG,YAAhB,CAA6Be,MADxB,EAEXd,KAFW,CAEL,GAFK,EAGXe,MAHW,CAGHC,CAAD,IAAOA,CAAC,CAACF,MAAF,GAAW,CAHd,CAAd;AAKA,WACEF,KAAK,CAAC,CAAD,CAAL,GACAA,KAAK,CACFC,KADH,CACS,CADT,EAEGZ,GAFH,CAEQC,CAAD,IAAOA,CAAC,CAAC,CAAD,CAAD,CAAKe,WAAL,KAAqBf,CAAC,CAACW,KAAF,CAAQ,CAAR,CAFnC,EAGGT,IAHH,CAGQ,EAHR,CAFF;AAOD;;AAEMc,uBAAqB,CAC1BC,uBAD0B,EAE1BC,oBAF0B,EAG1BC,OAH0B,EAGT;AAMjB,UAAMC,gBAAgB,GAA8B,EAApD;AACA,QAAIC,QAAJ;AACA,UAAMC,YAAY,GAAa,EAA/B;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,OAAO,CAACP,MAA5B,EAAoCW,CAAC,EAArC,EAAyC;AACvC,YAAMC,GAAG,GAAGL,OAAO,CAACI,CAAD,CAAnB;;AAEA,UAAIF,QAAQ,KAAKI,SAAjB,EAA4B;AAC1B,YAAI,CAAC,KAAKC,sBAAL,CAA4BF,GAA5B,CAAL,EAAuC;AACrCH,kBAAQ,GAAGG,GAAX;AACA;AACD;;AAED,YAAI,CAAC,KAAKG,eAAL,CAAqBH,GAArB,EAA0BP,uBAA1B,CAAL,EAAyD;AACvD,gBAAM,IAAIZ,qBAAJ,CACJC,qBAAOC,SAAP,CAAiBqB,6BADb,EAEJ;AAAEC,oBAAQ,EAAEL;AAAZ,WAFI,CAAN;AAID;;AAEDD,SAAC,GAAG,KAAKO,gBAAL,CACFX,OADE,EAEFI,CAFE,EAGFN,uBAHE,EAIFG,gBAJE,CAAJ;AAMD,OAnBD,MAmBO;AACL,YAAI,CAAC,KAAKO,eAAL,CAAqBH,GAArB,EAA0BP,uBAA1B,CAAL,EAAyD;AACvDK,sBAAY,CAACS,IAAb,CAAkBP,GAAlB;AACA;AACD;;AAEDD,SAAC,GAAG,KAAKO,gBAAL,CACFX,OADE,EAEFI,CAFE,EAGFN,uBAHE,EAIFG,gBAJE,CAAJ;AAMD;AACF;;AAED,WAAO;AACLA,sBAAgB,EAAE,KAAKY,2BAAL,CAChBf,uBADgB,EAEhBC,oBAFgB,EAGhBE,gBAHgB,CADb;AAMLC,cANK;AAOLC;AAPK,KAAP;AASD;;AAEMW,oBAAkB,CACvBC,cADuB,EAEvBf,OAFuB,EAEN;AAEjB,UAAM;AAAEgB,oBAAF;AAAkBC;AAAlB,QACJ,KAAKC,wBAAL,CAA8BH,cAA9B,EAA8Cf,OAA9C,CADF;;AAGA,UAAMmB,mBAAmB,GAAG,KAAKC,yBAAL,CAC1BH,sBAD0B,EAE1BF,cAAc,CAACM,0BAFW,CAA5B;;AAKA,2CAAYL,cAAZ,GAA+BG,mBAA/B;AACD;;AAEOD,0BAAwB,CAC9BH,cAD8B,EAE9Bf,OAF8B,EAEb;AAEjB,UAAMgB,cAAc,GAAG,EAAvB;AACA,UAAMC,sBAAsB,GAAa,EAAzC;;AAEA,SAAK,IAAIb,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,OAAO,CAACP,MAA5B,EAAoCW,CAAC,EAArC,EAAyC;AACvC,YAAMC,GAAG,GAAGL,OAAO,CAACI,CAAD,CAAnB;;AAEA,UAAI,CAAC,KAAKG,sBAAL,CAA4BF,GAA5B,CAAL,EAAuC;AACrCY,8BAAsB,CAACL,IAAvB,CAA4BP,GAA5B;AACA;AACD;;AAED,UAAI,CAAC,KAAKG,eAAL,CAAqBH,GAArB,EAA0BU,cAAc,CAACO,gBAAzC,CAAL,EAAiE;AAC/D,cAAM,IAAIpC,qBAAJ,CAAiBC,qBAAOC,SAAP,CAAiBmC,uBAAlC,EAA2D;AAC/DjC,eAAK,EAAEe;AADwD,SAA3D,CAAN;AAGD;;AAEDD,OAAC,GAAG,KAAKO,gBAAL,CACFX,OADE,EAEFI,CAFE,EAGFW,cAAc,CAACO,gBAHb,EAIFN,cAJE,CAAJ;AAMD;;AAED,SAAKQ,wBAAL,CAA8BT,cAA9B,EAA8CC,cAA9C;;AAEA,WAAO;AAAEA,oBAAF;AAAkBC;AAAlB,KAAP;AACD;;AAEOJ,6BAA2B,CACjCf,uBADiC,EAEjCC,oBAFiC,EAGjCE,gBAHiC,EAGU;AAE3C,2CACKF,oBADL,GAEKE,gBAFL;AAID;;AAEOuB,0BAAwB,CAC9BT,cAD8B,EAE9BU,aAF8B,EAEF;AAE5B,SAAK,MAAMhD,SAAX,IAAwBiD,MAAM,CAACC,IAAP,CAAYZ,cAAc,CAACO,gBAA3B,CAAxB,EAAsE;AACpE,YAAMM,UAAU,GAAGb,cAAc,CAACO,gBAAf,CAAgC7C,SAAhC,CAAnB;;AAEA,UAAIgD,aAAa,CAAChD,SAAD,CAAb,KAA6B6B,SAAjC,EAA4C;AAC1C;AACD;;AACD,UAAI,CAACsB,UAAU,CAACC,UAAhB,EAA4B;AAC1B,cAAM,IAAI3C,qBAAJ,CAAiBC,qBAAOC,SAAP,CAAiB0C,qBAAlC,EAAyD;AAC7DxC,eAAK,EAAEf,eAAe,CAACC,cAAhB,CAA+BC,SAA/B;AADsD,SAAzD,CAAN;AAGD;;AAEDgD,mBAAa,CAAChD,SAAD,CAAb,GAA2BmD,UAAU,CAACG,YAAtC;AACD;AACF;;AAEOvB,iBAAe,CAACwB,GAAD,EAAcV,gBAAd,EAAmD;AACxE,QAAI,CAAC,KAAKf,sBAAL,CAA4ByB,GAA5B,CAAL,EAAuC;AACrC,aAAO,KAAP;AACD;;AAED,UAAMC,IAAI,GAAG1D,eAAe,CAACS,cAAhB,CAA+BgD,GAA/B,CAAb;AACA,WAAOV,gBAAgB,CAACW,IAAD,CAAhB,KAA2B3B,SAAlC;AACD;;AAEOC,wBAAsB,CAACyB,GAAD,EAAY;AACxC,WAAOA,GAAG,CAACE,UAAJ,CAAe3D,eAAe,CAACG,YAA/B,CAAP;AACD;;AAEOiC,kBAAgB,CACtBX,OADsB,EAEtBmC,KAFsB,EAGtBb,gBAHsB,EAItBc,eAJsB,EAIQ;AAE9B,UAAMC,MAAM,GAAGrC,OAAO,CAACmC,KAAD,CAAtB;AACA,UAAM1D,SAAS,GAAGF,eAAe,CAACS,cAAhB,CAA+BqD,MAA/B,CAAlB;AACA,UAAMT,UAAU,GAAGN,gBAAgB,CAAC7C,SAAD,CAAnC;;AAEA,QAAI2D,eAAe,CAAC3D,SAAD,CAAf,KAA+B6B,SAAnC,EAA8C;AAC5C,YAAM,IAAIpB,qBAAJ,CAAiBC,qBAAOC,SAAP,CAAiBkD,cAAlC,EAAkD;AACtDhD,aAAK,EAAE+C;AAD+C,OAAlD,CAAN;AAGD;;AAED,QAAIT,UAAU,CAACW,MAAf,EAAuB;AACrBH,qBAAe,CAAC3D,SAAD,CAAf,GAA6B,IAA7B;AACD,KAFD,MAEO;AACL0D,WAAK;AACL,YAAMK,KAAK,GAAGxC,OAAO,CAACmC,KAAD,CAArB;;AAEA,UAAIK,KAAK,KAAKlC,SAAd,EAAyB;AACvB,cAAM,IAAIpB,qBAAJ,CAAiBC,qBAAOC,SAAP,CAAiB0C,qBAAlC,EAAyD;AAC7DxC,eAAK,EAAEf,eAAe,CAACC,cAAhB,CAA+BC,SAA/B;AADsD,SAAzD,CAAN;AAGD,OARI,CAUL;AACA;;;AACA,YAAMgE,IAAI,GAAGb,UAAU,CAACa,IAAxB;AACAL,qBAAe,CAAC3D,SAAD,CAAf,GAA6BgE,IAAI,CAACC,KAAL,CAAWjE,SAAX,EAAsB+D,KAAtB,CAA7B;AACD;;AAED,WAAOL,KAAP;AACD;;AAEOf,2BAAyB,CAC/BuB,sBAD+B,EAE/BtB,0BAF+B,EAEwB;AAEvD,UAAMuB,IAAI,GAAkB,EAA5B;;AAEA,SAAK,IAAIxC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiB,0BAA0B,CAAC5B,MAA/C,EAAuDW,CAAC,EAAxD,EAA4D;AAC1D,YAAMwB,UAAU,GAAGP,0BAA0B,CAACjB,CAAD,CAA7C,CAD0D,CAE1D;AACA;;AACA,YAAMqC,IAAI,GAAGb,UAAU,CAACa,IAAxB;AAEA,YAAMI,MAAM,GAAGF,sBAAsB,CAACvC,CAAD,CAArC;;AAEA,UAAIyC,MAAM,KAAKvC,SAAf,EAA0B;AACxB,YAAI,CAACsB,UAAU,CAACC,UAAhB,EAA4B;AAC1B,gBAAM,IAAI3C,qBAAJ,CAAiBC,qBAAOC,SAAP,CAAiB0D,sBAAlC,EAA0D;AAC9DxD,iBAAK,EAAEsC,UAAU,CAACK;AAD4C,WAA1D,CAAN;AAGD;;AAEDW,YAAI,CAAChB,UAAU,CAACK,IAAZ,CAAJ,GAAwBL,UAAU,CAACG,YAAnC;AACD,OARD,MAQO,IAAI,CAACH,UAAU,CAACmB,UAAhB,EAA4B;AACjCH,YAAI,CAAChB,UAAU,CAACK,IAAZ,CAAJ,GAAwBQ,IAAI,CAACC,KAAL,CAAWd,UAAU,CAACK,IAAtB,EAA4BY,MAA5B,CAAxB;AACD,OAFM,MAEA;AACLD,YAAI,CAAChB,UAAU,CAACK,IAAZ,CAAJ,GAAwBU,sBAAsB,CAC3CnD,KADqB,CACfY,CADe,EAErBxB,GAFqB,CAEhBoE,GAAD,IAASP,IAAI,CAACC,KAAL,CAAWd,UAAU,CAACK,IAAtB,EAA4Be,GAA5B,CAFQ,CAAxB;AAGD;AACF;;AAED,UAAMC,cAAc,GAClB5B,0BAA0B,CAACA,0BAA0B,CAAC5B,MAA3B,GAAoC,CAArC,CAD5B;AAGA,UAAMyD,gBAAgB,GACpBD,cAAc,KAAK3C,SAAnB,IAAgC2C,cAAc,CAACF,UADjD;;AAGA,QACE,CAACG,gBAAD,IACAP,sBAAsB,CAAClD,MAAvB,GAAgC4B,0BAA0B,CAAC5B,MAF7D,EAGE;AACA,YAAM,IAAIP,qBAAJ,CAAiBC,qBAAOC,SAAP,CAAiB+D,2BAAlC,EAA+D;AACnEzC,gBAAQ,EAAEiC,sBAAsB,CAACtB,0BAA0B,CAAC5B,MAA5B;AADmC,OAA/D,CAAN;AAGD;;AAED,WAAOmD,IAAP;AACD;;AAhRyB;;AAA5BQ;AACyB7E,+BAAe,IAAf","names":["ArgumentsParser","paramNameToCLA","paramName","PARAM_PREFIX","split","map","s","toLowerCase","join","cLAToParamName","cLA","errors_1","errors_list_1","ARGUMENTS","PARAM_NAME_INVALID_CASING","param","parts","slice","length","filter","x","toUpperCase","parseHardhatArguments","hardhatParamDefinitions","envVariableArguments","rawCLAs","hardhatArguments","taskName","unparsedCLAs","i","arg","undefined","_hasCLAParamNameFormat","_isCLAParamName","UNRECOGNIZED_COMMAND_LINE_ARG","argument","_parseArgumentAt","push","_addHardhatDefaultArguments","parseTaskArguments","taskDefinition","paramArguments","rawPositionalArguments","_parseTaskParamArguments","positionalArguments","_parsePositionalParamArgs","positionalParamDefinitions","paramDefinitions","UNRECOGNIZED_PARAM_NAME","_addTaskDefaultArguments","taskArguments","Object","keys","definition","isOptional","MISSING_TASK_ARGUMENT","defaultValue","str","name","startsWith","index","parsedArguments","claArg","REPEATED_PARAM","isFlag","value","type","parse","rawPositionalParamArgs","args","rawArg","MISSING_POSITIONAL_ARG","isVariadic","raw","lastDefinition","hasVariadicParam","UNRECOGNIZED_POSITIONAL_ARG","exports"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/internal/cli/ArgumentsParser.ts"],"sourcesContent":["import {\n  CLIArgumentType,\n  HardhatArguments,\n  HardhatParamDefinitions,\n  ParamDefinition,\n  ParamDefinitionsMap,\n  TaskArguments,\n  TaskDefinition,\n} from \"../../types\";\nimport { HardhatError } from \"../core/errors\";\nimport { ERRORS } from \"../core/errors-list\";\n\nexport class ArgumentsParser {\n  public static readonly PARAM_PREFIX = \"--\";\n\n  public static paramNameToCLA(paramName: string): string {\n    return (\n      ArgumentsParser.PARAM_PREFIX +\n      paramName\n        .split(/(?=[A-Z])/g)\n        .map((s) => s.toLowerCase())\n        .join(\"-\")\n    );\n  }\n\n  public static cLAToParamName(cLA: string): string {\n    if (cLA.toLowerCase() !== cLA) {\n      throw new HardhatError(ERRORS.ARGUMENTS.PARAM_NAME_INVALID_CASING, {\n        param: cLA,\n      });\n    }\n\n    const parts = cLA\n      .slice(ArgumentsParser.PARAM_PREFIX.length)\n      .split(\"-\")\n      .filter((x) => x.length > 0);\n\n    return (\n      parts[0] +\n      parts\n        .slice(1)\n        .map((s) => s[0].toUpperCase() + s.slice(1))\n        .join(\"\")\n    );\n  }\n\n  public parseHardhatArguments(\n    hardhatParamDefinitions: HardhatParamDefinitions,\n    envVariableArguments: HardhatArguments,\n    rawCLAs: string[]\n  ): {\n    hardhatArguments: HardhatArguments;\n    taskName?: string;\n    unparsedCLAs: string[];\n  } {\n    const hardhatArguments: Partial<HardhatArguments> = {};\n    let taskName: string | undefined;\n    const unparsedCLAs: string[] = [];\n\n    for (let i = 0; i < rawCLAs.length; i++) {\n      const arg = rawCLAs[i];\n\n      if (taskName === undefined) {\n        if (!this._hasCLAParamNameFormat(arg)) {\n          taskName = arg;\n          continue;\n        }\n\n        if (!this._isCLAParamName(arg, hardhatParamDefinitions)) {\n          throw new HardhatError(\n            ERRORS.ARGUMENTS.UNRECOGNIZED_COMMAND_LINE_ARG,\n            { argument: arg }\n          );\n        }\n\n        i = this._parseArgumentAt(\n          rawCLAs,\n          i,\n          hardhatParamDefinitions,\n          hardhatArguments\n        );\n      } else {\n        if (!this._isCLAParamName(arg, hardhatParamDefinitions)) {\n          unparsedCLAs.push(arg);\n          continue;\n        }\n\n        i = this._parseArgumentAt(\n          rawCLAs,\n          i,\n          hardhatParamDefinitions,\n          hardhatArguments\n        );\n      }\n    }\n\n    return {\n      hardhatArguments: this._addHardhatDefaultArguments(\n        hardhatParamDefinitions,\n        envVariableArguments,\n        hardhatArguments\n      ),\n      taskName,\n      unparsedCLAs,\n    };\n  }\n\n  public parseTaskArguments(\n    taskDefinition: TaskDefinition,\n    rawCLAs: string[]\n  ): TaskArguments {\n    const { paramArguments, rawPositionalArguments } =\n      this._parseTaskParamArguments(taskDefinition, rawCLAs);\n\n    const positionalArguments = this._parsePositionalParamArgs(\n      rawPositionalArguments,\n      taskDefinition.positionalParamDefinitions\n    );\n\n    return { ...paramArguments, ...positionalArguments };\n  }\n\n  private _parseTaskParamArguments(\n    taskDefinition: TaskDefinition,\n    rawCLAs: string[]\n  ) {\n    const paramArguments = {};\n    const rawPositionalArguments: string[] = [];\n\n    for (let i = 0; i < rawCLAs.length; i++) {\n      const arg = rawCLAs[i];\n\n      if (!this._hasCLAParamNameFormat(arg)) {\n        rawPositionalArguments.push(arg);\n        continue;\n      }\n\n      if (!this._isCLAParamName(arg, taskDefinition.paramDefinitions)) {\n        throw new HardhatError(ERRORS.ARGUMENTS.UNRECOGNIZED_PARAM_NAME, {\n          param: arg,\n        });\n      }\n\n      i = this._parseArgumentAt(\n        rawCLAs,\n        i,\n        taskDefinition.paramDefinitions,\n        paramArguments\n      );\n    }\n\n    this._addTaskDefaultArguments(taskDefinition, paramArguments);\n\n    return { paramArguments, rawPositionalArguments };\n  }\n\n  private _addHardhatDefaultArguments(\n    hardhatParamDefinitions: HardhatParamDefinitions,\n    envVariableArguments: HardhatArguments,\n    hardhatArguments: Partial<HardhatArguments>\n  ): HardhatArguments {\n    return {\n      ...envVariableArguments,\n      ...hardhatArguments,\n    };\n  }\n\n  private _addTaskDefaultArguments(\n    taskDefinition: TaskDefinition,\n    taskArguments: TaskArguments\n  ) {\n    for (const paramName of Object.keys(taskDefinition.paramDefinitions)) {\n      const definition = taskDefinition.paramDefinitions[paramName];\n\n      if (taskArguments[paramName] !== undefined) {\n        continue;\n      }\n      if (!definition.isOptional) {\n        throw new HardhatError(ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n          param: ArgumentsParser.paramNameToCLA(paramName),\n        });\n      }\n\n      taskArguments[paramName] = definition.defaultValue;\n    }\n  }\n\n  private _isCLAParamName(str: string, paramDefinitions: ParamDefinitionsMap) {\n    if (!this._hasCLAParamNameFormat(str)) {\n      return false;\n    }\n\n    const name = ArgumentsParser.cLAToParamName(str);\n    return paramDefinitions[name] !== undefined;\n  }\n\n  private _hasCLAParamNameFormat(str: string) {\n    return str.startsWith(ArgumentsParser.PARAM_PREFIX);\n  }\n\n  private _parseArgumentAt(\n    rawCLAs: string[],\n    index: number,\n    paramDefinitions: ParamDefinitionsMap,\n    parsedArguments: TaskArguments\n  ) {\n    const claArg = rawCLAs[index];\n    const paramName = ArgumentsParser.cLAToParamName(claArg);\n    const definition = paramDefinitions[paramName];\n\n    if (parsedArguments[paramName] !== undefined) {\n      throw new HardhatError(ERRORS.ARGUMENTS.REPEATED_PARAM, {\n        param: claArg,\n      });\n    }\n\n    if (definition.isFlag) {\n      parsedArguments[paramName] = true;\n    } else {\n      index++;\n      const value = rawCLAs[index];\n\n      if (value === undefined) {\n        throw new HardhatError(ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n          param: ArgumentsParser.paramNameToCLA(paramName),\n        });\n      }\n\n      // We only parse the arguments of non-subtasks, and those only\n      // accept CLIArgumentTypes.\n      const type = definition.type as CLIArgumentType<any>;\n      parsedArguments[paramName] = type.parse(paramName, value);\n    }\n\n    return index;\n  }\n\n  private _parsePositionalParamArgs(\n    rawPositionalParamArgs: string[],\n    positionalParamDefinitions: Array<ParamDefinition<any>>\n  ): TaskArguments {\n    const args: TaskArguments = {};\n\n    for (let i = 0; i < positionalParamDefinitions.length; i++) {\n      const definition = positionalParamDefinitions[i];\n      // We only parse the arguments of non-subtasks, and those only\n      // accept CLIArgumentTypes.\n      const type = definition.type as CLIArgumentType<any>;\n\n      const rawArg = rawPositionalParamArgs[i];\n\n      if (rawArg === undefined) {\n        if (!definition.isOptional) {\n          throw new HardhatError(ERRORS.ARGUMENTS.MISSING_POSITIONAL_ARG, {\n            param: definition.name,\n          });\n        }\n\n        args[definition.name] = definition.defaultValue;\n      } else if (!definition.isVariadic) {\n        args[definition.name] = type.parse(definition.name, rawArg);\n      } else {\n        args[definition.name] = rawPositionalParamArgs\n          .slice(i)\n          .map((raw) => type.parse(definition.name, raw));\n      }\n    }\n\n    const lastDefinition =\n      positionalParamDefinitions[positionalParamDefinitions.length - 1];\n\n    const hasVariadicParam =\n      lastDefinition !== undefined && lastDefinition.isVariadic;\n\n    if (\n      !hasVariadicParam &&\n      rawPositionalParamArgs.length > positionalParamDefinitions.length\n    ) {\n      throw new HardhatError(ERRORS.ARGUMENTS.UNRECOGNIZED_POSITIONAL_ARG, {\n        argument: rawPositionalParamArgs[positionalParamDefinitions.length],\n      });\n    }\n\n    return args;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}