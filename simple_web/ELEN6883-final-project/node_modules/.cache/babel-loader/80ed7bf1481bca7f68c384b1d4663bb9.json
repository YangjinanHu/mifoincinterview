{"ast":null,"code":"var util = require('util');\n\nmodule.exports = function tsort(initial) {\n  var graph = new Graph();\n\n  if (initial) {\n    initial.forEach(function (entry) {\n      Graph.prototype.add.apply(graph, entry);\n    });\n  }\n\n  return graph;\n};\n\nfunction Graph() {\n  this.nodes = {};\n} // Add sorted items to the graph\n\n\nGraph.prototype.add = function () {\n  var self = this;\n  var items = [].slice.call(arguments);\n  if (items.length == 1 && util.isArray(items[0])) items = items[0];\n  items.forEach(function (item) {\n    if (!self.nodes[item]) self.nodes[item] = [];\n  });\n\n  for (var i = 1; i < items.length; i++) {\n    var from = items[i];\n    var to = items[i - 1];\n    self.nodes[from].push(to);\n  }\n\n  return self;\n}; // Depth first search\n// As given in http://en.wikipedia.org/wiki/Topological_sorting\n\n\nGraph.prototype.sort = function () {\n  var self = this;\n  var nodes = Object.keys(this.nodes);\n  var sorted = [];\n  var marks = {};\n\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    if (!marks[node]) visit(node);\n  }\n\n  return sorted;\n\n  function visit(node) {\n    if (marks[node] === 'temp') throw new Error(\"There is a cycle in the graph. It is not possible to derive a topological sort.\");else if (marks[node]) return;\n    marks[node] = 'temp';\n    self.nodes[node].forEach(visit);\n    marks[node] = 'perm';\n    sorted.push(node);\n  }\n};","map":{"version":3,"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/tsort/index.js"],"names":["util","require","module","exports","tsort","initial","graph","Graph","forEach","entry","prototype","add","apply","nodes","self","items","slice","call","arguments","length","isArray","item","i","from","to","push","sort","Object","keys","sorted","marks","node","visit","Error"],"mappings":"AAAA,IAAIA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAAlB;;AAEAC,MAAM,CAACC,OAAP,GAAiB,SAASC,KAAT,CAAeC,OAAf,EAAwB;AACvC,MAAIC,KAAK,GAAG,IAAIC,KAAJ,EAAZ;;AAEA,MAAIF,OAAJ,EAAa;AACXA,IAAAA,OAAO,CAACG,OAAR,CAAgB,UAASC,KAAT,EAAgB;AAC9BF,MAAAA,KAAK,CAACG,SAAN,CAAgBC,GAAhB,CAAoBC,KAApB,CAA0BN,KAA1B,EAAiCG,KAAjC;AACD,KAFD;AAGD;;AAED,SAAOH,KAAP;AACD,CAVD;;AAYA,SAASC,KAAT,GAAiB;AACf,OAAKM,KAAL,GAAa,EAAb;AACD,C,CAED;;;AACAN,KAAK,CAACG,SAAN,CAAgBC,GAAhB,GAAsB,YAAW;AAC/B,MAAIG,IAAI,GAAG,IAAX;AACA,MAAIC,KAAK,GAAG,GAAGC,KAAH,CAASC,IAAT,CAAcC,SAAd,CAAZ;AAEA,MAAIH,KAAK,CAACI,MAAN,IAAgB,CAAhB,IAAqBnB,IAAI,CAACoB,OAAL,CAAaL,KAAK,CAAC,CAAD,CAAlB,CAAzB,EACEA,KAAK,GAAGA,KAAK,CAAC,CAAD,CAAb;AAEFA,EAAAA,KAAK,CAACP,OAAN,CAAc,UAASa,IAAT,EAAe;AAC3B,QAAI,CAACP,IAAI,CAACD,KAAL,CAAWQ,IAAX,CAAL,EACEP,IAAI,CAACD,KAAL,CAAWQ,IAAX,IAAmB,EAAnB;AACH,GAHD;;AAKA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,KAAK,CAACI,MAA1B,EAAkCG,CAAC,EAAnC,EAAuC;AACrC,QAAIC,IAAI,GAAGR,KAAK,CAACO,CAAD,CAAhB;AACA,QAAIE,EAAE,GAAGT,KAAK,CAACO,CAAC,GAAG,CAAL,CAAd;AAEAR,IAAAA,IAAI,CAACD,KAAL,CAAWU,IAAX,EAAiBE,IAAjB,CAAsBD,EAAtB;AACD;;AAED,SAAOV,IAAP;AACD,CApBD,C,CAsBA;AACA;;;AACAP,KAAK,CAACG,SAAN,CAAgBgB,IAAhB,GAAuB,YAAW;AAChC,MAAIZ,IAAI,GAAG,IAAX;AACA,MAAID,KAAK,GAAGc,MAAM,CAACC,IAAP,CAAY,KAAKf,KAAjB,CAAZ;AAEA,MAAIgB,MAAM,GAAG,EAAb;AACA,MAAIC,KAAK,GAAG,EAAZ;;AAEA,OAAK,IAAIR,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,KAAK,CAACM,MAA1B,EAAkCG,CAAC,EAAnC,EAAuC;AACrC,QAAIS,IAAI,GAAGlB,KAAK,CAACS,CAAD,CAAhB;AAEA,QAAI,CAACQ,KAAK,CAACC,IAAD,CAAV,EACEC,KAAK,CAACD,IAAD,CAAL;AACH;;AAED,SAAOF,MAAP;;AAEA,WAASG,KAAT,CAAeD,IAAf,EAAqB;AACnB,QAAID,KAAK,CAACC,IAAD,CAAL,KAAgB,MAApB,EACE,MAAM,IAAIE,KAAJ,CAAU,iFAAV,CAAN,CADF,KAEK,IAAIH,KAAK,CAACC,IAAD,CAAT,EACH;AAEFD,IAAAA,KAAK,CAACC,IAAD,CAAL,GAAc,MAAd;AACAjB,IAAAA,IAAI,CAACD,KAAL,CAAWkB,IAAX,EAAiBvB,OAAjB,CAAyBwB,KAAzB;AACAF,IAAAA,KAAK,CAACC,IAAD,CAAL,GAAc,MAAd;AAEAF,IAAAA,MAAM,CAACJ,IAAP,CAAYM,IAAZ;AACD;AACF,CA5BD","sourcesContent":["var util = require('util');\n\nmodule.exports = function tsort(initial) {\n  var graph = new Graph();\n\n  if (initial) {\n    initial.forEach(function(entry) {\n      Graph.prototype.add.apply(graph, entry);\n    });\n  }\n\n  return graph;\n}\n\nfunction Graph() {\n  this.nodes = {};\n}\n\n// Add sorted items to the graph\nGraph.prototype.add = function() {\n  var self = this;\n  var items = [].slice.call(arguments);\n\n  if (items.length == 1 && util.isArray(items[0]))\n    items = items[0];\n\n  items.forEach(function(item) {\n    if (!self.nodes[item])\n      self.nodes[item] = [];\n  });\n\n  for (var i = 1; i < items.length; i++) {\n    var from = items[i];\n    var to = items[i - 1];\n\n    self.nodes[from].push(to);\n  }\n\n  return self;\n};\n\n// Depth first search\n// As given in http://en.wikipedia.org/wiki/Topological_sorting\nGraph.prototype.sort = function() {\n  var self = this;\n  var nodes = Object.keys(this.nodes);\n\n  var sorted = [];\n  var marks = {};\n\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n\n    if (!marks[node])\n      visit(node);\n  }\n\n  return sorted;\n\n  function visit(node) {\n    if (marks[node] === 'temp')\n      throw new Error(\"There is a cycle in the graph. It is not possible to derive a topological sort.\");\n    else if (marks[node])\n      return;\n\n    marks[node] = 'temp';\n    self.nodes[node].forEach(visit);\n    marks[node] = 'perm';\n\n    sorted.push(node);\n  }\n};\n"]},"metadata":{},"sourceType":"script"}