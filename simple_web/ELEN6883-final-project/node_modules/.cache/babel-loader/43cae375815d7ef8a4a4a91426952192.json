{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getArtifactFromContractOutput = exports.Artifacts = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\n\nconst os = __importStar(require(\"os\"));\n\nconst path = __importStar(require(\"path\"));\n\nconst contract_names_1 = require(\"../utils/contract-names\");\n\nconst source_names_1 = require(\"../utils/source-names\");\n\nconst constants_1 = require(\"./constants\");\n\nconst errors_1 = require(\"./core/errors\");\n\nconst errors_list_1 = require(\"./core/errors-list\");\n\nconst glob_1 = require(\"./util/glob\");\n\nconst hash_1 = require(\"./util/hash\");\n\nconst log = (0, debug_1.default)(\"hardhat:core:artifacts\");\n\nclass Artifacts {\n  constructor(_artifactsPath) {\n    this._artifactsPath = _artifactsPath;\n    this._buildInfosGlob = path.join(this._artifactsPath, constants_1.BUILD_INFO_DIR_NAME, \"**/*.json\");\n    this._dbgsGlob = path.join(this._artifactsPath, \"**/*.dbg.json\");\n    this._validArtifacts = [];\n  }\n\n  addValidArtifacts(validArtifacts) {\n    this._validArtifacts.push(...validArtifacts);\n  }\n\n  async readArtifact(name) {\n    const artifactPath = await this._getArtifactPath(name);\n    return fs_extra_1.default.readJson(artifactPath);\n  }\n\n  readArtifactSync(name) {\n    const artifactPath = this._getArtifactPathSync(name);\n\n    return fs_extra_1.default.readJsonSync(artifactPath);\n  }\n\n  async artifactExists(name) {\n    try {\n      await this.readArtifact(name);\n      return true;\n    } catch (_a) {\n      return false;\n    }\n  }\n\n  async getAllFullyQualifiedNames() {\n    const paths = await this.getArtifactPaths();\n    return paths.map(p => this._getFullyQualifiedNameFromPath(p)).sort();\n  }\n\n  async getBuildInfo(fullyQualifiedName) {\n    const artifactPath = this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n\n    const debugFilePath = this._getDebugFilePath(artifactPath);\n\n    const buildInfoPath = await this._getBuildInfoFromDebugFile(debugFilePath);\n\n    if (buildInfoPath === undefined) {\n      return undefined;\n    }\n\n    return fs_extra_1.default.readJSON(buildInfoPath);\n  }\n\n  async getArtifactPaths() {\n    const paths = await (0, glob_1.glob)(path.join(this._artifactsPath, \"**/*.json\"), {\n      ignore: [this._buildInfosGlob, this._dbgsGlob]\n    });\n    return paths.sort();\n  }\n\n  async getBuildInfoPaths() {\n    const paths = await (0, glob_1.glob)(this._buildInfosGlob);\n    return paths.sort();\n  }\n\n  async getDebugFilePaths() {\n    const paths = await (0, glob_1.glob)(this._dbgsGlob);\n    return paths.sort();\n  }\n\n  async saveArtifactAndDebugFile(artifact, pathToBuildInfo) {\n    // artifact\n    const fullyQualifiedName = (0, contract_names_1.getFullyQualifiedName)(artifact.sourceName, artifact.contractName);\n    const artifactPath = this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n    await fs_extra_1.default.ensureDir(path.dirname(artifactPath)); // write artifact\n\n    await fs_extra_1.default.writeJSON(artifactPath, artifact, {\n      spaces: 2\n    });\n\n    if (pathToBuildInfo === undefined) {\n      return;\n    } // save debug file\n\n\n    const debugFilePath = this._getDebugFilePath(artifactPath);\n\n    const debugFile = this._createDebugFile(artifactPath, pathToBuildInfo);\n\n    await fs_extra_1.default.writeJSON(debugFilePath, debugFile, {\n      spaces: 2\n    });\n  }\n\n  async saveBuildInfo(solcVersion, solcLongVersion, input, output) {\n    const buildInfoDir = path.join(this._artifactsPath, constants_1.BUILD_INFO_DIR_NAME);\n    await fs_extra_1.default.ensureDir(buildInfoDir);\n\n    const buildInfoName = this._getBuildInfoName(solcVersion, solcLongVersion, input);\n\n    const buildInfo = this._createBuildInfo(buildInfoName, solcVersion, solcLongVersion, input, output);\n\n    const buildInfoPath = path.join(buildInfoDir, `${buildInfoName}.json`);\n    await fs_extra_1.default.writeJson(buildInfoPath, buildInfo, {\n      spaces: 2\n    });\n    return buildInfoPath;\n  }\n  /**\n   * Remove all artifacts that don't correspond to the current solidity files\n   */\n\n\n  async removeObsoleteArtifacts() {\n    const validArtifactsPaths = new Set();\n\n    for (const {\n      sourceName,\n      artifacts\n    } of this._validArtifacts) {\n      for (const artifactName of artifacts) {\n        validArtifactsPaths.add(this._getArtifactPathSync((0, contract_names_1.getFullyQualifiedName)(sourceName, artifactName)));\n      }\n    }\n\n    const existingArtifactsPaths = await this.getArtifactPaths();\n\n    for (const artifactPath of existingArtifactsPaths) {\n      if (!validArtifactsPaths.has(artifactPath)) {\n        await this._removeArtifactFiles(artifactPath);\n      }\n    }\n\n    await this._removeObsoleteBuildInfos();\n  }\n  /**\n   * Returns the absolute path to the given artifact\n   */\n\n\n  formArtifactPathFromFullyQualifiedName(fullyQualifiedName) {\n    const {\n      sourceName,\n      contractName\n    } = (0, contract_names_1.parseFullyQualifiedName)(fullyQualifiedName);\n    return path.join(this._artifactsPath, sourceName, `${contractName}.json`);\n  }\n  /**\n   * Remove all build infos that aren't used by any debug file\n   */\n\n\n  async _removeObsoleteBuildInfos() {\n    const debugFiles = await this.getDebugFilePaths();\n    const validBuildInfos = new Set();\n\n    for (const debugFile of debugFiles) {\n      const buildInfoFile = await this._getBuildInfoFromDebugFile(debugFile);\n\n      if (buildInfoFile !== undefined) {\n        validBuildInfos.add(path.resolve(path.dirname(debugFile), buildInfoFile));\n      }\n    }\n\n    const buildInfoFiles = await this.getBuildInfoPaths();\n\n    for (const buildInfoFile of buildInfoFiles) {\n      if (!validBuildInfos.has(buildInfoFile)) {\n        log(`Removing buildInfo '${buildInfoFile}'`);\n        await fs_extra_1.default.unlink(buildInfoFile);\n      }\n    }\n  }\n\n  _getBuildInfoName(solcVersion, solcLongVersion, input) {\n    const json = JSON.stringify({\n      _format: constants_1.BUILD_INFO_FORMAT_VERSION,\n      solcVersion,\n      solcLongVersion,\n      input\n    });\n    return (0, hash_1.createNonCryptographicHashBasedIdentifier)(Buffer.from(json)).toString(\"hex\");\n  }\n  /**\n   * Returns the absolute path to the artifact that corresponds to the given\n   * name.\n   *\n   * If the name is fully qualified, the path is computed from it.  If not, an\n   * artifact that matches the given name is searched in the existing artifacts.\n   * If there is an ambiguity, an error is thrown.\n   */\n\n\n  async _getArtifactPath(name) {\n    if ((0, contract_names_1.isFullyQualifiedName)(name)) {\n      return this._getValidArtifactPathFromFullyQualifiedName(name);\n    }\n\n    const files = await this.getArtifactPaths();\n    return this._getArtifactPathFromFiles(name, files);\n  }\n\n  _createBuildInfo(id, solcVersion, solcLongVersion, input, output) {\n    return {\n      id,\n      _format: constants_1.BUILD_INFO_FORMAT_VERSION,\n      solcVersion,\n      solcLongVersion,\n      input,\n      output\n    };\n  }\n\n  _createDebugFile(artifactPath, pathToBuildInfo) {\n    const relativePathToBuildInfo = path.relative(path.dirname(artifactPath), pathToBuildInfo);\n    const debugFile = {\n      _format: constants_1.DEBUG_FILE_FORMAT_VERSION,\n      buildInfo: relativePathToBuildInfo\n    };\n    return debugFile;\n  }\n\n  _getArtifactPathsSync() {\n    const paths = (0, glob_1.globSync)(path.join(this._artifactsPath, \"**/*.json\"), {\n      ignore: [this._buildInfosGlob, this._dbgsGlob]\n    });\n    return paths.sort();\n  }\n  /**\n   * Sync version of _getArtifactPath\n   */\n\n\n  _getArtifactPathSync(name) {\n    if ((0, contract_names_1.isFullyQualifiedName)(name)) {\n      return this._getValidArtifactPathFromFullyQualifiedNameSync(name);\n    }\n\n    const files = this._getArtifactPathsSync();\n\n    return this._getArtifactPathFromFiles(name, files);\n  }\n  /**\n   * Same signature as imported function, but abstracted to handle the only error we consistently care about\n   */\n\n\n  async _trueCasePath(filePath, basePath) {\n    const {\n      trueCasePath\n    } = await Promise.resolve().then(() => __importStar(require(\"true-case-path\")));\n\n    try {\n      const result = await trueCasePath(filePath, basePath);\n      return result;\n    } catch (error) {\n      if (error instanceof Error) {\n        if (error.message.includes(\"no matching file exists\")) {\n          return null;\n        }\n      } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n      throw error;\n    }\n  }\n  /**\n   * Same signature as imported function, but abstracted to handle the only error we consistently care about\n   * and synchronous\n   */\n\n\n  _trueCasePathSync(filePath, basePath) {\n    const {\n      trueCasePathSync\n    } = require(\"true-case-path\");\n\n    try {\n      const result = trueCasePathSync(filePath, basePath);\n      return result;\n    } catch (error) {\n      if (error instanceof Error) {\n        if (error.message.includes(\"no matching file exists\")) {\n          return null;\n        }\n      } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n      throw error;\n    }\n  }\n  /**\n   * DO NOT DELETE OR CHANGE\n   *\n   * use this.formArtifactPathFromFullyQualifiedName instead\n   * @deprecated until typechain migrates to public version\n   * @see https://github.com/dethcrypto/TypeChain/issues/544\n   */\n\n\n  _getArtifactPathFromFullyQualifiedName(fullyQualifiedName) {\n    const {\n      sourceName,\n      contractName\n    } = (0, contract_names_1.parseFullyQualifiedName)(fullyQualifiedName);\n    return path.join(this._artifactsPath, sourceName, `${contractName}.json`);\n  }\n\n  async _getValidArtifactPathFromFullyQualifiedName(fullyQualifiedName) {\n    const artifactPath = this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n    const trueCaseArtifactPath = await this._trueCasePath(path.relative(this._artifactsPath, artifactPath), this._artifactsPath);\n\n    if (trueCaseArtifactPath === null) {\n      return this._handleWrongArtifactForFullyQualifiedName(fullyQualifiedName);\n    }\n\n    if (artifactPath !== trueCaseArtifactPath) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARTIFACTS.WRONG_CASING, {\n        correct: trueCaseArtifactPath,\n        incorrect: artifactPath\n      });\n    }\n\n    return artifactPath;\n  }\n\n  _getAllContractNamesFromFiles(files) {\n    return files.map(file => {\n      const fqn = this._getFullyQualifiedNameFromPath(file);\n\n      return (0, contract_names_1.parseFullyQualifiedName)(fqn).contractName;\n    });\n  }\n\n  _getAllFullyQualifiedNamesSync() {\n    const paths = this._getArtifactPathsSync();\n\n    return paths.map(p => this._getFullyQualifiedNameFromPath(p)).sort();\n  }\n\n  _formatSuggestions(names, contractName) {\n    switch (names.length) {\n      case 0:\n        return \"\";\n\n      case 1:\n        return `Did you mean \"${names[0]}\"?`;\n\n      default:\n        return `We found some that were similar:\n\n${names.map(n => `  * ${n}`).join(os.EOL)}\n\nPlease replace \"${contractName}\" for the correct contract name wherever you are trying to read its artifact.\n`;\n    }\n  }\n\n  _handleWrongArtifactForFullyQualifiedName(fullyQualifiedName) {\n    const names = this._getAllFullyQualifiedNamesSync();\n\n    const similarNames = this._getSimilarContractNames(fullyQualifiedName, names);\n\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.ARTIFACTS.NOT_FOUND, {\n      contractName: fullyQualifiedName,\n      suggestion: this._formatSuggestions(similarNames)\n    });\n  }\n\n  _handleWrongArtifactForContractName(contractName, files) {\n    const names = this._getAllContractNamesFromFiles(files);\n\n    let similarNames = this._getSimilarContractNames(contractName, names);\n\n    if (similarNames.length > 1) {\n      similarNames = this._filterDuplicatesAsFullyQualifiedNames(files, similarNames);\n    }\n\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.ARTIFACTS.NOT_FOUND, {\n      contractName,\n      suggestion: this._formatSuggestions(similarNames, contractName)\n    });\n  }\n  /**\n   * If the project has these contracts:\n   *   - 'contracts/Greeter.sol:Greeter'\n   *   - 'contracts/Meeter.sol:Greeter'\n   *   - 'contracts/Greater.sol:Greater'\n   *  And the user tries to get an artifact with the name 'Greter', then\n   *  the suggestions will be 'Greeter', 'Greeter', and 'Greater'.\n   *\n   * We don't want to show duplicates here, so we use FQNs for those. The\n   * suggestions will then be:\n   *   - 'contracts/Greeter.sol:Greeter'\n   *   - 'contracts/Meeter.sol:Greeter'\n   *   - 'Greater'\n   */\n\n\n  _filterDuplicatesAsFullyQualifiedNames(files, similarNames) {\n    const outputNames = [];\n    const groups = similarNames.reduce((obj, cur) => {\n      obj[cur] = obj[cur] ? obj[cur] + 1 : 1;\n      return obj;\n    }, {});\n\n    for (const [name, occurrences] of Object.entries(groups)) {\n      if (occurrences > 1) {\n        for (const file of files) {\n          if (path.basename(file) === `${name}.json`) {\n            outputNames.push(this._getFullyQualifiedNameFromPath(file));\n          }\n        }\n\n        continue;\n      }\n\n      outputNames.push(name);\n    }\n\n    return outputNames;\n  }\n  /**\n   *\n   * @param givenName can be FQN or contract name\n   * @param names MUST match type of givenName (i.e. array of FQN's if givenName is FQN)\n   * @returns\n   */\n\n\n  _getSimilarContractNames(givenName, names) {\n    let shortestDistance = constants_1.EDIT_DISTANCE_THRESHOLD;\n    let mostSimilarNames = [];\n\n    for (const name of names) {\n      const distance = (0, contract_names_1.findDistance)(givenName, name);\n\n      if (distance < shortestDistance) {\n        shortestDistance = distance;\n        mostSimilarNames = [name];\n        continue;\n      }\n\n      if (distance === shortestDistance) {\n        mostSimilarNames.push(name);\n        continue;\n      }\n    }\n\n    return mostSimilarNames;\n  }\n\n  _getValidArtifactPathFromFullyQualifiedNameSync(fullyQualifiedName) {\n    const artifactPath = this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n\n    const trueCaseArtifactPath = this._trueCasePathSync(path.relative(this._artifactsPath, artifactPath), this._artifactsPath);\n\n    if (trueCaseArtifactPath === null) {\n      return this._handleWrongArtifactForFullyQualifiedName(fullyQualifiedName);\n    }\n\n    if (artifactPath !== trueCaseArtifactPath) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARTIFACTS.WRONG_CASING, {\n        correct: trueCaseArtifactPath,\n        incorrect: artifactPath\n      });\n    }\n\n    return artifactPath;\n  }\n\n  _getDebugFilePath(artifactPath) {\n    return artifactPath.replace(/\\.json$/, \".dbg.json\");\n  }\n\n  _getArtifactPathFromFiles(contractName, files) {\n    const matchingFiles = files.filter(file => {\n      return path.basename(file) === `${contractName}.json`;\n    });\n\n    if (matchingFiles.length === 0) {\n      return this._handleWrongArtifactForContractName(contractName, files);\n    }\n\n    if (matchingFiles.length > 1) {\n      const candidates = matchingFiles.map(file => this._getFullyQualifiedNameFromPath(file));\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARTIFACTS.MULTIPLE_FOUND, {\n        contractName,\n        candidates: candidates.join(os.EOL)\n      });\n    }\n\n    return matchingFiles[0];\n  }\n  /**\n   * Returns the FQN of a contract giving the absolute path to its artifact.\n   *\n   * For example, given a path like\n   * `/path/to/project/artifacts/contracts/Foo.sol/Bar.json`, it'll return the\n   * FQN `contracts/Foo.sol:Bar`\n   */\n\n\n  _getFullyQualifiedNameFromPath(absolutePath) {\n    const sourceName = (0, source_names_1.replaceBackslashes)(path.relative(this._artifactsPath, path.dirname(absolutePath)));\n    const contractName = path.basename(absolutePath).replace(\".json\", \"\");\n    return (0, contract_names_1.getFullyQualifiedName)(sourceName, contractName);\n  }\n  /**\n   * Remove the artifact file, its debug file and, if it exists, its build\n   * info file.\n   */\n\n\n  async _removeArtifactFiles(artifactPath) {\n    await fs_extra_1.default.remove(artifactPath);\n\n    const debugFilePath = this._getDebugFilePath(artifactPath);\n\n    const buildInfoPath = await this._getBuildInfoFromDebugFile(debugFilePath);\n    await fs_extra_1.default.remove(debugFilePath);\n\n    if (buildInfoPath !== undefined) {\n      await fs_extra_1.default.remove(buildInfoPath);\n    }\n  }\n  /**\n   * Given the path to a debug file, returns the absolute path to its\n   * corresponding build info file if it exists, or undefined otherwise.\n   */\n\n\n  async _getBuildInfoFromDebugFile(debugFilePath) {\n    if (await fs_extra_1.default.pathExists(debugFilePath)) {\n      const {\n        buildInfo\n      } = await fs_extra_1.default.readJson(debugFilePath);\n      return path.resolve(path.dirname(debugFilePath), buildInfo);\n    }\n\n    return undefined;\n  }\n\n}\n\nexports.Artifacts = Artifacts;\n/**\n * Retrieves an artifact for the given `contractName` from the compilation output.\n *\n * @param sourceName The contract's source name.\n * @param contractName the contract's name.\n * @param contractOutput the contract's compilation output as emitted by `solc`.\n */\n\nfunction getArtifactFromContractOutput(sourceName, contractName, contractOutput) {\n  const evmBytecode = contractOutput.evm && contractOutput.evm.bytecode;\n  let bytecode = evmBytecode && evmBytecode.object ? evmBytecode.object : \"\";\n\n  if (bytecode.slice(0, 2).toLowerCase() !== \"0x\") {\n    bytecode = `0x${bytecode}`;\n  }\n\n  const evmDeployedBytecode = contractOutput.evm && contractOutput.evm.deployedBytecode;\n  let deployedBytecode = evmDeployedBytecode && evmDeployedBytecode.object ? evmDeployedBytecode.object : \"\";\n\n  if (deployedBytecode.slice(0, 2).toLowerCase() !== \"0x\") {\n    deployedBytecode = `0x${deployedBytecode}`;\n  }\n\n  const linkReferences = evmBytecode && evmBytecode.linkReferences ? evmBytecode.linkReferences : {};\n  const deployedLinkReferences = evmDeployedBytecode && evmDeployedBytecode.linkReferences ? evmDeployedBytecode.linkReferences : {};\n  return {\n    _format: constants_1.ARTIFACT_FORMAT_VERSION,\n    contractName,\n    sourceName,\n    abi: contractOutput.abi,\n    bytecode,\n    deployedBytecode,\n    linkReferences,\n    deployedLinkReferences\n  };\n}\n\nexports.getArtifactFromContractOutput = getArtifactFromContractOutput;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AACA;;AACA;;AAUA;;AAMA;;AAEA;;AAOA;;AACA;;AACA;;AACA;;AAEA,MAAMA,GAAG,GAAG,qBAAM,wBAAN,CAAZ;;AAEA,MAAaC,SAAb,CAAsB;AAKpBC,cAAoBC,cAApB,EAA0C;AAAtB;AAClB,SAAKC,eAAL,GAAuBC,IAAI,CAACC,IAAL,CACrB,KAAKH,cADgB,EAErBI,+BAFqB,EAGrB,WAHqB,CAAvB;AAKA,SAAKC,SAAL,GAAiBH,IAAI,CAACC,IAAL,CAAU,KAAKH,cAAf,EAA+B,eAA/B,CAAjB;AACA,SAAKM,eAAL,GAAuB,EAAvB;AACD;;AAEMC,mBAAiB,CACtBC,cADsB,EAC4C;AAElE,SAAKF,eAAL,CAAqBG,IAArB,CAA0B,GAAGD,cAA7B;AACD;;AAEwB,QAAZE,YAAY,CAACC,IAAD,EAAa;AACpC,UAAMC,YAAY,GAAG,MAAM,KAAKC,gBAAL,CAAsBF,IAAtB,CAA3B;AACA,WAAOG,mBAAQC,QAAR,CAAiBH,YAAjB,CAAP;AACD;;AAEMI,kBAAgB,CAACL,IAAD,EAAa;AAClC,UAAMC,YAAY,GAAG,KAAKK,oBAAL,CAA0BN,IAA1B,CAArB;;AACA,WAAOG,mBAAQI,YAAR,CAAqBN,YAArB,CAAP;AACD;;AAE0B,QAAdO,cAAc,CAACR,IAAD,EAAa;AACtC,QAAI;AACF,YAAM,KAAKD,YAAL,CAAkBC,IAAlB,CAAN;AACA,aAAO,IAAP;AACD,KAHD,CAGE,WAAM;AACN,aAAO,KAAP;AACD;AACF;;AAEqC,QAAzBS,yBAAyB;AACpC,UAAMC,KAAK,GAAG,MAAM,KAAKC,gBAAL,EAApB;AACA,WAAOD,KAAK,CAACE,GAAN,CAAWC,CAAD,IAAO,KAAKC,8BAAL,CAAoCD,CAApC,CAAjB,EAAyDE,IAAzD,EAAP;AACD;;AAEwB,QAAZC,YAAY,CACvBC,kBADuB,EACG;AAE1B,UAAMhB,YAAY,GAChB,KAAKiB,sCAAL,CAA4CD,kBAA5C,CADF;;AAGA,UAAME,aAAa,GAAG,KAAKC,iBAAL,CAAuBnB,YAAvB,CAAtB;;AACA,UAAMoB,aAAa,GAAG,MAAM,KAAKC,0BAAL,CAAgCH,aAAhC,CAA5B;;AAEA,QAAIE,aAAa,KAAKE,SAAtB,EAAiC;AAC/B,aAAOA,SAAP;AACD;;AAED,WAAOpB,mBAAQqB,QAAR,CAAiBH,aAAjB,CAAP;AACD;;AAE4B,QAAhBV,gBAAgB;AAC3B,UAAMD,KAAK,GAAG,MAAM,iBAAKnB,IAAI,CAACC,IAAL,CAAU,KAAKH,cAAf,EAA+B,WAA/B,CAAL,EAAkD;AACpEoC,YAAM,EAAE,CAAC,KAAKnC,eAAN,EAAuB,KAAKI,SAA5B;AAD4D,KAAlD,CAApB;AAIA,WAAOgB,KAAK,CAACK,IAAN,EAAP;AACD;;AAE6B,QAAjBW,iBAAiB;AAC5B,UAAMhB,KAAK,GAAG,MAAM,iBAAK,KAAKpB,eAAV,CAApB;AAEA,WAAOoB,KAAK,CAACK,IAAN,EAAP;AACD;;AAE6B,QAAjBY,iBAAiB;AAC5B,UAAMjB,KAAK,GAAG,MAAM,iBAAK,KAAKhB,SAAV,CAApB;AAEA,WAAOgB,KAAK,CAACK,IAAN,EAAP;AACD;;AAEoC,QAAxBa,wBAAwB,CACnCC,QADmC,EAEnCC,eAFmC,EAEX;AAExB;AACA,UAAMb,kBAAkB,GAAG,4CACzBY,QAAQ,CAACE,UADgB,EAEzBF,QAAQ,CAACG,YAFgB,CAA3B;AAKA,UAAM/B,YAAY,GAChB,KAAKiB,sCAAL,CAA4CD,kBAA5C,CADF;AAGA,UAAMd,mBAAQ8B,SAAR,CAAkB1C,IAAI,CAAC2C,OAAL,CAAajC,YAAb,CAAlB,CAAN,CAXwB,CAaxB;;AACA,UAAME,mBAAQgC,SAAR,CAAkBlC,YAAlB,EAAgC4B,QAAhC,EAA0C;AAC9CO,YAAM,EAAE;AADsC,KAA1C,CAAN;;AAIA,QAAIN,eAAe,KAAKP,SAAxB,EAAmC;AACjC;AACD,KApBuB,CAsBxB;;;AACA,UAAMJ,aAAa,GAAG,KAAKC,iBAAL,CAAuBnB,YAAvB,CAAtB;;AACA,UAAMoC,SAAS,GAAG,KAAKC,gBAAL,CAAsBrC,YAAtB,EAAoC6B,eAApC,CAAlB;;AAEA,UAAM3B,mBAAQgC,SAAR,CAAkBhB,aAAlB,EAAiCkB,SAAjC,EAA4C;AAChDD,YAAM,EAAE;AADwC,KAA5C,CAAN;AAGD;;AAEyB,QAAbG,aAAa,CACxBC,WADwB,EAExBC,eAFwB,EAGxBC,KAHwB,EAIxBC,MAJwB,EAIF;AAEtB,UAAMC,YAAY,GAAGrD,IAAI,CAACC,IAAL,CAAU,KAAKH,cAAf,EAA+BI,+BAA/B,CAArB;AACA,UAAMU,mBAAQ8B,SAAR,CAAkBW,YAAlB,CAAN;;AAEA,UAAMC,aAAa,GAAG,KAAKC,iBAAL,CACpBN,WADoB,EAEpBC,eAFoB,EAGpBC,KAHoB,CAAtB;;AAMA,UAAMK,SAAS,GAAG,KAAKC,gBAAL,CAChBH,aADgB,EAEhBL,WAFgB,EAGhBC,eAHgB,EAIhBC,KAJgB,EAKhBC,MALgB,CAAlB;;AAQA,UAAMtB,aAAa,GAAG9B,IAAI,CAACC,IAAL,CAAUoD,YAAV,EAAwB,GAAGC,aAAa,OAAxC,CAAtB;AACA,UAAM1C,mBAAQ8C,SAAR,CAAkB5B,aAAlB,EAAiC0B,SAAjC,EAA4C;AAAEX,YAAM,EAAE;AAAV,KAA5C,CAAN;AAEA,WAAOf,aAAP;AACD;AAED;;;;;AAGoC,QAAvB6B,uBAAuB;AAClC,UAAMC,mBAAmB,GAAG,IAAIC,GAAJ,EAA5B;;AAEA,SAAK,MAAM;AAAErB,gBAAF;AAAcsB;AAAd,KAAX,IAAwC,KAAK1D,eAA7C,EAA8D;AAC5D,WAAK,MAAM2D,YAAX,IAA2BD,SAA3B,EAAsC;AACpCF,2BAAmB,CAACI,GAApB,CACE,KAAKjD,oBAAL,CACE,4CAAsByB,UAAtB,EAAkCuB,YAAlC,CADF,CADF;AAKD;AACF;;AAED,UAAME,sBAAsB,GAAG,MAAM,KAAK7C,gBAAL,EAArC;;AAEA,SAAK,MAAMV,YAAX,IAA2BuD,sBAA3B,EAAmD;AACjD,UAAI,CAACL,mBAAmB,CAACM,GAApB,CAAwBxD,YAAxB,CAAL,EAA4C;AAC1C,cAAM,KAAKyD,oBAAL,CAA0BzD,YAA1B,CAAN;AACD;AACF;;AAED,UAAM,KAAK0D,yBAAL,EAAN;AACD;AAED;;;;;AAGOzC,wCAAsC,CAC3CD,kBAD2C,EACjB;AAE1B,UAAM;AAAEc,gBAAF;AAAcC;AAAd,QACJ,8CAAwBf,kBAAxB,CADF;AAGA,WAAO1B,IAAI,CAACC,IAAL,CAAU,KAAKH,cAAf,EAA+B0C,UAA/B,EAA2C,GAAGC,YAAY,OAA1D,CAAP;AACD;AAED;;;;;AAGuC,QAAzB2B,yBAAyB;AACrC,UAAMC,UAAU,GAAG,MAAM,KAAKjC,iBAAL,EAAzB;AAEA,UAAMkC,eAAe,GAAG,IAAIT,GAAJ,EAAxB;;AACA,SAAK,MAAMf,SAAX,IAAwBuB,UAAxB,EAAoC;AAClC,YAAME,aAAa,GAAG,MAAM,KAAKxC,0BAAL,CAAgCe,SAAhC,CAA5B;;AACA,UAAIyB,aAAa,KAAKvC,SAAtB,EAAiC;AAC/BsC,uBAAe,CAACN,GAAhB,CACEhE,IAAI,CAACwE,OAAL,CAAaxE,IAAI,CAAC2C,OAAL,CAAaG,SAAb,CAAb,EAAsCyB,aAAtC,CADF;AAGD;AACF;;AAED,UAAME,cAAc,GAAG,MAAM,KAAKtC,iBAAL,EAA7B;;AAEA,SAAK,MAAMoC,aAAX,IAA4BE,cAA5B,EAA4C;AAC1C,UAAI,CAACH,eAAe,CAACJ,GAAhB,CAAoBK,aAApB,CAAL,EAAyC;AACvC5E,WAAG,CAAC,uBAAuB4E,aAAa,GAArC,CAAH;AACA,cAAM3D,mBAAQ8D,MAAR,CAAeH,aAAf,CAAN;AACD;AACF;AACF;;AAEOhB,mBAAiB,CACvBN,WADuB,EAEvBC,eAFuB,EAGvBC,KAHuB,EAGH;AAEpB,UAAMwB,IAAI,GAAGC,IAAI,CAACC,SAAL,CAAe;AAC1BC,aAAO,EAAE5E,qCADiB;AAE1B+C,iBAF0B;AAG1BC,qBAH0B;AAI1BC;AAJ0B,KAAf,CAAb;AAOA,WAAO,sDACL4B,MAAM,CAACC,IAAP,CAAYL,IAAZ,CADK,EAELM,QAFK,CAEI,KAFJ,CAAP;AAGD;AAED;;;;;;;;;;AAQ8B,QAAhBtE,gBAAgB,CAACF,IAAD,EAAa;AACzC,QAAI,2CAAqBA,IAArB,CAAJ,EAAgC;AAC9B,aAAO,KAAKyE,2CAAL,CAAiDzE,IAAjD,CAAP;AACD;;AAED,UAAM0E,KAAK,GAAG,MAAM,KAAK/D,gBAAL,EAApB;AACA,WAAO,KAAKgE,yBAAL,CAA+B3E,IAA/B,EAAqC0E,KAArC,CAAP;AACD;;AAEO1B,kBAAgB,CACtB4B,EADsB,EAEtBpC,WAFsB,EAGtBC,eAHsB,EAItBC,KAJsB,EAKtBC,MALsB,EAKA;AAEtB,WAAO;AACLiC,QADK;AAELP,aAAO,EAAE5E,qCAFJ;AAGL+C,iBAHK;AAILC,qBAJK;AAKLC,WALK;AAMLC;AANK,KAAP;AAQD;;AAEOL,kBAAgB,CAACrC,YAAD,EAAuB6B,eAAvB,EAA8C;AACpE,UAAM+C,uBAAuB,GAAGtF,IAAI,CAACuF,QAAL,CAC9BvF,IAAI,CAAC2C,OAAL,CAAajC,YAAb,CAD8B,EAE9B6B,eAF8B,CAAhC;AAKA,UAAMO,SAAS,GAAc;AAC3BgC,aAAO,EAAE5E,qCADkB;AAE3BsD,eAAS,EAAE8B;AAFgB,KAA7B;AAKA,WAAOxC,SAAP;AACD;;AAEO0C,uBAAqB;AAC3B,UAAMrE,KAAK,GAAG,qBAASnB,IAAI,CAACC,IAAL,CAAU,KAAKH,cAAf,EAA+B,WAA/B,CAAT,EAAsD;AAClEoC,YAAM,EAAE,CAAC,KAAKnC,eAAN,EAAuB,KAAKI,SAA5B;AAD0D,KAAtD,CAAd;AAIA,WAAOgB,KAAK,CAACK,IAAN,EAAP;AACD;AAED;;;;;AAGQT,sBAAoB,CAACN,IAAD,EAAa;AACvC,QAAI,2CAAqBA,IAArB,CAAJ,EAAgC;AAC9B,aAAO,KAAKgF,+CAAL,CAAqDhF,IAArD,CAAP;AACD;;AAED,UAAM0E,KAAK,GAAG,KAAKK,qBAAL,EAAd;;AACA,WAAO,KAAKJ,yBAAL,CAA+B3E,IAA/B,EAAqC0E,KAArC,CAAP;AACD;AAED;;;;;AAG2B,QAAbO,aAAa,CACzBC,QADyB,EAEzBC,QAFyB,EAER;AAEjB,UAAM;AAAEC;AAAF,QAAmB,wDAAa,gBAAb,GAAzB;;AAEA,QAAI;AACF,YAAMC,MAAM,GAAG,MAAMD,YAAY,CAACF,QAAD,EAAWC,QAAX,CAAjC;AACA,aAAOE,MAAP;AACD,KAHD,CAGE,OAAOC,KAAP,EAAc;AACd,UAAIA,KAAK,YAAYC,KAArB,EAA4B;AAC1B,YAAID,KAAK,CAACE,OAAN,CAAcC,QAAd,CAAuB,yBAAvB,CAAJ,EAAuD;AACrD,iBAAO,IAAP;AACD;AACF,OALa,CAOd;;;AACA,YAAMH,KAAN;AACD;AACF;AAED;;;;;;AAIQI,mBAAiB,CACvBR,QADuB,EAEvBC,QAFuB,EAEN;AAEjB,UAAM;AAAEQ;AAAF,QAAuBC,OAAO,CAAC,gBAAD,CAApC;;AAEA,QAAI;AACF,YAAMP,MAAM,GAAGM,gBAAgB,CAACT,QAAD,EAAWC,QAAX,CAA/B;AACA,aAAOE,MAAP;AACD,KAHD,CAGE,OAAOC,KAAP,EAAc;AACd,UAAIA,KAAK,YAAYC,KAArB,EAA4B;AAC1B,YAAID,KAAK,CAACE,OAAN,CAAcC,QAAd,CAAuB,yBAAvB,CAAJ,EAAuD;AACrD,iBAAO,IAAP;AACD;AACF,OALa,CAOd;;;AACA,YAAMH,KAAN;AACD;AACF;AAED;;;;;;;;;AAOQO,wCAAsC,CAC5C5E,kBAD4C,EAClB;AAE1B,UAAM;AAAEc,gBAAF;AAAcC;AAAd,QACJ,8CAAwBf,kBAAxB,CADF;AAGA,WAAO1B,IAAI,CAACC,IAAL,CAAU,KAAKH,cAAf,EAA+B0C,UAA/B,EAA2C,GAAGC,YAAY,OAA1D,CAAP;AACD;;AAEwD,QAA3CyC,2CAA2C,CACvDxD,kBADuD,EAC7B;AAE1B,UAAMhB,YAAY,GAChB,KAAKiB,sCAAL,CAA4CD,kBAA5C,CADF;AAGA,UAAM6E,oBAAoB,GAAG,MAAM,KAAKb,aAAL,CACjC1F,IAAI,CAACuF,QAAL,CAAc,KAAKzF,cAAnB,EAAmCY,YAAnC,CADiC,EAEjC,KAAKZ,cAF4B,CAAnC;;AAKA,QAAIyG,oBAAoB,KAAK,IAA7B,EAAmC;AACjC,aAAO,KAAKC,yCAAL,CAA+C9E,kBAA/C,CAAP;AACD;;AAED,QAAIhB,YAAY,KAAK6F,oBAArB,EAA2C;AACzC,YAAM,IAAIE,qBAAJ,CAAiBC,qBAAOC,SAAP,CAAiBC,YAAlC,EAAgD;AACpDC,eAAO,EAAEN,oBAD2C;AAEpDO,iBAAS,EAAEpG;AAFyC,OAAhD,CAAN;AAID;;AAED,WAAOA,YAAP;AACD;;AAEOqG,+BAA6B,CAAC5B,KAAD,EAAgB;AACnD,WAAOA,KAAK,CAAC9D,GAAN,CAAW2F,IAAD,IAAS;AACxB,YAAMC,GAAG,GAAG,KAAK1F,8BAAL,CAAoCyF,IAApC,CAAZ;;AACA,aAAO,8CAAwBC,GAAxB,EAA6BxE,YAApC;AACD,KAHM,CAAP;AAID;;AAEOyE,gCAA8B;AACpC,UAAM/F,KAAK,GAAG,KAAKqE,qBAAL,EAAd;;AACA,WAAOrE,KAAK,CAACE,GAAN,CAAWC,CAAD,IAAO,KAAKC,8BAAL,CAAoCD,CAApC,CAAjB,EAAyDE,IAAzD,EAAP;AACD;;AAEO2F,oBAAkB,CAACC,KAAD,EAAkB3E,YAAlB,EAAuC;AAC/D,YAAQ2E,KAAK,CAACC,MAAd;AACE,WAAK,CAAL;AACE,eAAO,EAAP;;AACF,WAAK,CAAL;AACE,eAAO,iBAAiBD,KAAK,CAAC,CAAD,CAAG,IAAhC;;AACF;AACE,eAAO;;EAEbA,KAAK,CAAC/F,GAAN,CAAWiG,CAAD,IAAO,OAAOA,CAAC,EAAzB,EAA6BrH,IAA7B,CAAkCsH,EAAE,CAACC,GAArC,CAAyC;;kBAEzB/E,YAAY;CAJtB;AANJ;AAaD;;AAEO+D,2CAAyC,CAC/C9E,kBAD+C,EACrB;AAE1B,UAAM0F,KAAK,GAAG,KAAKF,8BAAL,EAAd;;AAEA,UAAMO,YAAY,GAAG,KAAKC,wBAAL,CACnBhG,kBADmB,EAEnB0F,KAFmB,CAArB;;AAKA,UAAM,IAAIX,qBAAJ,CAAiBC,qBAAOC,SAAP,CAAiBgB,SAAlC,EAA6C;AACjDlF,kBAAY,EAAEf,kBADmC;AAEjDkG,gBAAU,EAAE,KAAKT,kBAAL,CAAwBM,YAAxB;AAFqC,KAA7C,CAAN;AAID;;AAEOI,qCAAmC,CACzCpF,YADyC,EAEzC0C,KAFyC,EAE1B;AAEf,UAAMiC,KAAK,GAAG,KAAKL,6BAAL,CAAmC5B,KAAnC,CAAd;;AAEA,QAAIsC,YAAY,GAAG,KAAKC,wBAAL,CAA8BjF,YAA9B,EAA4C2E,KAA5C,CAAnB;;AAEA,QAAIK,YAAY,CAACJ,MAAb,GAAsB,CAA1B,EAA6B;AAC3BI,kBAAY,GAAG,KAAKK,sCAAL,CACb3C,KADa,EAEbsC,YAFa,CAAf;AAID;;AAED,UAAM,IAAIhB,qBAAJ,CAAiBC,qBAAOC,SAAP,CAAiBgB,SAAlC,EAA6C;AACjDlF,kBADiD;AAEjDmF,gBAAU,EAAE,KAAKT,kBAAL,CAAwBM,YAAxB,EAAsChF,YAAtC;AAFqC,KAA7C,CAAN;AAID;AAED;;;;;;;;;;;;;;;;AAcQqF,wCAAsC,CAC5C3C,KAD4C,EAE5CsC,YAF4C,EAEtB;AAEtB,UAAMM,WAAW,GAAG,EAApB;AACA,UAAMC,MAAM,GAAGP,YAAY,CAACQ,MAAb,CAAoB,CAACC,GAAD,EAAMC,GAAN,KAAa;AAC9CD,SAAG,CAACC,GAAD,CAAH,GAAWD,GAAG,CAACC,GAAD,CAAH,GAAWD,GAAG,CAACC,GAAD,CAAH,GAAW,CAAtB,GAA0B,CAArC;AACA,aAAOD,GAAP;AACD,KAHc,EAGZ,EAHY,CAAf;;AAKA,SAAK,MAAM,CAACzH,IAAD,EAAO2H,WAAP,CAAX,IAAkCC,MAAM,CAACC,OAAP,CAAeN,MAAf,CAAlC,EAA0D;AACxD,UAAII,WAAW,GAAG,CAAlB,EAAqB;AACnB,aAAK,MAAMpB,IAAX,IAAmB7B,KAAnB,EAA0B;AACxB,cAAInF,IAAI,CAACuI,QAAL,CAAcvB,IAAd,MAAwB,GAAGvG,IAAI,OAAnC,EAA4C;AAC1CsH,uBAAW,CAACxH,IAAZ,CAAiB,KAAKgB,8BAAL,CAAoCyF,IAApC,CAAjB;AACD;AACF;;AACD;AACD;;AAEDe,iBAAW,CAACxH,IAAZ,CAAiBE,IAAjB;AACD;;AAED,WAAOsH,WAAP;AACD;AAED;;;;;;;;AAMQL,0BAAwB,CAC9Bc,SAD8B,EAE9BpB,KAF8B,EAEf;AAEf,QAAIqB,gBAAgB,GAAGvI,mCAAvB;AACA,QAAIwI,gBAAgB,GAAa,EAAjC;;AACA,SAAK,MAAMjI,IAAX,IAAmB2G,KAAnB,EAA0B;AACxB,YAAMuB,QAAQ,GAAG,mCAAaH,SAAb,EAAwB/H,IAAxB,CAAjB;;AAEA,UAAIkI,QAAQ,GAAGF,gBAAf,EAAiC;AAC/BA,wBAAgB,GAAGE,QAAnB;AACAD,wBAAgB,GAAG,CAACjI,IAAD,CAAnB;AACA;AACD;;AAED,UAAIkI,QAAQ,KAAKF,gBAAjB,EAAmC;AACjCC,wBAAgB,CAACnI,IAAjB,CAAsBE,IAAtB;AACA;AACD;AACF;;AAED,WAAOiI,gBAAP;AACD;;AAEOjD,iDAA+C,CACrD/D,kBADqD,EAC3B;AAE1B,UAAMhB,YAAY,GAChB,KAAKiB,sCAAL,CAA4CD,kBAA5C,CADF;;AAGA,UAAM6E,oBAAoB,GAAG,KAAKJ,iBAAL,CAC3BnG,IAAI,CAACuF,QAAL,CAAc,KAAKzF,cAAnB,EAAmCY,YAAnC,CAD2B,EAE3B,KAAKZ,cAFsB,CAA7B;;AAKA,QAAIyG,oBAAoB,KAAK,IAA7B,EAAmC;AACjC,aAAO,KAAKC,yCAAL,CAA+C9E,kBAA/C,CAAP;AACD;;AAED,QAAIhB,YAAY,KAAK6F,oBAArB,EAA2C;AACzC,YAAM,IAAIE,qBAAJ,CAAiBC,qBAAOC,SAAP,CAAiBC,YAAlC,EAAgD;AACpDC,eAAO,EAAEN,oBAD2C;AAEpDO,iBAAS,EAAEpG;AAFyC,OAAhD,CAAN;AAID;;AAED,WAAOA,YAAP;AACD;;AAEOmB,mBAAiB,CAACnB,YAAD,EAAqB;AAC5C,WAAOA,YAAY,CAACkI,OAAb,CAAqB,SAArB,EAAgC,WAAhC,CAAP;AACD;;AAEOxD,2BAAyB,CAC/B3C,YAD+B,EAE/B0C,KAF+B,EAEhB;AAEf,UAAM0D,aAAa,GAAG1D,KAAK,CAAC2D,MAAN,CAAc9B,IAAD,IAAS;AAC1C,aAAOhH,IAAI,CAACuI,QAAL,CAAcvB,IAAd,MAAwB,GAAGvE,YAAY,OAA9C;AACD,KAFqB,CAAtB;;AAIA,QAAIoG,aAAa,CAACxB,MAAd,KAAyB,CAA7B,EAAgC;AAC9B,aAAO,KAAKQ,mCAAL,CAAyCpF,YAAzC,EAAuD0C,KAAvD,CAAP;AACD;;AAED,QAAI0D,aAAa,CAACxB,MAAd,GAAuB,CAA3B,EAA8B;AAC5B,YAAM0B,UAAU,GAAGF,aAAa,CAACxH,GAAd,CAAmB2F,IAAD,IACnC,KAAKzF,8BAAL,CAAoCyF,IAApC,CADiB,CAAnB;AAIA,YAAM,IAAIP,qBAAJ,CAAiBC,qBAAOC,SAAP,CAAiBqC,cAAlC,EAAkD;AACtDvG,oBADsD;AAEtDsG,kBAAU,EAAEA,UAAU,CAAC9I,IAAX,CAAgBsH,EAAE,CAACC,GAAnB;AAF0C,OAAlD,CAAN;AAID;;AAED,WAAOqB,aAAa,CAAC,CAAD,CAApB;AACD;AAED;;;;;;;;;AAOQtH,gCAA8B,CAAC0H,YAAD,EAAqB;AACzD,UAAMzG,UAAU,GAAG,uCACjBxC,IAAI,CAACuF,QAAL,CAAc,KAAKzF,cAAnB,EAAmCE,IAAI,CAAC2C,OAAL,CAAasG,YAAb,CAAnC,CADiB,CAAnB;AAIA,UAAMxG,YAAY,GAAGzC,IAAI,CAACuI,QAAL,CAAcU,YAAd,EAA4BL,OAA5B,CAAoC,OAApC,EAA6C,EAA7C,CAArB;AAEA,WAAO,4CAAsBpG,UAAtB,EAAkCC,YAAlC,CAAP;AACD;AAED;;;;;;AAIkC,QAApB0B,oBAAoB,CAACzD,YAAD,EAAqB;AACrD,UAAME,mBAAQsI,MAAR,CAAexI,YAAf,CAAN;;AAEA,UAAMkB,aAAa,GAAG,KAAKC,iBAAL,CAAuBnB,YAAvB,CAAtB;;AACA,UAAMoB,aAAa,GAAG,MAAM,KAAKC,0BAAL,CAAgCH,aAAhC,CAA5B;AAEA,UAAMhB,mBAAQsI,MAAR,CAAetH,aAAf,CAAN;;AAEA,QAAIE,aAAa,KAAKE,SAAtB,EAAiC;AAC/B,YAAMpB,mBAAQsI,MAAR,CAAepH,aAAf,CAAN;AACD;AACF;AAED;;;;;;AAIwC,QAA1BC,0BAA0B,CACtCH,aADsC,EACjB;AAErB,QAAI,MAAMhB,mBAAQuI,UAAR,CAAmBvH,aAAnB,CAAV,EAA6C;AAC3C,YAAM;AAAE4B;AAAF,UAAgB,MAAM5C,mBAAQC,QAAR,CAAiBe,aAAjB,CAA5B;AACA,aAAO5B,IAAI,CAACwE,OAAL,CAAaxE,IAAI,CAAC2C,OAAL,CAAaf,aAAb,CAAb,EAA0C4B,SAA1C,CAAP;AACD;;AAED,WAAOxB,SAAP;AACD;;AA5mBmB;;AAAtBoH;AA+mBA;;;;;;;;AAOA,SAAgBC,6BAAhB,CACE7G,UADF,EAEEC,YAFF,EAGE6G,cAHF,EAGqB;AAEnB,QAAMC,WAAW,GAAGD,cAAc,CAACE,GAAf,IAAsBF,cAAc,CAACE,GAAf,CAAmBC,QAA7D;AACA,MAAIA,QAAQ,GACVF,WAAW,IAAIA,WAAW,CAACG,MAA3B,GAAoCH,WAAW,CAACG,MAAhD,GAAyD,EAD3D;;AAGA,MAAID,QAAQ,CAACE,KAAT,CAAe,CAAf,EAAkB,CAAlB,EAAqBC,WAArB,OAAuC,IAA3C,EAAiD;AAC/CH,YAAQ,GAAG,KAAKA,QAAQ,EAAxB;AACD;;AAED,QAAMI,mBAAmB,GACvBP,cAAc,CAACE,GAAf,IAAsBF,cAAc,CAACE,GAAf,CAAmBM,gBAD3C;AAEA,MAAIA,gBAAgB,GAClBD,mBAAmB,IAAIA,mBAAmB,CAACH,MAA3C,GACIG,mBAAmB,CAACH,MADxB,GAEI,EAHN;;AAKA,MAAII,gBAAgB,CAACH,KAAjB,CAAuB,CAAvB,EAA0B,CAA1B,EAA6BC,WAA7B,OAA+C,IAAnD,EAAyD;AACvDE,oBAAgB,GAAG,KAAKA,gBAAgB,EAAxC;AACD;;AAED,QAAMC,cAAc,GAClBR,WAAW,IAAIA,WAAW,CAACQ,cAA3B,GAA4CR,WAAW,CAACQ,cAAxD,GAAyE,EAD3E;AAEA,QAAMC,sBAAsB,GAC1BH,mBAAmB,IAAIA,mBAAmB,CAACE,cAA3C,GACIF,mBAAmB,CAACE,cADxB,GAEI,EAHN;AAKA,SAAO;AACLjF,WAAO,EAAE5E,mCADJ;AAELuC,gBAFK;AAGLD,cAHK;AAILyH,OAAG,EAAEX,cAAc,CAACW,GAJf;AAKLR,YALK;AAMLK,oBANK;AAOLC,kBAPK;AAQLC;AARK,GAAP;AAUD;;AAzCDZ","names":["log","Artifacts","constructor","_artifactsPath","_buildInfosGlob","path","join","constants_1","_dbgsGlob","_validArtifacts","addValidArtifacts","validArtifacts","push","readArtifact","name","artifactPath","_getArtifactPath","fs_extra_1","readJson","readArtifactSync","_getArtifactPathSync","readJsonSync","artifactExists","getAllFullyQualifiedNames","paths","getArtifactPaths","map","p","_getFullyQualifiedNameFromPath","sort","getBuildInfo","fullyQualifiedName","formArtifactPathFromFullyQualifiedName","debugFilePath","_getDebugFilePath","buildInfoPath","_getBuildInfoFromDebugFile","undefined","readJSON","ignore","getBuildInfoPaths","getDebugFilePaths","saveArtifactAndDebugFile","artifact","pathToBuildInfo","sourceName","contractName","ensureDir","dirname","writeJSON","spaces","debugFile","_createDebugFile","saveBuildInfo","solcVersion","solcLongVersion","input","output","buildInfoDir","buildInfoName","_getBuildInfoName","buildInfo","_createBuildInfo","writeJson","removeObsoleteArtifacts","validArtifactsPaths","Set","artifacts","artifactName","add","existingArtifactsPaths","has","_removeArtifactFiles","_removeObsoleteBuildInfos","debugFiles","validBuildInfos","buildInfoFile","resolve","buildInfoFiles","unlink","json","JSON","stringify","_format","Buffer","from","toString","_getValidArtifactPathFromFullyQualifiedName","files","_getArtifactPathFromFiles","id","relativePathToBuildInfo","relative","_getArtifactPathsSync","_getValidArtifactPathFromFullyQualifiedNameSync","_trueCasePath","filePath","basePath","trueCasePath","result","error","Error","message","includes","_trueCasePathSync","trueCasePathSync","require","_getArtifactPathFromFullyQualifiedName","trueCaseArtifactPath","_handleWrongArtifactForFullyQualifiedName","errors_1","errors_list_1","ARTIFACTS","WRONG_CASING","correct","incorrect","_getAllContractNamesFromFiles","file","fqn","_getAllFullyQualifiedNamesSync","_formatSuggestions","names","length","n","os","EOL","similarNames","_getSimilarContractNames","NOT_FOUND","suggestion","_handleWrongArtifactForContractName","_filterDuplicatesAsFullyQualifiedNames","outputNames","groups","reduce","obj","cur","occurrences","Object","entries","basename","givenName","shortestDistance","mostSimilarNames","distance","replace","matchingFiles","filter","candidates","MULTIPLE_FOUND","absolutePath","remove","pathExists","exports","getArtifactFromContractOutput","contractOutput","evmBytecode","evm","bytecode","object","slice","toLowerCase","evmDeployedBytecode","deployedBytecode","linkReferences","deployedLinkReferences","abi"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/internal/artifacts.ts"],"sourcesContent":["import debug from \"debug\";\nimport fsExtra from \"fs-extra\";\nimport * as os from \"os\";\nimport * as path from \"path\";\n\nimport {\n  Artifact,\n  Artifacts as IArtifacts,\n  BuildInfo,\n  CompilerInput,\n  CompilerOutput,\n  DebugFile,\n} from \"../types\";\nimport {\n  getFullyQualifiedName,\n  isFullyQualifiedName,\n  parseFullyQualifiedName,\n  findDistance,\n} from \"../utils/contract-names\";\nimport { replaceBackslashes } from \"../utils/source-names\";\n\nimport {\n  ARTIFACT_FORMAT_VERSION,\n  BUILD_INFO_DIR_NAME,\n  BUILD_INFO_FORMAT_VERSION,\n  DEBUG_FILE_FORMAT_VERSION,\n  EDIT_DISTANCE_THRESHOLD,\n} from \"./constants\";\nimport { HardhatError } from \"./core/errors\";\nimport { ERRORS } from \"./core/errors-list\";\nimport { glob, globSync } from \"./util/glob\";\nimport { createNonCryptographicHashBasedIdentifier } from \"./util/hash\";\n\nconst log = debug(\"hardhat:core:artifacts\");\n\nexport class Artifacts implements IArtifacts {\n  private _buildInfosGlob: string;\n  private _dbgsGlob: string;\n  private _validArtifacts: Array<{ sourceName: string; artifacts: string[] }>;\n\n  constructor(private _artifactsPath: string) {\n    this._buildInfosGlob = path.join(\n      this._artifactsPath,\n      BUILD_INFO_DIR_NAME,\n      \"**/*.json\"\n    );\n    this._dbgsGlob = path.join(this._artifactsPath, \"**/*.dbg.json\");\n    this._validArtifacts = [];\n  }\n\n  public addValidArtifacts(\n    validArtifacts: Array<{ sourceName: string; artifacts: string[] }>\n  ) {\n    this._validArtifacts.push(...validArtifacts);\n  }\n\n  public async readArtifact(name: string): Promise<Artifact> {\n    const artifactPath = await this._getArtifactPath(name);\n    return fsExtra.readJson(artifactPath);\n  }\n\n  public readArtifactSync(name: string): Artifact {\n    const artifactPath = this._getArtifactPathSync(name);\n    return fsExtra.readJsonSync(artifactPath);\n  }\n\n  public async artifactExists(name: string): Promise<boolean> {\n    try {\n      await this.readArtifact(name);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  public async getAllFullyQualifiedNames(): Promise<string[]> {\n    const paths = await this.getArtifactPaths();\n    return paths.map((p) => this._getFullyQualifiedNameFromPath(p)).sort();\n  }\n\n  public async getBuildInfo(\n    fullyQualifiedName: string\n  ): Promise<BuildInfo | undefined> {\n    const artifactPath =\n      this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n\n    const debugFilePath = this._getDebugFilePath(artifactPath);\n    const buildInfoPath = await this._getBuildInfoFromDebugFile(debugFilePath);\n\n    if (buildInfoPath === undefined) {\n      return undefined;\n    }\n\n    return fsExtra.readJSON(buildInfoPath);\n  }\n\n  public async getArtifactPaths(): Promise<string[]> {\n    const paths = await glob(path.join(this._artifactsPath, \"**/*.json\"), {\n      ignore: [this._buildInfosGlob, this._dbgsGlob],\n    });\n\n    return paths.sort();\n  }\n\n  public async getBuildInfoPaths(): Promise<string[]> {\n    const paths = await glob(this._buildInfosGlob);\n\n    return paths.sort();\n  }\n\n  public async getDebugFilePaths(): Promise<string[]> {\n    const paths = await glob(this._dbgsGlob);\n\n    return paths.sort();\n  }\n\n  public async saveArtifactAndDebugFile(\n    artifact: Artifact,\n    pathToBuildInfo?: string\n  ) {\n    // artifact\n    const fullyQualifiedName = getFullyQualifiedName(\n      artifact.sourceName,\n      artifact.contractName\n    );\n\n    const artifactPath =\n      this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n\n    await fsExtra.ensureDir(path.dirname(artifactPath));\n\n    // write artifact\n    await fsExtra.writeJSON(artifactPath, artifact, {\n      spaces: 2,\n    });\n\n    if (pathToBuildInfo === undefined) {\n      return;\n    }\n\n    // save debug file\n    const debugFilePath = this._getDebugFilePath(artifactPath);\n    const debugFile = this._createDebugFile(artifactPath, pathToBuildInfo);\n\n    await fsExtra.writeJSON(debugFilePath, debugFile, {\n      spaces: 2,\n    });\n  }\n\n  public async saveBuildInfo(\n    solcVersion: string,\n    solcLongVersion: string,\n    input: CompilerInput,\n    output: CompilerOutput\n  ): Promise<string> {\n    const buildInfoDir = path.join(this._artifactsPath, BUILD_INFO_DIR_NAME);\n    await fsExtra.ensureDir(buildInfoDir);\n\n    const buildInfoName = this._getBuildInfoName(\n      solcVersion,\n      solcLongVersion,\n      input\n    );\n\n    const buildInfo = this._createBuildInfo(\n      buildInfoName,\n      solcVersion,\n      solcLongVersion,\n      input,\n      output\n    );\n\n    const buildInfoPath = path.join(buildInfoDir, `${buildInfoName}.json`);\n    await fsExtra.writeJson(buildInfoPath, buildInfo, { spaces: 2 });\n\n    return buildInfoPath;\n  }\n\n  /**\n   * Remove all artifacts that don't correspond to the current solidity files\n   */\n  public async removeObsoleteArtifacts() {\n    const validArtifactsPaths = new Set<string>();\n\n    for (const { sourceName, artifacts } of this._validArtifacts) {\n      for (const artifactName of artifacts) {\n        validArtifactsPaths.add(\n          this._getArtifactPathSync(\n            getFullyQualifiedName(sourceName, artifactName)\n          )\n        );\n      }\n    }\n\n    const existingArtifactsPaths = await this.getArtifactPaths();\n\n    for (const artifactPath of existingArtifactsPaths) {\n      if (!validArtifactsPaths.has(artifactPath)) {\n        await this._removeArtifactFiles(artifactPath);\n      }\n    }\n\n    await this._removeObsoleteBuildInfos();\n  }\n\n  /**\n   * Returns the absolute path to the given artifact\n   */\n  public formArtifactPathFromFullyQualifiedName(\n    fullyQualifiedName: string\n  ): string {\n    const { sourceName, contractName } =\n      parseFullyQualifiedName(fullyQualifiedName);\n\n    return path.join(this._artifactsPath, sourceName, `${contractName}.json`);\n  }\n\n  /**\n   * Remove all build infos that aren't used by any debug file\n   */\n  private async _removeObsoleteBuildInfos() {\n    const debugFiles = await this.getDebugFilePaths();\n\n    const validBuildInfos = new Set<string>();\n    for (const debugFile of debugFiles) {\n      const buildInfoFile = await this._getBuildInfoFromDebugFile(debugFile);\n      if (buildInfoFile !== undefined) {\n        validBuildInfos.add(\n          path.resolve(path.dirname(debugFile), buildInfoFile)\n        );\n      }\n    }\n\n    const buildInfoFiles = await this.getBuildInfoPaths();\n\n    for (const buildInfoFile of buildInfoFiles) {\n      if (!validBuildInfos.has(buildInfoFile)) {\n        log(`Removing buildInfo '${buildInfoFile}'`);\n        await fsExtra.unlink(buildInfoFile);\n      }\n    }\n  }\n\n  private _getBuildInfoName(\n    solcVersion: string,\n    solcLongVersion: string,\n    input: CompilerInput\n  ): string {\n    const json = JSON.stringify({\n      _format: BUILD_INFO_FORMAT_VERSION,\n      solcVersion,\n      solcLongVersion,\n      input,\n    });\n\n    return createNonCryptographicHashBasedIdentifier(\n      Buffer.from(json)\n    ).toString(\"hex\");\n  }\n\n  /**\n   * Returns the absolute path to the artifact that corresponds to the given\n   * name.\n   *\n   * If the name is fully qualified, the path is computed from it.  If not, an\n   * artifact that matches the given name is searched in the existing artifacts.\n   * If there is an ambiguity, an error is thrown.\n   */\n  private async _getArtifactPath(name: string): Promise<string> {\n    if (isFullyQualifiedName(name)) {\n      return this._getValidArtifactPathFromFullyQualifiedName(name);\n    }\n\n    const files = await this.getArtifactPaths();\n    return this._getArtifactPathFromFiles(name, files);\n  }\n\n  private _createBuildInfo(\n    id: string,\n    solcVersion: string,\n    solcLongVersion: string,\n    input: CompilerInput,\n    output: CompilerOutput\n  ): BuildInfo {\n    return {\n      id,\n      _format: BUILD_INFO_FORMAT_VERSION,\n      solcVersion,\n      solcLongVersion,\n      input,\n      output,\n    };\n  }\n\n  private _createDebugFile(artifactPath: string, pathToBuildInfo: string) {\n    const relativePathToBuildInfo = path.relative(\n      path.dirname(artifactPath),\n      pathToBuildInfo\n    );\n\n    const debugFile: DebugFile = {\n      _format: DEBUG_FILE_FORMAT_VERSION,\n      buildInfo: relativePathToBuildInfo,\n    };\n\n    return debugFile;\n  }\n\n  private _getArtifactPathsSync(): string[] {\n    const paths = globSync(path.join(this._artifactsPath, \"**/*.json\"), {\n      ignore: [this._buildInfosGlob, this._dbgsGlob],\n    });\n\n    return paths.sort();\n  }\n\n  /**\n   * Sync version of _getArtifactPath\n   */\n  private _getArtifactPathSync(name: string): string {\n    if (isFullyQualifiedName(name)) {\n      return this._getValidArtifactPathFromFullyQualifiedNameSync(name);\n    }\n\n    const files = this._getArtifactPathsSync();\n    return this._getArtifactPathFromFiles(name, files);\n  }\n\n  /**\n   * Same signature as imported function, but abstracted to handle the only error we consistently care about\n   */\n  private async _trueCasePath(\n    filePath: string,\n    basePath?: string\n  ): Promise<string | null> {\n    const { trueCasePath } = await import(\"true-case-path\");\n\n    try {\n      const result = await trueCasePath(filePath, basePath);\n      return result;\n    } catch (error) {\n      if (error instanceof Error) {\n        if (error.message.includes(\"no matching file exists\")) {\n          return null;\n        }\n      }\n\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n  }\n\n  /**\n   * Same signature as imported function, but abstracted to handle the only error we consistently care about\n   * and synchronous\n   */\n  private _trueCasePathSync(\n    filePath: string,\n    basePath?: string\n  ): string | null {\n    const { trueCasePathSync } = require(\"true-case-path\");\n\n    try {\n      const result = trueCasePathSync(filePath, basePath);\n      return result;\n    } catch (error) {\n      if (error instanceof Error) {\n        if (error.message.includes(\"no matching file exists\")) {\n          return null;\n        }\n      }\n\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n  }\n\n  /**\n   * DO NOT DELETE OR CHANGE\n   *\n   * use this.formArtifactPathFromFullyQualifiedName instead\n   * @deprecated until typechain migrates to public version\n   * @see https://github.com/dethcrypto/TypeChain/issues/544\n   */\n  private _getArtifactPathFromFullyQualifiedName(\n    fullyQualifiedName: string\n  ): string {\n    const { sourceName, contractName } =\n      parseFullyQualifiedName(fullyQualifiedName);\n\n    return path.join(this._artifactsPath, sourceName, `${contractName}.json`);\n  }\n\n  private async _getValidArtifactPathFromFullyQualifiedName(\n    fullyQualifiedName: string\n  ): Promise<string> {\n    const artifactPath =\n      this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n\n    const trueCaseArtifactPath = await this._trueCasePath(\n      path.relative(this._artifactsPath, artifactPath),\n      this._artifactsPath\n    );\n\n    if (trueCaseArtifactPath === null) {\n      return this._handleWrongArtifactForFullyQualifiedName(fullyQualifiedName);\n    }\n\n    if (artifactPath !== trueCaseArtifactPath) {\n      throw new HardhatError(ERRORS.ARTIFACTS.WRONG_CASING, {\n        correct: trueCaseArtifactPath,\n        incorrect: artifactPath,\n      });\n    }\n\n    return artifactPath;\n  }\n\n  private _getAllContractNamesFromFiles(files: string[]): string[] {\n    return files.map((file) => {\n      const fqn = this._getFullyQualifiedNameFromPath(file);\n      return parseFullyQualifiedName(fqn).contractName;\n    });\n  }\n\n  private _getAllFullyQualifiedNamesSync(): string[] {\n    const paths = this._getArtifactPathsSync();\n    return paths.map((p) => this._getFullyQualifiedNameFromPath(p)).sort();\n  }\n\n  private _formatSuggestions(names: string[], contractName?: string): string {\n    switch (names.length) {\n      case 0:\n        return \"\";\n      case 1:\n        return `Did you mean \"${names[0]}\"?`;\n      default:\n        return `We found some that were similar:\n\n${names.map((n) => `  * ${n}`).join(os.EOL)}\n\nPlease replace \"${contractName}\" for the correct contract name wherever you are trying to read its artifact.\n`;\n    }\n  }\n\n  private _handleWrongArtifactForFullyQualifiedName(\n    fullyQualifiedName: string\n  ): never {\n    const names = this._getAllFullyQualifiedNamesSync();\n\n    const similarNames = this._getSimilarContractNames(\n      fullyQualifiedName,\n      names\n    );\n\n    throw new HardhatError(ERRORS.ARTIFACTS.NOT_FOUND, {\n      contractName: fullyQualifiedName,\n      suggestion: this._formatSuggestions(similarNames),\n    });\n  }\n\n  private _handleWrongArtifactForContractName(\n    contractName: string,\n    files: string[]\n  ): never {\n    const names = this._getAllContractNamesFromFiles(files);\n\n    let similarNames = this._getSimilarContractNames(contractName, names);\n\n    if (similarNames.length > 1) {\n      similarNames = this._filterDuplicatesAsFullyQualifiedNames(\n        files,\n        similarNames\n      );\n    }\n\n    throw new HardhatError(ERRORS.ARTIFACTS.NOT_FOUND, {\n      contractName,\n      suggestion: this._formatSuggestions(similarNames, contractName),\n    });\n  }\n\n  /**\n   * If the project has these contracts:\n   *   - 'contracts/Greeter.sol:Greeter'\n   *   - 'contracts/Meeter.sol:Greeter'\n   *   - 'contracts/Greater.sol:Greater'\n   *  And the user tries to get an artifact with the name 'Greter', then\n   *  the suggestions will be 'Greeter', 'Greeter', and 'Greater'.\n   *\n   * We don't want to show duplicates here, so we use FQNs for those. The\n   * suggestions will then be:\n   *   - 'contracts/Greeter.sol:Greeter'\n   *   - 'contracts/Meeter.sol:Greeter'\n   *   - 'Greater'\n   */\n  private _filterDuplicatesAsFullyQualifiedNames(\n    files: string[],\n    similarNames: string[]\n  ): string[] {\n    const outputNames = [];\n    const groups = similarNames.reduce((obj, cur) => {\n      obj[cur] = obj[cur] ? obj[cur] + 1 : 1;\n      return obj;\n    }, {} as { [k: string]: number });\n\n    for (const [name, occurrences] of Object.entries(groups)) {\n      if (occurrences > 1) {\n        for (const file of files) {\n          if (path.basename(file) === `${name}.json`) {\n            outputNames.push(this._getFullyQualifiedNameFromPath(file));\n          }\n        }\n        continue;\n      }\n\n      outputNames.push(name);\n    }\n\n    return outputNames;\n  }\n\n  /**\n   *\n   * @param givenName can be FQN or contract name\n   * @param names MUST match type of givenName (i.e. array of FQN's if givenName is FQN)\n   * @returns\n   */\n  private _getSimilarContractNames(\n    givenName: string,\n    names: string[]\n  ): string[] {\n    let shortestDistance = EDIT_DISTANCE_THRESHOLD;\n    let mostSimilarNames: string[] = [];\n    for (const name of names) {\n      const distance = findDistance(givenName, name);\n\n      if (distance < shortestDistance) {\n        shortestDistance = distance;\n        mostSimilarNames = [name];\n        continue;\n      }\n\n      if (distance === shortestDistance) {\n        mostSimilarNames.push(name);\n        continue;\n      }\n    }\n\n    return mostSimilarNames;\n  }\n\n  private _getValidArtifactPathFromFullyQualifiedNameSync(\n    fullyQualifiedName: string\n  ): string {\n    const artifactPath =\n      this.formArtifactPathFromFullyQualifiedName(fullyQualifiedName);\n\n    const trueCaseArtifactPath = this._trueCasePathSync(\n      path.relative(this._artifactsPath, artifactPath),\n      this._artifactsPath\n    );\n\n    if (trueCaseArtifactPath === null) {\n      return this._handleWrongArtifactForFullyQualifiedName(fullyQualifiedName);\n    }\n\n    if (artifactPath !== trueCaseArtifactPath) {\n      throw new HardhatError(ERRORS.ARTIFACTS.WRONG_CASING, {\n        correct: trueCaseArtifactPath,\n        incorrect: artifactPath,\n      });\n    }\n\n    return artifactPath;\n  }\n\n  private _getDebugFilePath(artifactPath: string): string {\n    return artifactPath.replace(/\\.json$/, \".dbg.json\");\n  }\n\n  private _getArtifactPathFromFiles(\n    contractName: string,\n    files: string[]\n  ): string {\n    const matchingFiles = files.filter((file) => {\n      return path.basename(file) === `${contractName}.json`;\n    });\n\n    if (matchingFiles.length === 0) {\n      return this._handleWrongArtifactForContractName(contractName, files);\n    }\n\n    if (matchingFiles.length > 1) {\n      const candidates = matchingFiles.map((file) =>\n        this._getFullyQualifiedNameFromPath(file)\n      );\n\n      throw new HardhatError(ERRORS.ARTIFACTS.MULTIPLE_FOUND, {\n        contractName,\n        candidates: candidates.join(os.EOL),\n      });\n    }\n\n    return matchingFiles[0];\n  }\n\n  /**\n   * Returns the FQN of a contract giving the absolute path to its artifact.\n   *\n   * For example, given a path like\n   * `/path/to/project/artifacts/contracts/Foo.sol/Bar.json`, it'll return the\n   * FQN `contracts/Foo.sol:Bar`\n   */\n  private _getFullyQualifiedNameFromPath(absolutePath: string): string {\n    const sourceName = replaceBackslashes(\n      path.relative(this._artifactsPath, path.dirname(absolutePath))\n    );\n\n    const contractName = path.basename(absolutePath).replace(\".json\", \"\");\n\n    return getFullyQualifiedName(sourceName, contractName);\n  }\n\n  /**\n   * Remove the artifact file, its debug file and, if it exists, its build\n   * info file.\n   */\n  private async _removeArtifactFiles(artifactPath: string) {\n    await fsExtra.remove(artifactPath);\n\n    const debugFilePath = this._getDebugFilePath(artifactPath);\n    const buildInfoPath = await this._getBuildInfoFromDebugFile(debugFilePath);\n\n    await fsExtra.remove(debugFilePath);\n\n    if (buildInfoPath !== undefined) {\n      await fsExtra.remove(buildInfoPath);\n    }\n  }\n\n  /**\n   * Given the path to a debug file, returns the absolute path to its\n   * corresponding build info file if it exists, or undefined otherwise.\n   */\n  private async _getBuildInfoFromDebugFile(\n    debugFilePath: string\n  ): Promise<string | undefined> {\n    if (await fsExtra.pathExists(debugFilePath)) {\n      const { buildInfo } = await fsExtra.readJson(debugFilePath);\n      return path.resolve(path.dirname(debugFilePath), buildInfo);\n    }\n\n    return undefined;\n  }\n}\n\n/**\n * Retrieves an artifact for the given `contractName` from the compilation output.\n *\n * @param sourceName The contract's source name.\n * @param contractName the contract's name.\n * @param contractOutput the contract's compilation output as emitted by `solc`.\n */\nexport function getArtifactFromContractOutput(\n  sourceName: string,\n  contractName: string,\n  contractOutput: any\n): Artifact {\n  const evmBytecode = contractOutput.evm && contractOutput.evm.bytecode;\n  let bytecode: string =\n    evmBytecode && evmBytecode.object ? evmBytecode.object : \"\";\n\n  if (bytecode.slice(0, 2).toLowerCase() !== \"0x\") {\n    bytecode = `0x${bytecode}`;\n  }\n\n  const evmDeployedBytecode =\n    contractOutput.evm && contractOutput.evm.deployedBytecode;\n  let deployedBytecode: string =\n    evmDeployedBytecode && evmDeployedBytecode.object\n      ? evmDeployedBytecode.object\n      : \"\";\n\n  if (deployedBytecode.slice(0, 2).toLowerCase() !== \"0x\") {\n    deployedBytecode = `0x${deployedBytecode}`;\n  }\n\n  const linkReferences =\n    evmBytecode && evmBytecode.linkReferences ? evmBytecode.linkReferences : {};\n  const deployedLinkReferences =\n    evmDeployedBytecode && evmDeployedBytecode.linkReferences\n      ? evmDeployedBytecode.linkReferences\n      : {};\n\n  return {\n    _format: ARTIFACT_FORMAT_VERSION,\n    contractName,\n    sourceName,\n    abi: contractOutput.abi,\n    bytecode,\n    deployedBytecode,\n    linkReferences,\n    deployedLinkReferences,\n  };\n}\n"]},"metadata":{},"sourceType":"script"}