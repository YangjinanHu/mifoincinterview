{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst chalk_1 = __importDefault(require(\"chalk\"));\n\nconst path_1 = __importDefault(require(\"path\"));\n\nconst constants_1 = require(\"../internal/constants\");\n\nconst config_env_1 = require(\"../internal/core/config/config-env\");\n\nconst typescript_support_1 = require(\"../internal/core/typescript-support\");\n\nconst disk_cache_1 = require(\"../internal/hardhat-network/provider/utils/disk-cache\");\n\nconst fork_recomendations_banner_1 = require(\"../internal/hardhat-network/provider/utils/fork-recomendations-banner\");\n\nconst glob_1 = require(\"../internal/util/glob\");\n\nconst strings_1 = require(\"../internal/util/strings\");\n\nconst task_names_1 = require(\"./task-names\");\n\n(0, config_env_1.subtask)(task_names_1.TASK_TEST_GET_TEST_FILES).addOptionalVariadicPositionalParam(\"testFiles\", \"An optional list of files to test\", []).setAction(async (_ref, _ref2) => {\n  let {\n    testFiles\n  } = _ref;\n  let {\n    config\n  } = _ref2;\n\n  if (testFiles.length !== 0) {\n    return testFiles;\n  }\n\n  const jsFiles = await (0, glob_1.glob)(path_1.default.join(config.paths.tests, \"**/*.js\"));\n\n  if (!(0, typescript_support_1.isRunningWithTypescript)(config)) {\n    return jsFiles;\n  }\n\n  const tsFiles = await (0, glob_1.glob)(path_1.default.join(config.paths.tests, \"**/*.ts\"));\n  return [...jsFiles, ...tsFiles];\n});\n(0, config_env_1.subtask)(task_names_1.TASK_TEST_SETUP_TEST_ENVIRONMENT, async () => {});\n(0, config_env_1.subtask)(task_names_1.TASK_TEST_RUN_MOCHA_TESTS).addOptionalVariadicPositionalParam(\"testFiles\", \"An optional list of files to test\", []).setAction(async (_ref3, _ref4) => {\n  let {\n    testFiles\n  } = _ref3;\n  let {\n    config\n  } = _ref4;\n  const {\n    default: Mocha\n  } = await Promise.resolve().then(() => __importStar(require(\"mocha\")));\n  const mocha = new Mocha(config.mocha);\n  testFiles.forEach(file => mocha.addFile(file));\n  const testFailures = await new Promise(resolve => {\n    mocha.run(resolve);\n  });\n  mocha.dispose();\n  return testFailures;\n});\n(0, config_env_1.subtask)(task_names_1.TASK_TEST_RUN_SHOW_FORK_RECOMMENDATIONS).setAction(async (_, _ref5) => {\n  let {\n    config,\n    network\n  } = _ref5;\n\n  if (network.name !== constants_1.HARDHAT_NETWORK_NAME) {\n    return;\n  }\n\n  const forkCache = (0, disk_cache_1.getForkCacheDirPath)(config.paths);\n  await (0, fork_recomendations_banner_1.showForkRecommendationsBannerIfNecessary)(network.config, forkCache);\n});\n(0, config_env_1.task)(task_names_1.TASK_TEST, \"Runs mocha tests\").addOptionalVariadicPositionalParam(\"testFiles\", \"An optional list of files to test\", []).addFlag(\"noCompile\", \"Don't compile before running this task\").setAction(async (_ref6, _ref7) => {\n  let {\n    testFiles,\n    noCompile\n  } = _ref6;\n  let {\n    run,\n    network\n  } = _ref7;\n\n  if (!noCompile) {\n    await run(task_names_1.TASK_COMPILE, {\n      quiet: true\n    });\n  }\n\n  const files = await run(task_names_1.TASK_TEST_GET_TEST_FILES, {\n    testFiles\n  });\n  await run(task_names_1.TASK_TEST_SETUP_TEST_ENVIRONMENT);\n  await run(task_names_1.TASK_TEST_RUN_SHOW_FORK_RECOMMENDATIONS);\n  const testFailures = await run(task_names_1.TASK_TEST_RUN_MOCHA_TESTS, {\n    testFiles: files\n  });\n\n  if (network.name === constants_1.HARDHAT_NETWORK_NAME) {\n    const stackTracesFailures = await network.provider.send(\"hardhat_getStackTraceFailuresCount\");\n\n    if (stackTracesFailures !== 0) {\n      console.warn(chalk_1.default.yellow(`Failed to generate ${stackTracesFailures} ${(0, strings_1.pluralize)(stackTracesFailures, \"stack trace\")}. Run Hardhat with --verbose to learn more.`));\n    }\n  }\n\n  process.exitCode = testFailures;\n  return testFailures;\n});","map":{"version":3,"mappings":"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","names":["task_names_1","addOptionalVariadicPositionalParam","setAction","testFiles","config","length","jsFiles","path_1","join","paths","tests","tsFiles","default","Mocha","mocha","forEach","file","addFile","testFailures","Promise","resolve","run","dispose","_","network","name","constants_1","forkCache","addFlag","noCompile","quiet","files","stackTracesFailures","provider","send","console","warn","chalk_1","yellow","process","exitCode"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/builtin-tasks/test.ts"],"sourcesContent":["import chalk from \"chalk\";\nimport path from \"path\";\n\nimport { HARDHAT_NETWORK_NAME } from \"../internal/constants\";\nimport { subtask, task } from \"../internal/core/config/config-env\";\nimport { isRunningWithTypescript } from \"../internal/core/typescript-support\";\nimport { getForkCacheDirPath } from \"../internal/hardhat-network/provider/utils/disk-cache\";\nimport { showForkRecommendationsBannerIfNecessary } from \"../internal/hardhat-network/provider/utils/fork-recomendations-banner\";\nimport { glob } from \"../internal/util/glob\";\nimport { pluralize } from \"../internal/util/strings\";\n\nimport {\n  TASK_COMPILE,\n  TASK_TEST,\n  TASK_TEST_GET_TEST_FILES,\n  TASK_TEST_RUN_MOCHA_TESTS,\n  TASK_TEST_RUN_SHOW_FORK_RECOMMENDATIONS,\n  TASK_TEST_SETUP_TEST_ENVIRONMENT,\n} from \"./task-names\";\n\nsubtask(TASK_TEST_GET_TEST_FILES)\n  .addOptionalVariadicPositionalParam(\n    \"testFiles\",\n    \"An optional list of files to test\",\n    []\n  )\n  .setAction(async ({ testFiles }: { testFiles: string[] }, { config }) => {\n    if (testFiles.length !== 0) {\n      return testFiles;\n    }\n\n    const jsFiles = await glob(path.join(config.paths.tests, \"**/*.js\"));\n\n    if (!isRunningWithTypescript(config)) {\n      return jsFiles;\n    }\n\n    const tsFiles = await glob(path.join(config.paths.tests, \"**/*.ts\"));\n\n    return [...jsFiles, ...tsFiles];\n  });\n\nsubtask(TASK_TEST_SETUP_TEST_ENVIRONMENT, async () => {});\n\nsubtask(TASK_TEST_RUN_MOCHA_TESTS)\n  .addOptionalVariadicPositionalParam(\n    \"testFiles\",\n    \"An optional list of files to test\",\n    []\n  )\n  .setAction(async ({ testFiles }: { testFiles: string[] }, { config }) => {\n    const { default: Mocha } = await import(\"mocha\");\n    const mocha = new Mocha(config.mocha);\n    testFiles.forEach((file) => mocha.addFile(file));\n\n    const testFailures = await new Promise<number>((resolve) => {\n      mocha.run(resolve);\n    });\n\n    mocha.dispose();\n\n    return testFailures;\n  });\n\nsubtask(TASK_TEST_RUN_SHOW_FORK_RECOMMENDATIONS).setAction(\n  async (_, { config, network }) => {\n    if (network.name !== HARDHAT_NETWORK_NAME) {\n      return;\n    }\n\n    const forkCache = getForkCacheDirPath(config.paths);\n    await showForkRecommendationsBannerIfNecessary(network.config, forkCache);\n  }\n);\n\ntask(TASK_TEST, \"Runs mocha tests\")\n  .addOptionalVariadicPositionalParam(\n    \"testFiles\",\n    \"An optional list of files to test\",\n    []\n  )\n  .addFlag(\"noCompile\", \"Don't compile before running this task\")\n  .setAction(\n    async (\n      {\n        testFiles,\n        noCompile,\n      }: {\n        testFiles: string[];\n        noCompile: boolean;\n      },\n      { run, network }\n    ) => {\n      if (!noCompile) {\n        await run(TASK_COMPILE, { quiet: true });\n      }\n\n      const files = await run(TASK_TEST_GET_TEST_FILES, { testFiles });\n\n      await run(TASK_TEST_SETUP_TEST_ENVIRONMENT);\n\n      await run(TASK_TEST_RUN_SHOW_FORK_RECOMMENDATIONS);\n\n      const testFailures = await run(TASK_TEST_RUN_MOCHA_TESTS, {\n        testFiles: files,\n      });\n\n      if (network.name === HARDHAT_NETWORK_NAME) {\n        const stackTracesFailures = await network.provider.send(\n          \"hardhat_getStackTraceFailuresCount\"\n        );\n\n        if (stackTracesFailures !== 0) {\n          console.warn(\n            chalk.yellow(\n              `Failed to generate ${stackTracesFailures} ${pluralize(\n                stackTracesFailures,\n                \"stack trace\"\n              )}. Run Hardhat with --verbose to learn more.`\n            )\n          );\n        }\n      }\n\n      process.exitCode = testFailures;\n      return testFailures;\n    }\n  );\n"]},"metadata":{},"sourceType":"script"}