{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst fs = __importStar(require(\"fs\"));\n\nconst config_env_1 = require(\"../internal/core/config/config-env\");\n\nconst errors_1 = require(\"../internal/core/errors\");\n\nconst errors_list_1 = require(\"../internal/core/errors-list\");\n\nconst packageInfo_1 = require(\"../internal/util/packageInfo\");\n\nconst task_names_1 = require(\"./task-names\");\n\nfunction getSortedFiles(dependenciesGraph) {\n  const tsort = require(\"tsort\");\n\n  const graph = tsort();\n  const filesMap = {};\n  const resolvedFiles = dependenciesGraph.getResolvedFiles();\n  resolvedFiles.forEach(f => filesMap[f.sourceName] = f);\n\n  for (const [from, deps] of dependenciesGraph.entries()) {\n    for (const to of deps) {\n      graph.add(to.sourceName, from.sourceName);\n    }\n  }\n\n  try {\n    const topologicalSortedNames = graph.sort(); // If an entry has no dependency it won't be included in the graph, so we\n    // add them and then dedup the array\n\n    const withEntries = topologicalSortedNames.concat(resolvedFiles.map(f => f.sourceName));\n    const sortedNames = [...new Set(withEntries)];\n    return sortedNames.map(n => filesMap[n]);\n  } catch (error) {\n    if (error instanceof Error) {\n      if (error.toString().includes(\"Error: There is a cycle in the graph.\")) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.FLATTEN_CYCLE, error);\n      }\n    } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n    throw error;\n  }\n}\n\nfunction getFileWithoutImports(resolvedFile) {\n  const IMPORT_SOLIDITY_REGEX = /^\\s*import(\\s+)[\\s\\S]*?;\\s*$/gm;\n  return resolvedFile.content.rawContent.replace(IMPORT_SOLIDITY_REGEX, \"\").trim();\n}\n\n(0, config_env_1.subtask)(task_names_1.TASK_FLATTEN_GET_FLATTENED_SOURCE, \"Returns all contracts and their dependencies flattened\").addOptionalParam(\"files\", undefined, undefined, config_env_1.types.any).setAction(async (_ref, _ref2) => {\n  let {\n    files\n  } = _ref;\n  let {\n    run\n  } = _ref2;\n  const dependencyGraph = await run(task_names_1.TASK_FLATTEN_GET_DEPENDENCY_GRAPH, {\n    files\n  });\n  let flattened = \"\";\n\n  if (dependencyGraph.getResolvedFiles().length === 0) {\n    return flattened;\n  }\n\n  const packageJson = await (0, packageInfo_1.getPackageJson)();\n  flattened += `// Sources flattened with hardhat v${packageJson.version} https://hardhat.org`;\n  const sortedFiles = getSortedFiles(dependencyGraph);\n\n  for (const file of sortedFiles) {\n    flattened += `\\n\\n// File ${file.getVersionedName()}\\n`;\n    flattened += `\\n${getFileWithoutImports(file)}\\n`;\n  }\n\n  return flattened.trim();\n});\n(0, config_env_1.subtask)(task_names_1.TASK_FLATTEN_GET_DEPENDENCY_GRAPH).addOptionalParam(\"files\", undefined, undefined, config_env_1.types.any).setAction(async (_ref3, _ref4) => {\n  let {\n    files\n  } = _ref3;\n  let {\n    run\n  } = _ref4;\n  const sourcePaths = files === undefined ? await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS) : files.map(f => fs.realpathSync(f));\n  const sourceNames = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES, {\n    sourcePaths\n  });\n  const dependencyGraph = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH, {\n    sourceNames\n  });\n  return dependencyGraph;\n});\n(0, config_env_1.task)(task_names_1.TASK_FLATTEN, \"Flattens and prints contracts and their dependencies\").addOptionalVariadicPositionalParam(\"files\", \"The files to flatten\", undefined, config_env_1.types.inputFile).setAction(async (_ref5, _ref6) => {\n  let {\n    files\n  } = _ref5;\n  let {\n    run\n  } = _ref6;\n  console.log(await run(task_names_1.TASK_FLATTEN_GET_FLATTENED_SOURCE, {\n    files\n  }));\n});","map":{"version":3,"mappings":"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","names":["getSortedFiles","dependenciesGraph","tsort","require","graph","filesMap","resolvedFiles","getResolvedFiles","forEach","f","sourceName","from","deps","entries","to","add","topologicalSortedNames","sort","withEntries","concat","map","sortedNames","Set","n","error","Error","toString","includes","errors_1","errors_list_1","BUILTIN_TASKS","FLATTEN_CYCLE","getFileWithoutImports","resolvedFile","IMPORT_SOLIDITY_REGEX","content","rawContent","replace","trim","task_names_1","addOptionalParam","undefined","config_env_1","any","setAction","files","run","dependencyGraph","flattened","length","packageJson","version","sortedFiles","file","getVersionedName","sourcePaths","fs","realpathSync","sourceNames","addOptionalVariadicPositionalParam","inputFile","console","log"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/builtin-tasks/flatten.ts"],"sourcesContent":["import * as fs from \"fs\";\n\nimport { subtask, task, types } from \"../internal/core/config/config-env\";\nimport { HardhatError } from \"../internal/core/errors\";\nimport { ERRORS } from \"../internal/core/errors-list\";\nimport { DependencyGraph } from \"../internal/solidity/dependencyGraph\";\nimport { ResolvedFile, ResolvedFilesMap } from \"../internal/solidity/resolver\";\nimport { getPackageJson } from \"../internal/util/packageInfo\";\n\nimport {\n  TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH,\n  TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES,\n  TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS,\n  TASK_FLATTEN,\n  TASK_FLATTEN_GET_DEPENDENCY_GRAPH,\n  TASK_FLATTEN_GET_FLATTENED_SOURCE,\n} from \"./task-names\";\n\nfunction getSortedFiles(dependenciesGraph: DependencyGraph) {\n  const tsort = require(\"tsort\");\n  const graph = tsort();\n\n  const filesMap: ResolvedFilesMap = {};\n  const resolvedFiles = dependenciesGraph.getResolvedFiles();\n  resolvedFiles.forEach((f) => (filesMap[f.sourceName] = f));\n\n  for (const [from, deps] of dependenciesGraph.entries()) {\n    for (const to of deps) {\n      graph.add(to.sourceName, from.sourceName);\n    }\n  }\n\n  try {\n    const topologicalSortedNames: string[] = graph.sort();\n\n    // If an entry has no dependency it won't be included in the graph, so we\n    // add them and then dedup the array\n    const withEntries = topologicalSortedNames.concat(\n      resolvedFiles.map((f) => f.sourceName)\n    );\n\n    const sortedNames = [...new Set(withEntries)];\n    return sortedNames.map((n) => filesMap[n]);\n  } catch (error) {\n    if (error instanceof Error) {\n      if (error.toString().includes(\"Error: There is a cycle in the graph.\")) {\n        throw new HardhatError(ERRORS.BUILTIN_TASKS.FLATTEN_CYCLE, error);\n      }\n    }\n\n    // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n}\n\nfunction getFileWithoutImports(resolvedFile: ResolvedFile) {\n  const IMPORT_SOLIDITY_REGEX = /^\\s*import(\\s+)[\\s\\S]*?;\\s*$/gm;\n\n  return resolvedFile.content.rawContent\n    .replace(IMPORT_SOLIDITY_REGEX, \"\")\n    .trim();\n}\n\nsubtask(\n  TASK_FLATTEN_GET_FLATTENED_SOURCE,\n  \"Returns all contracts and their dependencies flattened\"\n)\n  .addOptionalParam(\"files\", undefined, undefined, types.any)\n  .setAction(async ({ files }: { files?: string[] }, { run }) => {\n    const dependencyGraph: DependencyGraph = await run(\n      TASK_FLATTEN_GET_DEPENDENCY_GRAPH,\n      { files }\n    );\n\n    let flattened = \"\";\n\n    if (dependencyGraph.getResolvedFiles().length === 0) {\n      return flattened;\n    }\n\n    const packageJson = await getPackageJson();\n    flattened += `// Sources flattened with hardhat v${packageJson.version} https://hardhat.org`;\n\n    const sortedFiles = getSortedFiles(dependencyGraph);\n\n    for (const file of sortedFiles) {\n      flattened += `\\n\\n// File ${file.getVersionedName()}\\n`;\n      flattened += `\\n${getFileWithoutImports(file)}\\n`;\n    }\n\n    return flattened.trim();\n  });\n\nsubtask(TASK_FLATTEN_GET_DEPENDENCY_GRAPH)\n  .addOptionalParam(\"files\", undefined, undefined, types.any)\n  .setAction(async ({ files }: { files: string[] | undefined }, { run }) => {\n    const sourcePaths: string[] =\n      files === undefined\n        ? await run(TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS)\n        : files.map((f) => fs.realpathSync(f));\n\n    const sourceNames: string[] = await run(\n      TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES,\n      {\n        sourcePaths,\n      }\n    );\n\n    const dependencyGraph: DependencyGraph = await run(\n      TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH,\n      { sourceNames }\n    );\n\n    return dependencyGraph;\n  });\n\ntask(TASK_FLATTEN, \"Flattens and prints contracts and their dependencies\")\n  .addOptionalVariadicPositionalParam(\n    \"files\",\n    \"The files to flatten\",\n    undefined,\n    types.inputFile\n  )\n  .setAction(async ({ files }: { files: string[] | undefined }, { run }) => {\n    console.log(await run(TASK_FLATTEN_GET_FLATTENED_SOURCE, { files }));\n  });\n"]},"metadata":{},"sourceType":"script"}