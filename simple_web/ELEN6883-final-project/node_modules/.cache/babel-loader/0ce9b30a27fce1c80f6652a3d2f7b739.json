{"ast":null,"code":"'use strict';\n/**\n * Module dependencies.\n */\n\nvar util = require('util');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar Pending = require('./pending');\n\nvar utils = require('./utils');\n\nvar inherits = utils.inherits;\n\nvar debug = require('debug')('mocha:runner');\n\nvar Runnable = require('./runnable');\n\nvar Suite = require('./suite');\n\nvar HOOK_TYPE_BEFORE_EACH = Suite.constants.HOOK_TYPE_BEFORE_EACH;\nvar HOOK_TYPE_AFTER_EACH = Suite.constants.HOOK_TYPE_AFTER_EACH;\nvar HOOK_TYPE_AFTER_ALL = Suite.constants.HOOK_TYPE_AFTER_ALL;\nvar HOOK_TYPE_BEFORE_ALL = Suite.constants.HOOK_TYPE_BEFORE_ALL;\nvar EVENT_ROOT_SUITE_RUN = Suite.constants.EVENT_ROOT_SUITE_RUN;\nvar STATE_FAILED = Runnable.constants.STATE_FAILED;\nvar STATE_PASSED = Runnable.constants.STATE_PASSED;\nvar dQuote = utils.dQuote;\nvar sQuote = utils.sQuote;\nvar stackFilter = utils.stackTraceFilter();\nvar stringify = utils.stringify;\nvar type = utils.type;\n\nvar errors = require('./errors');\n\nvar createInvalidExceptionError = errors.createInvalidExceptionError;\nvar createUnsupportedError = errors.createUnsupportedError;\nvar createFatalError = errors.createFatalError;\n/**\n * Non-enumerable globals.\n * @readonly\n */\n\nvar globals = ['setTimeout', 'clearTimeout', 'setInterval', 'clearInterval', 'XMLHttpRequest', 'Date', 'setImmediate', 'clearImmediate'];\nvar constants = utils.defineConstants(\n/**\n * {@link Runner}-related constants.\n * @public\n * @memberof Runner\n * @readonly\n * @alias constants\n * @static\n * @enum {string}\n */\n{\n  /**\n   * Emitted when {@link Hook} execution begins\n   */\n  EVENT_HOOK_BEGIN: 'hook',\n\n  /**\n   * Emitted when {@link Hook} execution ends\n   */\n  EVENT_HOOK_END: 'hook end',\n\n  /**\n   * Emitted when Root {@link Suite} execution begins (all files have been parsed and hooks/tests are ready for execution)\n   */\n  EVENT_RUN_BEGIN: 'start',\n\n  /**\n   * Emitted when Root {@link Suite} execution has been delayed via `delay` option\n   */\n  EVENT_DELAY_BEGIN: 'waiting',\n\n  /**\n   * Emitted when delayed Root {@link Suite} execution is triggered by user via `global.run()`\n   */\n  EVENT_DELAY_END: 'ready',\n\n  /**\n   * Emitted when Root {@link Suite} execution ends\n   */\n  EVENT_RUN_END: 'end',\n\n  /**\n   * Emitted when {@link Suite} execution begins\n   */\n  EVENT_SUITE_BEGIN: 'suite',\n\n  /**\n   * Emitted when {@link Suite} execution ends\n   */\n  EVENT_SUITE_END: 'suite end',\n\n  /**\n   * Emitted when {@link Test} execution begins\n   */\n  EVENT_TEST_BEGIN: 'test',\n\n  /**\n   * Emitted when {@link Test} execution ends\n   */\n  EVENT_TEST_END: 'test end',\n\n  /**\n   * Emitted when {@link Test} execution fails\n   */\n  EVENT_TEST_FAIL: 'fail',\n\n  /**\n   * Emitted when {@link Test} execution succeeds\n   */\n  EVENT_TEST_PASS: 'pass',\n\n  /**\n   * Emitted when {@link Test} becomes pending\n   */\n  EVENT_TEST_PENDING: 'pending',\n\n  /**\n   * Emitted when {@link Test} execution has failed, but will retry\n   */\n  EVENT_TEST_RETRY: 'retry',\n\n  /**\n   * Initial state of Runner\n   */\n  STATE_IDLE: 'idle',\n\n  /**\n   * State set to this value when the Runner has started running\n   */\n  STATE_RUNNING: 'running',\n\n  /**\n   * State set to this value when the Runner has stopped\n   */\n  STATE_STOPPED: 'stopped'\n});\nmodule.exports = Runner;\n/**\n * Initialize a `Runner` at the Root {@link Suite}, which represents a hierarchy of {@link Suite|Suites} and {@link Test|Tests}.\n *\n * @extends external:EventEmitter\n * @public\n * @class\n * @param {Suite} suite - Root suite\n * @param {Object|boolean} [opts] - Options. If `boolean`, whether or not to delay execution of root suite until ready (for backwards compatibility).\n * @param {boolean} [opts.delay] - Whether to delay execution of root suite until ready.\n * @param {boolean} [opts.cleanReferencesAfterRun] - Whether to clean references to test fns and hooks when a suite is done.\n */\n\nfunction Runner(suite, opts) {\n  if (opts === undefined) {\n    opts = {};\n  }\n\n  if (typeof opts === 'boolean') {\n    this._delay = opts;\n    opts = {};\n  } else {\n    this._delay = opts.delay;\n  }\n\n  var self = this;\n  this._globals = [];\n  this._abort = false;\n  this.suite = suite;\n  this._opts = opts;\n  this.state = constants.STATE_IDLE;\n  this.total = suite.total();\n  this.failures = 0;\n  this._eventListeners = [];\n  this.on(constants.EVENT_TEST_END, function (test) {\n    if (test.type === 'test' && test.retriedTest() && test.parent) {\n      var idx = test.parent.tests && test.parent.tests.indexOf(test.retriedTest());\n      if (idx > -1) test.parent.tests[idx] = test;\n    }\n\n    self.checkGlobals(test);\n  });\n  this.on(constants.EVENT_HOOK_END, function (hook) {\n    self.checkGlobals(hook);\n  });\n  this._defaultGrep = /.*/;\n  this.grep(this._defaultGrep);\n  this.globals(this.globalProps());\n  this.uncaught = this._uncaught.bind(this);\n}\n/**\n * Wrapper for setImmediate, process.nextTick, or browser polyfill.\n *\n * @param {Function} fn\n * @private\n */\n\n\nRunner.immediately = global.setImmediate || process.nextTick;\n/**\n * Inherit from `EventEmitter.prototype`.\n */\n\ninherits(Runner, EventEmitter);\n/**\n * Replacement for `target.on(eventName, listener)` that does bookkeeping to remove them when this runner instance is disposed.\n * @param {EventEmitter} target - The `EventEmitter`\n * @param {string} eventName - The event name\n * @param {string} fn - Listener function\n */\n\nRunner.prototype._addEventListener = function (target, eventName, listener) {\n  target.on(eventName, listener);\n\n  this._eventListeners.push([target, eventName, listener]);\n};\n/**\n * Replacement for `target.removeListener(eventName, listener)` that also updates the bookkeeping.\n * @param {EventEmitter} target - The `EventEmitter`\n * @param {string} eventName - The event anme\n * @param {function} listener - Listener function\n */\n\n\nRunner.prototype._removeEventListener = function (target, eventName, listener) {\n  var eventListenerIndex = -1;\n\n  for (var i = 0; i < this._eventListeners.length; i++) {\n    var eventListenerDescriptor = this._eventListeners[i];\n\n    if (eventListenerDescriptor[0] === target && eventListenerDescriptor[1] === eventName && eventListenerDescriptor[2] === listener) {\n      eventListenerIndex = i;\n      break;\n    }\n  }\n\n  if (eventListenerIndex !== -1) {\n    var removedListener = this._eventListeners.splice(eventListenerIndex, 1)[0];\n\n    removedListener[0].removeListener(removedListener[1], removedListener[2]);\n  }\n};\n/**\n * Removes all event handlers set during a run on this instance.\n * Remark: this does _not_ clean/dispose the tests or suites themselves.\n */\n\n\nRunner.prototype.dispose = function () {\n  this.removeAllListeners();\n\n  this._eventListeners.forEach(function (eventListenerDescriptor) {\n    eventListenerDescriptor[0].removeListener(eventListenerDescriptor[1], eventListenerDescriptor[2]);\n  });\n};\n/**\n * Run tests with full titles matching `re`. Updates runner.total\n * with number of tests matched.\n *\n * @public\n * @memberof Runner\n * @param {RegExp} re\n * @param {boolean} invert\n * @return {Runner} Runner instance.\n */\n\n\nRunner.prototype.grep = function (re, invert) {\n  debug('grep(): setting to %s', re);\n  this._grep = re;\n  this._invert = invert;\n  this.total = this.grepTotal(this.suite);\n  return this;\n};\n/**\n * Returns the number of tests matching the grep search for the\n * given suite.\n *\n * @memberof Runner\n * @public\n * @param {Suite} suite\n * @return {number}\n */\n\n\nRunner.prototype.grepTotal = function (suite) {\n  var self = this;\n  var total = 0;\n  suite.eachTest(function (test) {\n    var match = self._grep.test(test.fullTitle());\n\n    if (self._invert) {\n      match = !match;\n    }\n\n    if (match) {\n      total++;\n    }\n  });\n  return total;\n};\n/**\n * Return a list of global properties.\n *\n * @return {Array}\n * @private\n */\n\n\nRunner.prototype.globalProps = function () {\n  var props = Object.keys(global); // non-enumerables\n\n  for (var i = 0; i < globals.length; ++i) {\n    if (~props.indexOf(globals[i])) {\n      continue;\n    }\n\n    props.push(globals[i]);\n  }\n\n  return props;\n};\n/**\n * Allow the given `arr` of globals.\n *\n * @public\n * @memberof Runner\n * @param {Array} arr\n * @return {Runner} Runner instance.\n */\n\n\nRunner.prototype.globals = function (arr) {\n  if (!arguments.length) {\n    return this._globals;\n  }\n\n  debug('globals(): setting to %O', arr);\n  this._globals = this._globals.concat(arr);\n  return this;\n};\n/**\n * Check for global variable leaks.\n *\n * @private\n */\n\n\nRunner.prototype.checkGlobals = function (test) {\n  if (!this.checkLeaks) {\n    return;\n  }\n\n  var ok = this._globals;\n  var globals = this.globalProps();\n  var leaks;\n\n  if (test) {\n    ok = ok.concat(test._allowedGlobals || []);\n  }\n\n  if (this.prevGlobalsLength === globals.length) {\n    return;\n  }\n\n  this.prevGlobalsLength = globals.length;\n  leaks = filterLeaks(ok, globals);\n  this._globals = this._globals.concat(leaks);\n\n  if (leaks.length) {\n    var msg = 'global leak(s) detected: %s';\n    var error = new Error(util.format(msg, leaks.map(sQuote).join(', ')));\n    this.fail(test, error);\n  }\n};\n/**\n * Fail the given `test`.\n *\n * @private\n * @param {Test} test\n * @param {Error} err\n */\n\n\nRunner.prototype.fail = function (test, err) {\n  if (test.isPending()) {\n    return;\n  }\n\n  if (this.state === constants.STATE_STOPPED) {\n    if (err.code === errors.constants.MULTIPLE_DONE) {\n      throw err;\n    }\n\n    throw createFatalError('Test failed after root suite execution completed!', err);\n  }\n\n  ++this.failures;\n  debug('total number of failures: %d', this.failures);\n  test.state = STATE_FAILED;\n\n  if (!isError(err)) {\n    err = thrown2Error(err);\n  }\n\n  try {\n    err.stack = this.fullStackTrace || !err.stack ? err.stack : stackFilter(err.stack);\n  } catch (ignore) {// some environments do not take kindly to monkeying with the stack\n  }\n\n  this.emit(constants.EVENT_TEST_FAIL, test, err);\n};\n/**\n * Fail the given `hook` with `err`.\n *\n * Hook failures work in the following pattern:\n * - If bail, run corresponding `after each` and `after` hooks,\n *   then exit\n * - Failed `before` hook skips all tests in a suite and subsuites,\n *   but jumps to corresponding `after` hook\n * - Failed `before each` hook skips remaining tests in a\n *   suite and jumps to corresponding `after each` hook,\n *   which is run only once\n * - Failed `after` hook does not alter execution order\n * - Failed `after each` hook skips remaining tests in a\n *   suite and subsuites, but executes other `after each`\n *   hooks\n *\n * @private\n * @param {Hook} hook\n * @param {Error} err\n */\n\n\nRunner.prototype.failHook = function (hook, err) {\n  hook.originalTitle = hook.originalTitle || hook.title;\n\n  if (hook.ctx && hook.ctx.currentTest) {\n    hook.title = hook.originalTitle + ' for ' + dQuote(hook.ctx.currentTest.title);\n  } else {\n    var parentTitle;\n\n    if (hook.parent.title) {\n      parentTitle = hook.parent.title;\n    } else {\n      parentTitle = hook.parent.root ? '{root}' : '';\n    }\n\n    hook.title = hook.originalTitle + ' in ' + dQuote(parentTitle);\n  }\n\n  this.fail(hook, err);\n};\n/**\n * Run hook `name` callbacks and then invoke `fn()`.\n *\n * @private\n * @param {string} name\n * @param {Function} fn\n */\n\n\nRunner.prototype.hook = function (name, fn) {\n  var suite = this.suite;\n  var hooks = suite.getHooks(name);\n  var self = this;\n\n  function next(i) {\n    var hook = hooks[i];\n\n    if (!hook) {\n      return fn();\n    }\n\n    self.currentRunnable = hook;\n\n    if (name === HOOK_TYPE_BEFORE_ALL) {\n      hook.ctx.currentTest = hook.parent.tests[0];\n    } else if (name === HOOK_TYPE_AFTER_ALL) {\n      hook.ctx.currentTest = hook.parent.tests[hook.parent.tests.length - 1];\n    } else {\n      hook.ctx.currentTest = self.test;\n    }\n\n    hook.allowUncaught = self.allowUncaught;\n    self.emit(constants.EVENT_HOOK_BEGIN, hook);\n\n    if (!hook.listeners('error').length) {\n      self._addEventListener(hook, 'error', function (err) {\n        self.failHook(hook, err);\n      });\n    }\n\n    hook.run(function (err) {\n      var testError = hook.error();\n\n      if (testError) {\n        self.fail(self.test, testError);\n      } // conditional skip\n\n\n      if (hook.pending) {\n        if (name === HOOK_TYPE_AFTER_EACH) {\n          // TODO define and implement use case\n          if (self.test) {\n            self.test.pending = true;\n          }\n        } else if (name === HOOK_TYPE_BEFORE_EACH) {\n          if (self.test) {\n            self.test.pending = true;\n          }\n\n          self.emit(constants.EVENT_HOOK_END, hook);\n          hook.pending = false; // activates hook for next test\n\n          return fn(new Error('abort hookDown'));\n        } else if (name === HOOK_TYPE_BEFORE_ALL) {\n          suite.tests.forEach(function (test) {\n            test.pending = true;\n          });\n          suite.suites.forEach(function (suite) {\n            suite.pending = true;\n          });\n        } else {\n          hook.pending = false;\n          var errForbid = createUnsupportedError('`this.skip` forbidden');\n          self.failHook(hook, errForbid);\n          return fn(errForbid);\n        }\n      } else if (err) {\n        self.failHook(hook, err); // stop executing hooks, notify callee of hook err\n\n        return fn(err);\n      }\n\n      self.emit(constants.EVENT_HOOK_END, hook);\n      delete hook.ctx.currentTest;\n      next(++i);\n    });\n  }\n\n  Runner.immediately(function () {\n    next(0);\n  });\n};\n/**\n * Run hook `name` for the given array of `suites`\n * in order, and callback `fn(err, errSuite)`.\n *\n * @private\n * @param {string} name\n * @param {Array} suites\n * @param {Function} fn\n */\n\n\nRunner.prototype.hooks = function (name, suites, fn) {\n  var self = this;\n  var orig = this.suite;\n\n  function next(suite) {\n    self.suite = suite;\n\n    if (!suite) {\n      self.suite = orig;\n      return fn();\n    }\n\n    self.hook(name, function (err) {\n      if (err) {\n        var errSuite = self.suite;\n        self.suite = orig;\n        return fn(err, errSuite);\n      }\n\n      next(suites.pop());\n    });\n  }\n\n  next(suites.pop());\n};\n/**\n * Run hooks from the top level down.\n *\n * @param {String} name\n * @param {Function} fn\n * @private\n */\n\n\nRunner.prototype.hookUp = function (name, fn) {\n  var suites = [this.suite].concat(this.parents()).reverse();\n  this.hooks(name, suites, fn);\n};\n/**\n * Run hooks from the bottom up.\n *\n * @param {String} name\n * @param {Function} fn\n * @private\n */\n\n\nRunner.prototype.hookDown = function (name, fn) {\n  var suites = [this.suite].concat(this.parents());\n  this.hooks(name, suites, fn);\n};\n/**\n * Return an array of parent Suites from\n * closest to furthest.\n *\n * @return {Array}\n * @private\n */\n\n\nRunner.prototype.parents = function () {\n  var suite = this.suite;\n  var suites = [];\n\n  while (suite.parent) {\n    suite = suite.parent;\n    suites.push(suite);\n  }\n\n  return suites;\n};\n/**\n * Run the current test and callback `fn(err)`.\n *\n * @param {Function} fn\n * @private\n */\n\n\nRunner.prototype.runTest = function (fn) {\n  var self = this;\n  var test = this.test;\n\n  if (!test) {\n    return;\n  }\n\n  if (this.asyncOnly) {\n    test.asyncOnly = true;\n  }\n\n  this._addEventListener(test, 'error', function (err) {\n    self.fail(test, err);\n  });\n\n  if (this.allowUncaught) {\n    test.allowUncaught = true;\n    return test.run(fn);\n  }\n\n  try {\n    test.run(fn);\n  } catch (err) {\n    fn(err);\n  }\n};\n/**\n * Run tests in the given `suite` and invoke the callback `fn()` when complete.\n *\n * @private\n * @param {Suite} suite\n * @param {Function} fn\n */\n\n\nRunner.prototype.runTests = function (suite, fn) {\n  var self = this;\n  var tests = suite.tests.slice();\n  var test;\n\n  function hookErr(_, errSuite, after) {\n    // before/after Each hook for errSuite failed:\n    var orig = self.suite; // for failed 'after each' hook start from errSuite parent,\n    // otherwise start from errSuite itself\n\n    self.suite = after ? errSuite.parent : errSuite;\n\n    if (self.suite) {\n      // call hookUp afterEach\n      self.hookUp(HOOK_TYPE_AFTER_EACH, function (err2, errSuite2) {\n        self.suite = orig; // some hooks may fail even now\n\n        if (err2) {\n          return hookErr(err2, errSuite2, true);\n        } // report error suite\n\n\n        fn(errSuite);\n      });\n    } else {\n      // there is no need calling other 'after each' hooks\n      self.suite = orig;\n      fn(errSuite);\n    }\n  }\n\n  function next(err, errSuite) {\n    // if we bail after first err\n    if (self.failures && suite._bail) {\n      tests = [];\n    }\n\n    if (self._abort) {\n      return fn();\n    }\n\n    if (err) {\n      return hookErr(err, errSuite, true);\n    } // next test\n\n\n    test = tests.shift(); // all done\n\n    if (!test) {\n      return fn();\n    } // grep\n\n\n    var match = self._grep.test(test.fullTitle());\n\n    if (self._invert) {\n      match = !match;\n    }\n\n    if (!match) {\n      // Run immediately only if we have defined a grep. When we\n      // define a grep â€” It can cause maximum callstack error if\n      // the grep is doing a large recursive loop by neglecting\n      // all tests. The run immediately function also comes with\n      // a performance cost. So we don't want to run immediately\n      // if we run the whole test suite, because running the whole\n      // test suite don't do any immediate recursive loops. Thus,\n      // allowing a JS runtime to breathe.\n      if (self._grep !== self._defaultGrep) {\n        Runner.immediately(next);\n      } else {\n        next();\n      }\n\n      return;\n    } // static skip, no hooks are executed\n\n\n    if (test.isPending()) {\n      if (self.forbidPending) {\n        test.isPending = alwaysFalse;\n        self.fail(test, new Error('Pending test forbidden'));\n        delete test.isPending;\n      } else {\n        self.emit(constants.EVENT_TEST_PENDING, test);\n      }\n\n      self.emit(constants.EVENT_TEST_END, test);\n      return next();\n    } // execute test and hook(s)\n\n\n    self.emit(constants.EVENT_TEST_BEGIN, self.test = test);\n    self.hookDown(HOOK_TYPE_BEFORE_EACH, function (err, errSuite) {\n      // conditional skip within beforeEach\n      if (test.isPending()) {\n        if (self.forbidPending) {\n          test.isPending = alwaysFalse;\n          self.fail(test, new Error('Pending test forbidden'));\n          delete test.isPending;\n        } else {\n          self.emit(constants.EVENT_TEST_PENDING, test);\n        }\n\n        self.emit(constants.EVENT_TEST_END, test); // skip inner afterEach hooks below errSuite level\n\n        var origSuite = self.suite;\n        self.suite = errSuite || self.suite;\n        return self.hookUp(HOOK_TYPE_AFTER_EACH, function (e, eSuite) {\n          self.suite = origSuite;\n          next(e, eSuite);\n        });\n      }\n\n      if (err) {\n        return hookErr(err, errSuite, false);\n      }\n\n      self.currentRunnable = self.test;\n      self.runTest(function (err) {\n        test = self.test; // conditional skip within it\n\n        if (test.pending) {\n          if (self.forbidPending) {\n            test.isPending = alwaysFalse;\n            self.fail(test, new Error('Pending test forbidden'));\n            delete test.isPending;\n          } else {\n            self.emit(constants.EVENT_TEST_PENDING, test);\n          }\n\n          self.emit(constants.EVENT_TEST_END, test);\n          return self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n        } else if (err) {\n          var retry = test.currentRetry();\n\n          if (retry < test.retries()) {\n            var clonedTest = test.clone();\n            clonedTest.currentRetry(retry + 1);\n            tests.unshift(clonedTest);\n            self.emit(constants.EVENT_TEST_RETRY, test, err); // Early return + hook trigger so that it doesn't\n            // increment the count wrong\n\n            return self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n          } else {\n            self.fail(test, err);\n          }\n\n          self.emit(constants.EVENT_TEST_END, test);\n          return self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n        }\n\n        test.state = STATE_PASSED;\n        self.emit(constants.EVENT_TEST_PASS, test);\n        self.emit(constants.EVENT_TEST_END, test);\n        self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n      });\n    });\n  }\n\n  this.next = next;\n  this.hookErr = hookErr;\n  next();\n};\n\nfunction alwaysFalse() {\n  return false;\n}\n/**\n * Run the given `suite` and invoke the callback `fn()` when complete.\n *\n * @private\n * @param {Suite} suite\n * @param {Function} fn\n */\n\n\nRunner.prototype.runSuite = function (suite, fn) {\n  var i = 0;\n  var self = this;\n  var total = this.grepTotal(suite);\n  debug('runSuite(): running %s', suite.fullTitle());\n\n  if (!total || self.failures && suite._bail) {\n    debug('runSuite(): bailing');\n    return fn();\n  }\n\n  this.emit(constants.EVENT_SUITE_BEGIN, this.suite = suite);\n\n  function next(errSuite) {\n    if (errSuite) {\n      // current suite failed on a hook from errSuite\n      if (errSuite === suite) {\n        // if errSuite is current suite\n        // continue to the next sibling suite\n        return done();\n      } // errSuite is among the parents of current suite\n      // stop execution of errSuite and all sub-suites\n\n\n      return done(errSuite);\n    }\n\n    if (self._abort) {\n      return done();\n    }\n\n    var curr = suite.suites[i++];\n\n    if (!curr) {\n      return done();\n    } // Avoid grep neglecting large number of tests causing a\n    // huge recursive loop and thus a maximum call stack error.\n    // See comment in `this.runTests()` for more information.\n\n\n    if (self._grep !== self._defaultGrep) {\n      Runner.immediately(function () {\n        self.runSuite(curr, next);\n      });\n    } else {\n      self.runSuite(curr, next);\n    }\n  }\n\n  function done(errSuite) {\n    self.suite = suite;\n    self.nextSuite = next; // remove reference to test\n\n    delete self.test;\n    self.hook(HOOK_TYPE_AFTER_ALL, function () {\n      self.emit(constants.EVENT_SUITE_END, suite);\n      fn(errSuite);\n    });\n  }\n\n  this.nextSuite = next;\n  this.hook(HOOK_TYPE_BEFORE_ALL, function (err) {\n    if (err) {\n      return done();\n    }\n\n    self.runTests(suite, next);\n  });\n};\n/**\n * Handle uncaught exceptions within runner.\n *\n * This function is bound to the instance as `Runner#uncaught` at instantiation\n * time. It's intended to be listening on the `Process.uncaughtException` event.\n * In order to not leak EE listeners, we need to ensure no more than a single\n * `uncaughtException` listener exists per `Runner`.  The only way to do\n * this--because this function needs the context (and we don't have lambdas)--is\n * to use `Function.prototype.bind`. We need strict equality to unregister and\n * _only_ unregister the _one_ listener we set from the\n * `Process.uncaughtException` event; would be poor form to just remove\n * everything. See {@link Runner#run} for where the event listener is registered\n * and unregistered.\n * @param {Error} err - Some uncaught error\n * @private\n */\n\n\nRunner.prototype._uncaught = function (err) {\n  // this is defensive to prevent future developers from mis-calling this function.\n  // it's more likely that it'd be called with the incorrect context--say, the global\n  // `process` object--than it would to be called with a context that is not a \"subclass\"\n  // of `Runner`.\n  if (!(this instanceof Runner)) {\n    throw createFatalError('Runner#uncaught() called with invalid context', this);\n  }\n\n  if (err instanceof Pending) {\n    debug('uncaught(): caught a Pending');\n    return;\n  } // browser does not exit script when throwing in global.onerror()\n\n\n  if (this.allowUncaught && !process.browser) {\n    debug('uncaught(): bubbling exception due to --allow-uncaught');\n    throw err;\n  }\n\n  if (this.state === constants.STATE_STOPPED) {\n    debug('uncaught(): throwing after run has completed!');\n    throw err;\n  }\n\n  if (err) {\n    debug('uncaught(): got truthy exception %O', err);\n  } else {\n    debug('uncaught(): undefined/falsy exception');\n    err = createInvalidExceptionError('Caught falsy/undefined exception which would otherwise be uncaught. No stack trace found; try a debugger', err);\n  }\n\n  if (!isError(err)) {\n    err = thrown2Error(err);\n    debug('uncaught(): converted \"error\" %o to Error', err);\n  }\n\n  err.uncaught = true;\n  var runnable = this.currentRunnable;\n\n  if (!runnable) {\n    runnable = new Runnable('Uncaught error outside test suite');\n    debug('uncaught(): no current Runnable; created a phony one');\n    runnable.parent = this.suite;\n\n    if (this.state === constants.STATE_RUNNING) {\n      debug('uncaught(): failing gracefully');\n      this.fail(runnable, err);\n    } else {\n      // Can't recover from this failure\n      debug('uncaught(): test run has not yet started; unrecoverable');\n      this.emit(constants.EVENT_RUN_BEGIN);\n      this.fail(runnable, err);\n      this.emit(constants.EVENT_RUN_END);\n    }\n\n    return;\n  }\n\n  runnable.clearTimeout();\n\n  if (runnable.isFailed()) {\n    debug('uncaught(): Runnable has already failed'); // Ignore error if already failed\n\n    return;\n  } else if (runnable.isPending()) {\n    debug('uncaught(): pending Runnable wound up failing!'); // report 'pending test' retrospectively as failed\n\n    runnable.isPending = alwaysFalse;\n    this.fail(runnable, err);\n    delete runnable.isPending;\n    return;\n  } // we cannot recover gracefully if a Runnable has already passed\n  // then fails asynchronously\n\n\n  if (runnable.isPassed()) {\n    debug('uncaught(): Runnable has already passed; bailing gracefully');\n    this.fail(runnable, err);\n    this.abort();\n  } else {\n    debug('uncaught(): forcing Runnable to complete with Error');\n    return runnable.callback(err);\n  }\n};\n/**\n * Run the root suite and invoke `fn(failures)`\n * on completion.\n *\n * @public\n * @memberof Runner\n * @param {Function} fn\n * @return {Runner} Runner instance.\n */\n\n\nRunner.prototype.run = function (fn) {\n  var self = this;\n  var rootSuite = this.suite;\n\n  fn = fn || function () {};\n\n  function start() {\n    debug('run(): starting'); // If there is an `only` filter\n\n    if (rootSuite.hasOnly()) {\n      rootSuite.filterOnly();\n      debug('run(): filtered exclusive Runnables');\n    }\n\n    self.state = constants.STATE_RUNNING;\n\n    if (self._delay) {\n      self.emit(constants.EVENT_DELAY_END);\n      debug('run(): \"delay\" ended');\n    }\n\n    debug('run(): emitting %s', constants.EVENT_RUN_BEGIN);\n    self.emit(constants.EVENT_RUN_BEGIN);\n    debug('run(): emitted %s', constants.EVENT_RUN_BEGIN);\n    self.runSuite(rootSuite, function () {\n      debug('run(): root suite completed; emitting %s', constants.EVENT_RUN_END);\n      self.emit(constants.EVENT_RUN_END);\n      debug('run(): emitted %s', constants.EVENT_RUN_END);\n    });\n  } // references cleanup to avoid memory leaks\n\n\n  if (this._opts.cleanReferencesAfterRun) {\n    this.on(constants.EVENT_SUITE_END, function (suite) {\n      suite.cleanReferences();\n    });\n  } // callback\n\n\n  this.on(constants.EVENT_RUN_END, function () {\n    self.state = constants.STATE_STOPPED;\n    debug(constants.EVENT_RUN_END);\n    debug('run(): emitted %s', constants.EVENT_RUN_END);\n    fn(self.failures);\n  });\n\n  self._removeEventListener(process, 'uncaughtException', self.uncaught);\n\n  self._addEventListener(process, 'uncaughtException', self.uncaught);\n\n  if (this._delay) {\n    // for reporters, I guess.\n    // might be nice to debounce some dots while we wait.\n    this.emit(constants.EVENT_DELAY_BEGIN, rootSuite);\n    rootSuite.once(EVENT_ROOT_SUITE_RUN, start);\n    debug('run(): waiting for green light due to --delay');\n  } else {\n    Runner.immediately(function () {\n      start();\n    });\n  }\n\n  return this;\n};\n/**\n * Cleanly abort execution.\n *\n * @memberof Runner\n * @public\n * @return {Runner} Runner instance.\n */\n\n\nRunner.prototype.abort = function () {\n  debug('abort(): aborting');\n  this._abort = true;\n  return this;\n};\n/**\n * Filter leaks with the given globals flagged as `ok`.\n *\n * @private\n * @param {Array} ok\n * @param {Array} globals\n * @return {Array}\n */\n\n\nfunction filterLeaks(ok, globals) {\n  return globals.filter(function (key) {\n    // Firefox and Chrome exposes iframes as index inside the window object\n    if (/^\\d+/.test(key)) {\n      return false;\n    } // in firefox\n    // if runner runs in an iframe, this iframe's window.getInterface method\n    // not init at first it is assigned in some seconds\n\n\n    if (global.navigator && /^getInterface/.test(key)) {\n      return false;\n    } // an iframe could be approached by window[iframeIndex]\n    // in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak\n\n\n    if (global.navigator && /^\\d+/.test(key)) {\n      return false;\n    } // Opera and IE expose global variables for HTML element IDs (issue #243)\n\n\n    if (/^mocha-/.test(key)) {\n      return false;\n    }\n\n    var matched = ok.filter(function (ok) {\n      if (~ok.indexOf('*')) {\n        return key.indexOf(ok.split('*')[0]) === 0;\n      }\n\n      return key === ok;\n    });\n    return !matched.length && (!global.navigator || key !== 'onerror');\n  });\n}\n/**\n * Check if argument is an instance of Error object or a duck-typed equivalent.\n *\n * @private\n * @param {Object} err - object to check\n * @param {string} err.message - error message\n * @returns {boolean}\n */\n\n\nfunction isError(err) {\n  return err instanceof Error || err && typeof err.message === 'string';\n}\n/**\n *\n * Converts thrown non-extensible type into proper Error.\n *\n * @private\n * @param {*} thrown - Non-extensible type thrown by code\n * @return {Error}\n */\n\n\nfunction thrown2Error(err) {\n  return new Error('the ' + type(err) + ' ' + stringify(err) + ' was thrown, throw an Error :)');\n}\n\nRunner.constants = constants;\n/**\n * Node.js' `EventEmitter`\n * @external EventEmitter\n * @see {@link https://nodejs.org/api/events.html#events_class_eventemitter}\n */","map":{"version":3,"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/mocha/lib/runner.js"],"names":["util","require","EventEmitter","Pending","utils","inherits","debug","Runnable","Suite","HOOK_TYPE_BEFORE_EACH","constants","HOOK_TYPE_AFTER_EACH","HOOK_TYPE_AFTER_ALL","HOOK_TYPE_BEFORE_ALL","EVENT_ROOT_SUITE_RUN","STATE_FAILED","STATE_PASSED","dQuote","sQuote","stackFilter","stackTraceFilter","stringify","type","errors","createInvalidExceptionError","createUnsupportedError","createFatalError","globals","defineConstants","EVENT_HOOK_BEGIN","EVENT_HOOK_END","EVENT_RUN_BEGIN","EVENT_DELAY_BEGIN","EVENT_DELAY_END","EVENT_RUN_END","EVENT_SUITE_BEGIN","EVENT_SUITE_END","EVENT_TEST_BEGIN","EVENT_TEST_END","EVENT_TEST_FAIL","EVENT_TEST_PASS","EVENT_TEST_PENDING","EVENT_TEST_RETRY","STATE_IDLE","STATE_RUNNING","STATE_STOPPED","module","exports","Runner","suite","opts","undefined","_delay","delay","self","_globals","_abort","_opts","state","total","failures","_eventListeners","on","test","retriedTest","parent","idx","tests","indexOf","checkGlobals","hook","_defaultGrep","grep","globalProps","uncaught","_uncaught","bind","immediately","global","setImmediate","process","nextTick","prototype","_addEventListener","target","eventName","listener","push","_removeEventListener","eventListenerIndex","i","length","eventListenerDescriptor","removedListener","splice","removeListener","dispose","removeAllListeners","forEach","re","invert","_grep","_invert","grepTotal","eachTest","match","fullTitle","props","Object","keys","arr","arguments","concat","checkLeaks","ok","leaks","_allowedGlobals","prevGlobalsLength","filterLeaks","msg","error","Error","format","map","join","fail","err","isPending","code","MULTIPLE_DONE","isError","thrown2Error","stack","fullStackTrace","ignore","emit","failHook","originalTitle","title","ctx","currentTest","parentTitle","root","name","fn","hooks","getHooks","next","currentRunnable","allowUncaught","listeners","run","testError","pending","suites","errForbid","orig","errSuite","pop","hookUp","parents","reverse","hookDown","runTest","asyncOnly","runTests","slice","hookErr","_","after","err2","errSuite2","_bail","shift","forbidPending","alwaysFalse","origSuite","e","eSuite","retry","currentRetry","retries","clonedTest","clone","unshift","runSuite","done","curr","nextSuite","browser","runnable","clearTimeout","isFailed","isPassed","abort","callback","rootSuite","start","hasOnly","filterOnly","cleanReferencesAfterRun","cleanReferences","once","filter","key","navigator","matched","split","message"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * Module dependencies.\n */\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nvar Pending = require('./pending');\nvar utils = require('./utils');\nvar inherits = utils.inherits;\nvar debug = require('debug')('mocha:runner');\nvar Runnable = require('./runnable');\nvar Suite = require('./suite');\nvar HOOK_TYPE_BEFORE_EACH = Suite.constants.HOOK_TYPE_BEFORE_EACH;\nvar HOOK_TYPE_AFTER_EACH = Suite.constants.HOOK_TYPE_AFTER_EACH;\nvar HOOK_TYPE_AFTER_ALL = Suite.constants.HOOK_TYPE_AFTER_ALL;\nvar HOOK_TYPE_BEFORE_ALL = Suite.constants.HOOK_TYPE_BEFORE_ALL;\nvar EVENT_ROOT_SUITE_RUN = Suite.constants.EVENT_ROOT_SUITE_RUN;\nvar STATE_FAILED = Runnable.constants.STATE_FAILED;\nvar STATE_PASSED = Runnable.constants.STATE_PASSED;\nvar dQuote = utils.dQuote;\nvar sQuote = utils.sQuote;\nvar stackFilter = utils.stackTraceFilter();\nvar stringify = utils.stringify;\nvar type = utils.type;\nvar errors = require('./errors');\nvar createInvalidExceptionError = errors.createInvalidExceptionError;\nvar createUnsupportedError = errors.createUnsupportedError;\nvar createFatalError = errors.createFatalError;\n\n/**\n * Non-enumerable globals.\n * @readonly\n */\nvar globals = [\n  'setTimeout',\n  'clearTimeout',\n  'setInterval',\n  'clearInterval',\n  'XMLHttpRequest',\n  'Date',\n  'setImmediate',\n  'clearImmediate'\n];\n\nvar constants = utils.defineConstants(\n  /**\n   * {@link Runner}-related constants.\n   * @public\n   * @memberof Runner\n   * @readonly\n   * @alias constants\n   * @static\n   * @enum {string}\n   */\n  {\n    /**\n     * Emitted when {@link Hook} execution begins\n     */\n    EVENT_HOOK_BEGIN: 'hook',\n    /**\n     * Emitted when {@link Hook} execution ends\n     */\n    EVENT_HOOK_END: 'hook end',\n    /**\n     * Emitted when Root {@link Suite} execution begins (all files have been parsed and hooks/tests are ready for execution)\n     */\n    EVENT_RUN_BEGIN: 'start',\n    /**\n     * Emitted when Root {@link Suite} execution has been delayed via `delay` option\n     */\n    EVENT_DELAY_BEGIN: 'waiting',\n    /**\n     * Emitted when delayed Root {@link Suite} execution is triggered by user via `global.run()`\n     */\n    EVENT_DELAY_END: 'ready',\n    /**\n     * Emitted when Root {@link Suite} execution ends\n     */\n    EVENT_RUN_END: 'end',\n    /**\n     * Emitted when {@link Suite} execution begins\n     */\n    EVENT_SUITE_BEGIN: 'suite',\n    /**\n     * Emitted when {@link Suite} execution ends\n     */\n    EVENT_SUITE_END: 'suite end',\n    /**\n     * Emitted when {@link Test} execution begins\n     */\n    EVENT_TEST_BEGIN: 'test',\n    /**\n     * Emitted when {@link Test} execution ends\n     */\n    EVENT_TEST_END: 'test end',\n    /**\n     * Emitted when {@link Test} execution fails\n     */\n    EVENT_TEST_FAIL: 'fail',\n    /**\n     * Emitted when {@link Test} execution succeeds\n     */\n    EVENT_TEST_PASS: 'pass',\n    /**\n     * Emitted when {@link Test} becomes pending\n     */\n    EVENT_TEST_PENDING: 'pending',\n    /**\n     * Emitted when {@link Test} execution has failed, but will retry\n     */\n    EVENT_TEST_RETRY: 'retry',\n    /**\n     * Initial state of Runner\n     */\n    STATE_IDLE: 'idle',\n    /**\n     * State set to this value when the Runner has started running\n     */\n    STATE_RUNNING: 'running',\n    /**\n     * State set to this value when the Runner has stopped\n     */\n    STATE_STOPPED: 'stopped'\n  }\n);\n\nmodule.exports = Runner;\n\n/**\n * Initialize a `Runner` at the Root {@link Suite}, which represents a hierarchy of {@link Suite|Suites} and {@link Test|Tests}.\n *\n * @extends external:EventEmitter\n * @public\n * @class\n * @param {Suite} suite - Root suite\n * @param {Object|boolean} [opts] - Options. If `boolean`, whether or not to delay execution of root suite until ready (for backwards compatibility).\n * @param {boolean} [opts.delay] - Whether to delay execution of root suite until ready.\n * @param {boolean} [opts.cleanReferencesAfterRun] - Whether to clean references to test fns and hooks when a suite is done.\n */\nfunction Runner(suite, opts) {\n  if (opts === undefined) {\n    opts = {};\n  }\n  if (typeof opts === 'boolean') {\n    this._delay = opts;\n    opts = {};\n  } else {\n    this._delay = opts.delay;\n  }\n  var self = this;\n  this._globals = [];\n  this._abort = false;\n  this.suite = suite;\n  this._opts = opts;\n  this.state = constants.STATE_IDLE;\n  this.total = suite.total();\n  this.failures = 0;\n  this._eventListeners = [];\n  this.on(constants.EVENT_TEST_END, function(test) {\n    if (test.type === 'test' && test.retriedTest() && test.parent) {\n      var idx =\n        test.parent.tests && test.parent.tests.indexOf(test.retriedTest());\n      if (idx > -1) test.parent.tests[idx] = test;\n    }\n    self.checkGlobals(test);\n  });\n  this.on(constants.EVENT_HOOK_END, function(hook) {\n    self.checkGlobals(hook);\n  });\n  this._defaultGrep = /.*/;\n  this.grep(this._defaultGrep);\n  this.globals(this.globalProps());\n\n  this.uncaught = this._uncaught.bind(this);\n}\n\n/**\n * Wrapper for setImmediate, process.nextTick, or browser polyfill.\n *\n * @param {Function} fn\n * @private\n */\nRunner.immediately = global.setImmediate || process.nextTick;\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\ninherits(Runner, EventEmitter);\n\n/**\n * Replacement for `target.on(eventName, listener)` that does bookkeeping to remove them when this runner instance is disposed.\n * @param {EventEmitter} target - The `EventEmitter`\n * @param {string} eventName - The event name\n * @param {string} fn - Listener function\n */\nRunner.prototype._addEventListener = function(target, eventName, listener) {\n  target.on(eventName, listener);\n  this._eventListeners.push([target, eventName, listener]);\n};\n\n/**\n * Replacement for `target.removeListener(eventName, listener)` that also updates the bookkeeping.\n * @param {EventEmitter} target - The `EventEmitter`\n * @param {string} eventName - The event anme\n * @param {function} listener - Listener function\n */\nRunner.prototype._removeEventListener = function(target, eventName, listener) {\n  var eventListenerIndex = -1;\n  for (var i = 0; i < this._eventListeners.length; i++) {\n    var eventListenerDescriptor = this._eventListeners[i];\n    if (\n      eventListenerDescriptor[0] === target &&\n      eventListenerDescriptor[1] === eventName &&\n      eventListenerDescriptor[2] === listener\n    ) {\n      eventListenerIndex = i;\n      break;\n    }\n  }\n  if (eventListenerIndex !== -1) {\n    var removedListener = this._eventListeners.splice(eventListenerIndex, 1)[0];\n    removedListener[0].removeListener(removedListener[1], removedListener[2]);\n  }\n};\n\n/**\n * Removes all event handlers set during a run on this instance.\n * Remark: this does _not_ clean/dispose the tests or suites themselves.\n */\nRunner.prototype.dispose = function() {\n  this.removeAllListeners();\n  this._eventListeners.forEach(function(eventListenerDescriptor) {\n    eventListenerDescriptor[0].removeListener(\n      eventListenerDescriptor[1],\n      eventListenerDescriptor[2]\n    );\n  });\n};\n\n/**\n * Run tests with full titles matching `re`. Updates runner.total\n * with number of tests matched.\n *\n * @public\n * @memberof Runner\n * @param {RegExp} re\n * @param {boolean} invert\n * @return {Runner} Runner instance.\n */\nRunner.prototype.grep = function(re, invert) {\n  debug('grep(): setting to %s', re);\n  this._grep = re;\n  this._invert = invert;\n  this.total = this.grepTotal(this.suite);\n  return this;\n};\n\n/**\n * Returns the number of tests matching the grep search for the\n * given suite.\n *\n * @memberof Runner\n * @public\n * @param {Suite} suite\n * @return {number}\n */\nRunner.prototype.grepTotal = function(suite) {\n  var self = this;\n  var total = 0;\n\n  suite.eachTest(function(test) {\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) {\n      match = !match;\n    }\n    if (match) {\n      total++;\n    }\n  });\n\n  return total;\n};\n\n/**\n * Return a list of global properties.\n *\n * @return {Array}\n * @private\n */\nRunner.prototype.globalProps = function() {\n  var props = Object.keys(global);\n\n  // non-enumerables\n  for (var i = 0; i < globals.length; ++i) {\n    if (~props.indexOf(globals[i])) {\n      continue;\n    }\n    props.push(globals[i]);\n  }\n\n  return props;\n};\n\n/**\n * Allow the given `arr` of globals.\n *\n * @public\n * @memberof Runner\n * @param {Array} arr\n * @return {Runner} Runner instance.\n */\nRunner.prototype.globals = function(arr) {\n  if (!arguments.length) {\n    return this._globals;\n  }\n  debug('globals(): setting to %O', arr);\n  this._globals = this._globals.concat(arr);\n  return this;\n};\n\n/**\n * Check for global variable leaks.\n *\n * @private\n */\nRunner.prototype.checkGlobals = function(test) {\n  if (!this.checkLeaks) {\n    return;\n  }\n  var ok = this._globals;\n\n  var globals = this.globalProps();\n  var leaks;\n\n  if (test) {\n    ok = ok.concat(test._allowedGlobals || []);\n  }\n\n  if (this.prevGlobalsLength === globals.length) {\n    return;\n  }\n  this.prevGlobalsLength = globals.length;\n\n  leaks = filterLeaks(ok, globals);\n  this._globals = this._globals.concat(leaks);\n\n  if (leaks.length) {\n    var msg = 'global leak(s) detected: %s';\n    var error = new Error(util.format(msg, leaks.map(sQuote).join(', ')));\n    this.fail(test, error);\n  }\n};\n\n/**\n * Fail the given `test`.\n *\n * @private\n * @param {Test} test\n * @param {Error} err\n */\nRunner.prototype.fail = function(test, err) {\n  if (test.isPending()) {\n    return;\n  }\n  if (this.state === constants.STATE_STOPPED) {\n    if (err.code === errors.constants.MULTIPLE_DONE) {\n      throw err;\n    }\n    throw createFatalError(\n      'Test failed after root suite execution completed!',\n      err\n    );\n  }\n\n  ++this.failures;\n  debug('total number of failures: %d', this.failures);\n  test.state = STATE_FAILED;\n\n  if (!isError(err)) {\n    err = thrown2Error(err);\n  }\n\n  try {\n    err.stack =\n      this.fullStackTrace || !err.stack ? err.stack : stackFilter(err.stack);\n  } catch (ignore) {\n    // some environments do not take kindly to monkeying with the stack\n  }\n\n  this.emit(constants.EVENT_TEST_FAIL, test, err);\n};\n\n/**\n * Fail the given `hook` with `err`.\n *\n * Hook failures work in the following pattern:\n * - If bail, run corresponding `after each` and `after` hooks,\n *   then exit\n * - Failed `before` hook skips all tests in a suite and subsuites,\n *   but jumps to corresponding `after` hook\n * - Failed `before each` hook skips remaining tests in a\n *   suite and jumps to corresponding `after each` hook,\n *   which is run only once\n * - Failed `after` hook does not alter execution order\n * - Failed `after each` hook skips remaining tests in a\n *   suite and subsuites, but executes other `after each`\n *   hooks\n *\n * @private\n * @param {Hook} hook\n * @param {Error} err\n */\nRunner.prototype.failHook = function(hook, err) {\n  hook.originalTitle = hook.originalTitle || hook.title;\n  if (hook.ctx && hook.ctx.currentTest) {\n    hook.title =\n      hook.originalTitle + ' for ' + dQuote(hook.ctx.currentTest.title);\n  } else {\n    var parentTitle;\n    if (hook.parent.title) {\n      parentTitle = hook.parent.title;\n    } else {\n      parentTitle = hook.parent.root ? '{root}' : '';\n    }\n    hook.title = hook.originalTitle + ' in ' + dQuote(parentTitle);\n  }\n\n  this.fail(hook, err);\n};\n\n/**\n * Run hook `name` callbacks and then invoke `fn()`.\n *\n * @private\n * @param {string} name\n * @param {Function} fn\n */\n\nRunner.prototype.hook = function(name, fn) {\n  var suite = this.suite;\n  var hooks = suite.getHooks(name);\n  var self = this;\n\n  function next(i) {\n    var hook = hooks[i];\n    if (!hook) {\n      return fn();\n    }\n    self.currentRunnable = hook;\n\n    if (name === HOOK_TYPE_BEFORE_ALL) {\n      hook.ctx.currentTest = hook.parent.tests[0];\n    } else if (name === HOOK_TYPE_AFTER_ALL) {\n      hook.ctx.currentTest = hook.parent.tests[hook.parent.tests.length - 1];\n    } else {\n      hook.ctx.currentTest = self.test;\n    }\n\n    hook.allowUncaught = self.allowUncaught;\n\n    self.emit(constants.EVENT_HOOK_BEGIN, hook);\n\n    if (!hook.listeners('error').length) {\n      self._addEventListener(hook, 'error', function(err) {\n        self.failHook(hook, err);\n      });\n    }\n\n    hook.run(function(err) {\n      var testError = hook.error();\n      if (testError) {\n        self.fail(self.test, testError);\n      }\n      // conditional skip\n      if (hook.pending) {\n        if (name === HOOK_TYPE_AFTER_EACH) {\n          // TODO define and implement use case\n          if (self.test) {\n            self.test.pending = true;\n          }\n        } else if (name === HOOK_TYPE_BEFORE_EACH) {\n          if (self.test) {\n            self.test.pending = true;\n          }\n          self.emit(constants.EVENT_HOOK_END, hook);\n          hook.pending = false; // activates hook for next test\n          return fn(new Error('abort hookDown'));\n        } else if (name === HOOK_TYPE_BEFORE_ALL) {\n          suite.tests.forEach(function(test) {\n            test.pending = true;\n          });\n          suite.suites.forEach(function(suite) {\n            suite.pending = true;\n          });\n        } else {\n          hook.pending = false;\n          var errForbid = createUnsupportedError('`this.skip` forbidden');\n          self.failHook(hook, errForbid);\n          return fn(errForbid);\n        }\n      } else if (err) {\n        self.failHook(hook, err);\n        // stop executing hooks, notify callee of hook err\n        return fn(err);\n      }\n      self.emit(constants.EVENT_HOOK_END, hook);\n      delete hook.ctx.currentTest;\n      next(++i);\n    });\n  }\n\n  Runner.immediately(function() {\n    next(0);\n  });\n};\n\n/**\n * Run hook `name` for the given array of `suites`\n * in order, and callback `fn(err, errSuite)`.\n *\n * @private\n * @param {string} name\n * @param {Array} suites\n * @param {Function} fn\n */\nRunner.prototype.hooks = function(name, suites, fn) {\n  var self = this;\n  var orig = this.suite;\n\n  function next(suite) {\n    self.suite = suite;\n\n    if (!suite) {\n      self.suite = orig;\n      return fn();\n    }\n\n    self.hook(name, function(err) {\n      if (err) {\n        var errSuite = self.suite;\n        self.suite = orig;\n        return fn(err, errSuite);\n      }\n\n      next(suites.pop());\n    });\n  }\n\n  next(suites.pop());\n};\n\n/**\n * Run hooks from the top level down.\n *\n * @param {String} name\n * @param {Function} fn\n * @private\n */\nRunner.prototype.hookUp = function(name, fn) {\n  var suites = [this.suite].concat(this.parents()).reverse();\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Run hooks from the bottom up.\n *\n * @param {String} name\n * @param {Function} fn\n * @private\n */\nRunner.prototype.hookDown = function(name, fn) {\n  var suites = [this.suite].concat(this.parents());\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Return an array of parent Suites from\n * closest to furthest.\n *\n * @return {Array}\n * @private\n */\nRunner.prototype.parents = function() {\n  var suite = this.suite;\n  var suites = [];\n  while (suite.parent) {\n    suite = suite.parent;\n    suites.push(suite);\n  }\n  return suites;\n};\n\n/**\n * Run the current test and callback `fn(err)`.\n *\n * @param {Function} fn\n * @private\n */\nRunner.prototype.runTest = function(fn) {\n  var self = this;\n  var test = this.test;\n\n  if (!test) {\n    return;\n  }\n\n  if (this.asyncOnly) {\n    test.asyncOnly = true;\n  }\n  this._addEventListener(test, 'error', function(err) {\n    self.fail(test, err);\n  });\n  if (this.allowUncaught) {\n    test.allowUncaught = true;\n    return test.run(fn);\n  }\n  try {\n    test.run(fn);\n  } catch (err) {\n    fn(err);\n  }\n};\n\n/**\n * Run tests in the given `suite` and invoke the callback `fn()` when complete.\n *\n * @private\n * @param {Suite} suite\n * @param {Function} fn\n */\nRunner.prototype.runTests = function(suite, fn) {\n  var self = this;\n  var tests = suite.tests.slice();\n  var test;\n\n  function hookErr(_, errSuite, after) {\n    // before/after Each hook for errSuite failed:\n    var orig = self.suite;\n\n    // for failed 'after each' hook start from errSuite parent,\n    // otherwise start from errSuite itself\n    self.suite = after ? errSuite.parent : errSuite;\n\n    if (self.suite) {\n      // call hookUp afterEach\n      self.hookUp(HOOK_TYPE_AFTER_EACH, function(err2, errSuite2) {\n        self.suite = orig;\n        // some hooks may fail even now\n        if (err2) {\n          return hookErr(err2, errSuite2, true);\n        }\n        // report error suite\n        fn(errSuite);\n      });\n    } else {\n      // there is no need calling other 'after each' hooks\n      self.suite = orig;\n      fn(errSuite);\n    }\n  }\n\n  function next(err, errSuite) {\n    // if we bail after first err\n    if (self.failures && suite._bail) {\n      tests = [];\n    }\n\n    if (self._abort) {\n      return fn();\n    }\n\n    if (err) {\n      return hookErr(err, errSuite, true);\n    }\n\n    // next test\n    test = tests.shift();\n\n    // all done\n    if (!test) {\n      return fn();\n    }\n\n    // grep\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) {\n      match = !match;\n    }\n    if (!match) {\n      // Run immediately only if we have defined a grep. When we\n      // define a grep â€” It can cause maximum callstack error if\n      // the grep is doing a large recursive loop by neglecting\n      // all tests. The run immediately function also comes with\n      // a performance cost. So we don't want to run immediately\n      // if we run the whole test suite, because running the whole\n      // test suite don't do any immediate recursive loops. Thus,\n      // allowing a JS runtime to breathe.\n      if (self._grep !== self._defaultGrep) {\n        Runner.immediately(next);\n      } else {\n        next();\n      }\n      return;\n    }\n\n    // static skip, no hooks are executed\n    if (test.isPending()) {\n      if (self.forbidPending) {\n        test.isPending = alwaysFalse;\n        self.fail(test, new Error('Pending test forbidden'));\n        delete test.isPending;\n      } else {\n        self.emit(constants.EVENT_TEST_PENDING, test);\n      }\n      self.emit(constants.EVENT_TEST_END, test);\n      return next();\n    }\n\n    // execute test and hook(s)\n    self.emit(constants.EVENT_TEST_BEGIN, (self.test = test));\n    self.hookDown(HOOK_TYPE_BEFORE_EACH, function(err, errSuite) {\n      // conditional skip within beforeEach\n      if (test.isPending()) {\n        if (self.forbidPending) {\n          test.isPending = alwaysFalse;\n          self.fail(test, new Error('Pending test forbidden'));\n          delete test.isPending;\n        } else {\n          self.emit(constants.EVENT_TEST_PENDING, test);\n        }\n        self.emit(constants.EVENT_TEST_END, test);\n        // skip inner afterEach hooks below errSuite level\n        var origSuite = self.suite;\n        self.suite = errSuite || self.suite;\n        return self.hookUp(HOOK_TYPE_AFTER_EACH, function(e, eSuite) {\n          self.suite = origSuite;\n          next(e, eSuite);\n        });\n      }\n      if (err) {\n        return hookErr(err, errSuite, false);\n      }\n      self.currentRunnable = self.test;\n      self.runTest(function(err) {\n        test = self.test;\n        // conditional skip within it\n        if (test.pending) {\n          if (self.forbidPending) {\n            test.isPending = alwaysFalse;\n            self.fail(test, new Error('Pending test forbidden'));\n            delete test.isPending;\n          } else {\n            self.emit(constants.EVENT_TEST_PENDING, test);\n          }\n          self.emit(constants.EVENT_TEST_END, test);\n          return self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n        } else if (err) {\n          var retry = test.currentRetry();\n          if (retry < test.retries()) {\n            var clonedTest = test.clone();\n            clonedTest.currentRetry(retry + 1);\n            tests.unshift(clonedTest);\n\n            self.emit(constants.EVENT_TEST_RETRY, test, err);\n\n            // Early return + hook trigger so that it doesn't\n            // increment the count wrong\n            return self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n          } else {\n            self.fail(test, err);\n          }\n          self.emit(constants.EVENT_TEST_END, test);\n          return self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n        }\n\n        test.state = STATE_PASSED;\n        self.emit(constants.EVENT_TEST_PASS, test);\n        self.emit(constants.EVENT_TEST_END, test);\n        self.hookUp(HOOK_TYPE_AFTER_EACH, next);\n      });\n    });\n  }\n\n  this.next = next;\n  this.hookErr = hookErr;\n  next();\n};\n\nfunction alwaysFalse() {\n  return false;\n}\n\n/**\n * Run the given `suite` and invoke the callback `fn()` when complete.\n *\n * @private\n * @param {Suite} suite\n * @param {Function} fn\n */\nRunner.prototype.runSuite = function(suite, fn) {\n  var i = 0;\n  var self = this;\n  var total = this.grepTotal(suite);\n\n  debug('runSuite(): running %s', suite.fullTitle());\n\n  if (!total || (self.failures && suite._bail)) {\n    debug('runSuite(): bailing');\n    return fn();\n  }\n\n  this.emit(constants.EVENT_SUITE_BEGIN, (this.suite = suite));\n\n  function next(errSuite) {\n    if (errSuite) {\n      // current suite failed on a hook from errSuite\n      if (errSuite === suite) {\n        // if errSuite is current suite\n        // continue to the next sibling suite\n        return done();\n      }\n      // errSuite is among the parents of current suite\n      // stop execution of errSuite and all sub-suites\n      return done(errSuite);\n    }\n\n    if (self._abort) {\n      return done();\n    }\n\n    var curr = suite.suites[i++];\n    if (!curr) {\n      return done();\n    }\n\n    // Avoid grep neglecting large number of tests causing a\n    // huge recursive loop and thus a maximum call stack error.\n    // See comment in `this.runTests()` for more information.\n    if (self._grep !== self._defaultGrep) {\n      Runner.immediately(function() {\n        self.runSuite(curr, next);\n      });\n    } else {\n      self.runSuite(curr, next);\n    }\n  }\n\n  function done(errSuite) {\n    self.suite = suite;\n    self.nextSuite = next;\n\n    // remove reference to test\n    delete self.test;\n\n    self.hook(HOOK_TYPE_AFTER_ALL, function() {\n      self.emit(constants.EVENT_SUITE_END, suite);\n      fn(errSuite);\n    });\n  }\n\n  this.nextSuite = next;\n\n  this.hook(HOOK_TYPE_BEFORE_ALL, function(err) {\n    if (err) {\n      return done();\n    }\n    self.runTests(suite, next);\n  });\n};\n\n/**\n * Handle uncaught exceptions within runner.\n *\n * This function is bound to the instance as `Runner#uncaught` at instantiation\n * time. It's intended to be listening on the `Process.uncaughtException` event.\n * In order to not leak EE listeners, we need to ensure no more than a single\n * `uncaughtException` listener exists per `Runner`.  The only way to do\n * this--because this function needs the context (and we don't have lambdas)--is\n * to use `Function.prototype.bind`. We need strict equality to unregister and\n * _only_ unregister the _one_ listener we set from the\n * `Process.uncaughtException` event; would be poor form to just remove\n * everything. See {@link Runner#run} for where the event listener is registered\n * and unregistered.\n * @param {Error} err - Some uncaught error\n * @private\n */\nRunner.prototype._uncaught = function(err) {\n  // this is defensive to prevent future developers from mis-calling this function.\n  // it's more likely that it'd be called with the incorrect context--say, the global\n  // `process` object--than it would to be called with a context that is not a \"subclass\"\n  // of `Runner`.\n  if (!(this instanceof Runner)) {\n    throw createFatalError(\n      'Runner#uncaught() called with invalid context',\n      this\n    );\n  }\n  if (err instanceof Pending) {\n    debug('uncaught(): caught a Pending');\n    return;\n  }\n  // browser does not exit script when throwing in global.onerror()\n  if (this.allowUncaught && !process.browser) {\n    debug('uncaught(): bubbling exception due to --allow-uncaught');\n    throw err;\n  }\n\n  if (this.state === constants.STATE_STOPPED) {\n    debug('uncaught(): throwing after run has completed!');\n    throw err;\n  }\n\n  if (err) {\n    debug('uncaught(): got truthy exception %O', err);\n  } else {\n    debug('uncaught(): undefined/falsy exception');\n    err = createInvalidExceptionError(\n      'Caught falsy/undefined exception which would otherwise be uncaught. No stack trace found; try a debugger',\n      err\n    );\n  }\n\n  if (!isError(err)) {\n    err = thrown2Error(err);\n    debug('uncaught(): converted \"error\" %o to Error', err);\n  }\n  err.uncaught = true;\n\n  var runnable = this.currentRunnable;\n\n  if (!runnable) {\n    runnable = new Runnable('Uncaught error outside test suite');\n    debug('uncaught(): no current Runnable; created a phony one');\n    runnable.parent = this.suite;\n\n    if (this.state === constants.STATE_RUNNING) {\n      debug('uncaught(): failing gracefully');\n      this.fail(runnable, err);\n    } else {\n      // Can't recover from this failure\n      debug('uncaught(): test run has not yet started; unrecoverable');\n      this.emit(constants.EVENT_RUN_BEGIN);\n      this.fail(runnable, err);\n      this.emit(constants.EVENT_RUN_END);\n    }\n\n    return;\n  }\n\n  runnable.clearTimeout();\n\n  if (runnable.isFailed()) {\n    debug('uncaught(): Runnable has already failed');\n    // Ignore error if already failed\n    return;\n  } else if (runnable.isPending()) {\n    debug('uncaught(): pending Runnable wound up failing!');\n    // report 'pending test' retrospectively as failed\n    runnable.isPending = alwaysFalse;\n    this.fail(runnable, err);\n    delete runnable.isPending;\n    return;\n  }\n\n  // we cannot recover gracefully if a Runnable has already passed\n  // then fails asynchronously\n  if (runnable.isPassed()) {\n    debug('uncaught(): Runnable has already passed; bailing gracefully');\n    this.fail(runnable, err);\n    this.abort();\n  } else {\n    debug('uncaught(): forcing Runnable to complete with Error');\n    return runnable.callback(err);\n  }\n};\n\n/**\n * Run the root suite and invoke `fn(failures)`\n * on completion.\n *\n * @public\n * @memberof Runner\n * @param {Function} fn\n * @return {Runner} Runner instance.\n */\nRunner.prototype.run = function(fn) {\n  var self = this;\n  var rootSuite = this.suite;\n\n  fn = fn || function() {};\n\n  function start() {\n    debug('run(): starting');\n    // If there is an `only` filter\n    if (rootSuite.hasOnly()) {\n      rootSuite.filterOnly();\n      debug('run(): filtered exclusive Runnables');\n    }\n    self.state = constants.STATE_RUNNING;\n    if (self._delay) {\n      self.emit(constants.EVENT_DELAY_END);\n      debug('run(): \"delay\" ended');\n    }\n    debug('run(): emitting %s', constants.EVENT_RUN_BEGIN);\n    self.emit(constants.EVENT_RUN_BEGIN);\n    debug('run(): emitted %s', constants.EVENT_RUN_BEGIN);\n\n    self.runSuite(rootSuite, function() {\n      debug(\n        'run(): root suite completed; emitting %s',\n        constants.EVENT_RUN_END\n      );\n      self.emit(constants.EVENT_RUN_END);\n      debug('run(): emitted %s', constants.EVENT_RUN_END);\n    });\n  }\n\n  // references cleanup to avoid memory leaks\n  if (this._opts.cleanReferencesAfterRun) {\n    this.on(constants.EVENT_SUITE_END, function(suite) {\n      suite.cleanReferences();\n    });\n  }\n\n  // callback\n  this.on(constants.EVENT_RUN_END, function() {\n    self.state = constants.STATE_STOPPED;\n    debug(constants.EVENT_RUN_END);\n    debug('run(): emitted %s', constants.EVENT_RUN_END);\n    fn(self.failures);\n  });\n\n  self._removeEventListener(process, 'uncaughtException', self.uncaught);\n  self._addEventListener(process, 'uncaughtException', self.uncaught);\n\n  if (this._delay) {\n    // for reporters, I guess.\n    // might be nice to debounce some dots while we wait.\n    this.emit(constants.EVENT_DELAY_BEGIN, rootSuite);\n    rootSuite.once(EVENT_ROOT_SUITE_RUN, start);\n    debug('run(): waiting for green light due to --delay');\n  } else {\n    Runner.immediately(function() {\n      start();\n    });\n  }\n\n  return this;\n};\n\n/**\n * Cleanly abort execution.\n *\n * @memberof Runner\n * @public\n * @return {Runner} Runner instance.\n */\nRunner.prototype.abort = function() {\n  debug('abort(): aborting');\n  this._abort = true;\n\n  return this;\n};\n\n/**\n * Filter leaks with the given globals flagged as `ok`.\n *\n * @private\n * @param {Array} ok\n * @param {Array} globals\n * @return {Array}\n */\nfunction filterLeaks(ok, globals) {\n  return globals.filter(function(key) {\n    // Firefox and Chrome exposes iframes as index inside the window object\n    if (/^\\d+/.test(key)) {\n      return false;\n    }\n\n    // in firefox\n    // if runner runs in an iframe, this iframe's window.getInterface method\n    // not init at first it is assigned in some seconds\n    if (global.navigator && /^getInterface/.test(key)) {\n      return false;\n    }\n\n    // an iframe could be approached by window[iframeIndex]\n    // in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak\n    if (global.navigator && /^\\d+/.test(key)) {\n      return false;\n    }\n\n    // Opera and IE expose global variables for HTML element IDs (issue #243)\n    if (/^mocha-/.test(key)) {\n      return false;\n    }\n\n    var matched = ok.filter(function(ok) {\n      if (~ok.indexOf('*')) {\n        return key.indexOf(ok.split('*')[0]) === 0;\n      }\n      return key === ok;\n    });\n    return !matched.length && (!global.navigator || key !== 'onerror');\n  });\n}\n\n/**\n * Check if argument is an instance of Error object or a duck-typed equivalent.\n *\n * @private\n * @param {Object} err - object to check\n * @param {string} err.message - error message\n * @returns {boolean}\n */\nfunction isError(err) {\n  return err instanceof Error || (err && typeof err.message === 'string');\n}\n\n/**\n *\n * Converts thrown non-extensible type into proper Error.\n *\n * @private\n * @param {*} thrown - Non-extensible type thrown by code\n * @return {Error}\n */\nfunction thrown2Error(err) {\n  return new Error(\n    'the ' + type(err) + ' ' + stringify(err) + ' was thrown, throw an Error :)'\n  );\n}\n\nRunner.constants = constants;\n\n/**\n * Node.js' `EventEmitter`\n * @external EventEmitter\n * @see {@link https://nodejs.org/api/events.html#events_class_eventemitter}\n */\n"]},"metadata":{},"sourceType":"script"}