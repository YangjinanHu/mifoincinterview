{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getClosestCallerPackage = void 0;\n\nconst find_up_1 = __importDefault(require(\"find-up\"));\n\nconst path_1 = __importDefault(require(\"path\"));\n\nfunction findClosestPackageJson(file) {\n  return find_up_1.default.sync(\"package.json\", {\n    cwd: path_1.default.dirname(file)\n  });\n}\n/**\n * Returns the name of the closest package in the callstack that isn't this.\n */\n\n\nfunction getClosestCallerPackage() {\n  const previousPrepareStackTrace = Error.prepareStackTrace;\n\n  Error.prepareStackTrace = (e, s) => s;\n\n  const error = new Error();\n  const stack = error.stack;\n  Error.prepareStackTrace = previousPrepareStackTrace;\n  const currentPackage = findClosestPackageJson(__filename);\n\n  for (const callSite of stack) {\n    const fileName = callSite.getFileName();\n\n    if (fileName !== null && path_1.default.isAbsolute(fileName)) {\n      const callerPackage = findClosestPackageJson(fileName);\n\n      if (callerPackage === currentPackage) {\n        continue;\n      }\n\n      if (callerPackage === null) {\n        return undefined;\n      }\n\n      return require(callerPackage).name;\n    }\n  }\n\n  return undefined;\n}\n\nexports.getClosestCallerPackage = getClosestCallerPackage;","map":{"version":3,"mappings":";;;;;;;;;;;;;AAAA;;AACA;;AAEA,SAASA,sBAAT,CAAgCC,IAAhC,EAA4C;AAC1C,SAAOC,kBAAOC,IAAP,CAAY,cAAZ,EAA4B;AAAEC,OAAG,EAAEC,eAAKC,OAAL,CAAaL,IAAb;AAAP,GAA5B,CAAP;AACD;AAED;;;;;AAGA,SAAgBM,uBAAhB,GAAuC;AACrC,QAAMC,yBAAyB,GAAGC,KAAK,CAACC,iBAAxC;;AAEAD,OAAK,CAACC,iBAAN,GAA0B,CAACC,CAAD,EAAIC,CAAJ,KAAUA,CAApC;;AAEA,QAAMC,KAAK,GAAG,IAAIJ,KAAJ,EAAd;AACA,QAAMK,KAAK,GAAsBD,KAAK,CAACC,KAAvC;AAEAL,OAAK,CAACC,iBAAN,GAA0BF,yBAA1B;AAEA,QAAMO,cAAc,GAAGf,sBAAsB,CAACgB,UAAD,CAA7C;;AAEA,OAAK,MAAMC,QAAX,IAAuBH,KAAvB,EAA8B;AAC5B,UAAMI,QAAQ,GAAGD,QAAQ,CAACE,WAAT,EAAjB;;AACA,QAAID,QAAQ,KAAK,IAAb,IAAqBb,eAAKe,UAAL,CAAgBF,QAAhB,CAAzB,EAAoD;AAClD,YAAMG,aAAa,GAAGrB,sBAAsB,CAACkB,QAAD,CAA5C;;AAEA,UAAIG,aAAa,KAAKN,cAAtB,EAAsC;AACpC;AACD;;AAED,UAAIM,aAAa,KAAK,IAAtB,EAA4B;AAC1B,eAAOC,SAAP;AACD;;AAED,aAAOC,OAAO,CAACF,aAAD,CAAP,CAAuBG,IAA9B;AACD;AACF;;AAED,SAAOF,SAAP;AACD;;AA9BDG","names":["findClosestPackageJson","file","find_up_1","sync","cwd","path_1","dirname","getClosestCallerPackage","previousPrepareStackTrace","Error","prepareStackTrace","e","s","error","stack","currentPackage","__filename","callSite","fileName","getFileName","isAbsolute","callerPackage","undefined","require","name","exports"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/internal/util/caller-package.ts"],"sourcesContent":["import findup from \"find-up\";\nimport path from \"path\";\n\nfunction findClosestPackageJson(file: string): string | null {\n  return findup.sync(\"package.json\", { cwd: path.dirname(file) });\n}\n\n/**\n * Returns the name of the closest package in the callstack that isn't this.\n */\nexport function getClosestCallerPackage(): string | undefined {\n  const previousPrepareStackTrace = Error.prepareStackTrace;\n\n  Error.prepareStackTrace = (e, s) => s;\n\n  const error = new Error();\n  const stack: NodeJS.CallSite[] = error.stack as any;\n\n  Error.prepareStackTrace = previousPrepareStackTrace;\n\n  const currentPackage = findClosestPackageJson(__filename)!;\n\n  for (const callSite of stack) {\n    const fileName = callSite.getFileName();\n    if (fileName !== null && path.isAbsolute(fileName)) {\n      const callerPackage = findClosestPackageJson(fileName);\n\n      if (callerPackage === currentPackage) {\n        continue;\n      }\n\n      if (callerPackage === null) {\n        return undefined;\n      }\n\n      return require(callerPackage).name;\n    }\n  }\n\n  return undefined;\n}\n"]},"metadata":{},"sourceType":"script"}