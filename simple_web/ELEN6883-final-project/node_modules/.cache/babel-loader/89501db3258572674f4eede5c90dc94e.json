{"ast":null,"code":"/**\n * A doubly linked list-based Least Recently Used (LRU) cache. Will keep most\n * recently used items while discarding least recently used items when its limit\n * is reached.\n *\n * Licensed under MIT. Copyright (c) 2010 Rasmus Andersson <http://hunch.se/>\n * See README.md for details.\n *\n * Illustration of the design:\n *\n *       entry             entry             entry             entry\n *       ______            ______            ______            ______\n *      | head |.newer => |      |.newer => |      |.newer => | tail |\n *      |  A   |          |  B   |          |  C   |          |  D   |\n *      |______| <= older.|______| <= older.|______| <= older.|______|\n *\n *  removed  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  added\n */\n(function (g, f) {\n  const e = typeof exports == 'object' ? exports : typeof g == 'object' ? g : {};\n  f(e);\n\n  if (typeof define == 'function' && define.amd) {\n    define('lru', e);\n  }\n})(this, function (exports) {\n  const NEWER = Symbol('newer');\n  const OLDER = Symbol('older');\n\n  function LRUMap(limit, entries) {\n    if (typeof limit !== 'number') {\n      // called as (entries)\n      entries = limit;\n      limit = 0;\n    }\n\n    this.size = 0;\n    this.limit = limit;\n    this.oldest = this.newest = undefined;\n    this._keymap = new Map();\n\n    if (entries) {\n      this.assign(entries);\n\n      if (limit < 1) {\n        this.limit = this.size;\n      }\n    }\n  }\n\n  exports.LRUMap = LRUMap;\n\n  function Entry(key, value) {\n    this.key = key;\n    this.value = value;\n    this[NEWER] = undefined;\n    this[OLDER] = undefined;\n  }\n\n  LRUMap.prototype._markEntryAsUsed = function (entry) {\n    if (entry === this.newest) {\n      // Already the most recenlty used entry, so no need to update the list\n      return;\n    } // HEAD--------------TAIL\n    //   <.older   .newer>\n    //  <--- add direction --\n    //   A  B  C  <D>  E\n\n\n    if (entry[NEWER]) {\n      if (entry === this.oldest) {\n        this.oldest = entry[NEWER];\n      }\n\n      entry[NEWER][OLDER] = entry[OLDER]; // C <-- E.\n    }\n\n    if (entry[OLDER]) {\n      entry[OLDER][NEWER] = entry[NEWER]; // C. --> E\n    }\n\n    entry[NEWER] = undefined; // D --x\n\n    entry[OLDER] = this.newest; // D. --> E\n\n    if (this.newest) {\n      this.newest[NEWER] = entry; // E. <-- D\n    }\n\n    this.newest = entry;\n  };\n\n  LRUMap.prototype.assign = function (entries) {\n    let entry,\n        limit = this.limit || Number.MAX_VALUE;\n\n    this._keymap.clear();\n\n    let it = entries[Symbol.iterator]();\n\n    for (let itv = it.next(); !itv.done; itv = it.next()) {\n      let e = new Entry(itv.value[0], itv.value[1]);\n\n      this._keymap.set(e.key, e);\n\n      if (!entry) {\n        this.oldest = e;\n      } else {\n        entry[NEWER] = e;\n        e[OLDER] = entry;\n      }\n\n      entry = e;\n\n      if (limit-- == 0) {\n        throw new Error('overflow');\n      }\n    }\n\n    this.newest = entry;\n    this.size = this._keymap.size;\n  };\n\n  LRUMap.prototype.get = function (key) {\n    // First, find our cache entry\n    var entry = this._keymap.get(key);\n\n    if (!entry) return; // Not cached. Sorry.\n    // As <key> was found in the cache, register it as being requested recently\n\n    this._markEntryAsUsed(entry);\n\n    return entry.value;\n  };\n\n  LRUMap.prototype.set = function (key, value) {\n    var entry = this._keymap.get(key);\n\n    if (entry) {\n      // update existing\n      entry.value = value;\n\n      this._markEntryAsUsed(entry);\n\n      return this;\n    } // new entry\n\n\n    this._keymap.set(key, entry = new Entry(key, value));\n\n    if (this.newest) {\n      // link previous tail to the new tail (entry)\n      this.newest[NEWER] = entry;\n      entry[OLDER] = this.newest;\n    } else {\n      // we're first in -- yay\n      this.oldest = entry;\n    } // add new entry to the end of the linked list -- it's now the freshest entry.\n\n\n    this.newest = entry;\n    ++this.size;\n\n    if (this.size > this.limit) {\n      // we hit the limit -- remove the head\n      this.shift();\n    }\n\n    return this;\n  };\n\n  LRUMap.prototype.shift = function () {\n    // todo: handle special case when limit == 1\n    var entry = this.oldest;\n\n    if (entry) {\n      if (this.oldest[NEWER]) {\n        // advance the list\n        this.oldest = this.oldest[NEWER];\n        this.oldest[OLDER] = undefined;\n      } else {\n        // the cache is exhausted\n        this.oldest = undefined;\n        this.newest = undefined;\n      } // Remove last strong reference to <entry> and remove links from the purged\n      // entry being returned:\n\n\n      entry[NEWER] = entry[OLDER] = undefined;\n\n      this._keymap.delete(entry.key);\n\n      --this.size;\n      return [entry.key, entry.value];\n    }\n  }; // ----------------------------------------------------------------------------\n  // Following code is optional and can be removed without breaking the core\n  // functionality.\n\n\n  LRUMap.prototype.find = function (key) {\n    let e = this._keymap.get(key);\n\n    return e ? e.value : undefined;\n  };\n\n  LRUMap.prototype.has = function (key) {\n    return this._keymap.has(key);\n  };\n\n  LRUMap.prototype['delete'] = function (key) {\n    var entry = this._keymap.get(key);\n\n    if (!entry) return;\n\n    this._keymap.delete(entry.key);\n\n    if (entry[NEWER] && entry[OLDER]) {\n      // relink the older entry with the newer entry\n      entry[OLDER][NEWER] = entry[NEWER];\n      entry[NEWER][OLDER] = entry[OLDER];\n    } else if (entry[NEWER]) {\n      // remove the link to us\n      entry[NEWER][OLDER] = undefined; // link the newer entry to head\n\n      this.oldest = entry[NEWER];\n    } else if (entry[OLDER]) {\n      // remove the link to us\n      entry[OLDER][NEWER] = undefined; // link the newer entry to head\n\n      this.newest = entry[OLDER];\n    } else {\n      // if(entry[OLDER] === undefined && entry.newer === undefined) {\n      this.oldest = this.newest = undefined;\n    }\n\n    this.size--;\n    return entry.value;\n  };\n\n  LRUMap.prototype.clear = function () {\n    // Not clearing links should be safe, as we don't expose live links to user\n    this.oldest = this.newest = undefined;\n    this.size = 0;\n\n    this._keymap.clear();\n  };\n\n  function EntryIterator(oldestEntry) {\n    this.entry = oldestEntry;\n  }\n\n  EntryIterator.prototype[Symbol.iterator] = function () {\n    return this;\n  };\n\n  EntryIterator.prototype.next = function () {\n    let ent = this.entry;\n\n    if (ent) {\n      this.entry = ent[NEWER];\n      return {\n        done: false,\n        value: [ent.key, ent.value]\n      };\n    } else {\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n  };\n\n  function KeyIterator(oldestEntry) {\n    this.entry = oldestEntry;\n  }\n\n  KeyIterator.prototype[Symbol.iterator] = function () {\n    return this;\n  };\n\n  KeyIterator.prototype.next = function () {\n    let ent = this.entry;\n\n    if (ent) {\n      this.entry = ent[NEWER];\n      return {\n        done: false,\n        value: ent.key\n      };\n    } else {\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n  };\n\n  function ValueIterator(oldestEntry) {\n    this.entry = oldestEntry;\n  }\n\n  ValueIterator.prototype[Symbol.iterator] = function () {\n    return this;\n  };\n\n  ValueIterator.prototype.next = function () {\n    let ent = this.entry;\n\n    if (ent) {\n      this.entry = ent[NEWER];\n      return {\n        done: false,\n        value: ent.value\n      };\n    } else {\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n  };\n\n  LRUMap.prototype.keys = function () {\n    return new KeyIterator(this.oldest);\n  };\n\n  LRUMap.prototype.values = function () {\n    return new ValueIterator(this.oldest);\n  };\n\n  LRUMap.prototype.entries = function () {\n    return this;\n  };\n\n  LRUMap.prototype[Symbol.iterator] = function () {\n    return new EntryIterator(this.oldest);\n  };\n\n  LRUMap.prototype.forEach = function (fun, thisObj) {\n    if (typeof thisObj !== 'object') {\n      thisObj = this;\n    }\n\n    let entry = this.oldest;\n\n    while (entry) {\n      fun.call(thisObj, entry.value, entry.key, this);\n      entry = entry[NEWER];\n    }\n  };\n  /** Returns a JSON (array) representation */\n\n\n  LRUMap.prototype.toJSON = function () {\n    var s = new Array(this.size),\n        i = 0,\n        entry = this.oldest;\n\n    while (entry) {\n      s[i++] = {\n        key: entry.key,\n        value: entry.value\n      };\n      entry = entry[NEWER];\n    }\n\n    return s;\n  };\n  /** Returns a String representation */\n\n\n  LRUMap.prototype.toString = function () {\n    var s = '',\n        entry = this.oldest;\n\n    while (entry) {\n      s += String(entry.key) + ':' + entry.value;\n      entry = entry[NEWER];\n\n      if (entry) {\n        s += ' < ';\n      }\n    }\n\n    return s;\n  };\n});","map":{"version":3,"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/lru_map/lru.js"],"names":["g","f","e","exports","define","amd","NEWER","Symbol","OLDER","LRUMap","limit","entries","size","oldest","newest","undefined","_keymap","Map","assign","Entry","key","value","prototype","_markEntryAsUsed","entry","Number","MAX_VALUE","clear","it","iterator","itv","next","done","set","Error","get","shift","delete","find","has","EntryIterator","oldestEntry","ent","KeyIterator","ValueIterator","keys","values","forEach","fun","thisObj","call","toJSON","s","Array","i","toString","String"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,UAASA,CAAT,EAAWC,CAAX,EAAa;AACZ,QAAMC,CAAC,GAAG,OAAOC,OAAP,IAAkB,QAAlB,GAA6BA,OAA7B,GAAuC,OAAOH,CAAP,IAAY,QAAZ,GAAuBA,CAAvB,GAA2B,EAA5E;AACAC,EAAAA,CAAC,CAACC,CAAD,CAAD;;AACA,MAAI,OAAOE,MAAP,IAAiB,UAAjB,IAA+BA,MAAM,CAACC,GAA1C,EAA+C;AAAED,IAAAA,MAAM,CAAC,KAAD,EAAQF,CAAR,CAAN;AAAmB;AACrE,CAJD,EAIG,IAJH,EAIS,UAASC,OAAT,EAAkB;AAE3B,QAAMG,KAAK,GAAGC,MAAM,CAAC,OAAD,CAApB;AACA,QAAMC,KAAK,GAAGD,MAAM,CAAC,OAAD,CAApB;;AAEA,WAASE,MAAT,CAAgBC,KAAhB,EAAuBC,OAAvB,EAAgC;AAC9B,QAAI,OAAOD,KAAP,KAAiB,QAArB,EAA+B;AAC7B;AACAC,MAAAA,OAAO,GAAGD,KAAV;AACAA,MAAAA,KAAK,GAAG,CAAR;AACD;;AAED,SAAKE,IAAL,GAAY,CAAZ;AACA,SAAKF,KAAL,GAAaA,KAAb;AACA,SAAKG,MAAL,GAAc,KAAKC,MAAL,GAAcC,SAA5B;AACA,SAAKC,OAAL,GAAe,IAAIC,GAAJ,EAAf;;AAEA,QAAIN,OAAJ,EAAa;AACX,WAAKO,MAAL,CAAYP,OAAZ;;AACA,UAAID,KAAK,GAAG,CAAZ,EAAe;AACb,aAAKA,KAAL,GAAa,KAAKE,IAAlB;AACD;AACF;AACF;;AAEDT,EAAAA,OAAO,CAACM,MAAR,GAAiBA,MAAjB;;AAEA,WAASU,KAAT,CAAeC,GAAf,EAAoBC,KAApB,EAA2B;AACzB,SAAKD,GAAL,GAAWA,GAAX;AACA,SAAKC,KAAL,GAAaA,KAAb;AACA,SAAKf,KAAL,IAAcS,SAAd;AACA,SAAKP,KAAL,IAAcO,SAAd;AACD;;AAGDN,EAAAA,MAAM,CAACa,SAAP,CAAiBC,gBAAjB,GAAoC,UAASC,KAAT,EAAgB;AAClD,QAAIA,KAAK,KAAK,KAAKV,MAAnB,EAA2B;AACzB;AACA;AACD,KAJiD,CAKlD;AACA;AACA;AACA;;;AACA,QAAIU,KAAK,CAAClB,KAAD,CAAT,EAAkB;AAChB,UAAIkB,KAAK,KAAK,KAAKX,MAAnB,EAA2B;AACzB,aAAKA,MAAL,GAAcW,KAAK,CAAClB,KAAD,CAAnB;AACD;;AACDkB,MAAAA,KAAK,CAAClB,KAAD,CAAL,CAAaE,KAAb,IAAsBgB,KAAK,CAAChB,KAAD,CAA3B,CAJgB,CAIoB;AACrC;;AACD,QAAIgB,KAAK,CAAChB,KAAD,CAAT,EAAkB;AAChBgB,MAAAA,KAAK,CAAChB,KAAD,CAAL,CAAaF,KAAb,IAAsBkB,KAAK,CAAClB,KAAD,CAA3B,CADgB,CACoB;AACrC;;AACDkB,IAAAA,KAAK,CAAClB,KAAD,CAAL,GAAeS,SAAf,CAlBkD,CAkBxB;;AAC1BS,IAAAA,KAAK,CAAChB,KAAD,CAAL,GAAe,KAAKM,MAApB,CAnBkD,CAmBtB;;AAC5B,QAAI,KAAKA,MAAT,EAAiB;AACf,WAAKA,MAAL,CAAYR,KAAZ,IAAqBkB,KAArB,CADe,CACa;AAC7B;;AACD,SAAKV,MAAL,GAAcU,KAAd;AACD,GAxBD;;AA0BAf,EAAAA,MAAM,CAACa,SAAP,CAAiBJ,MAAjB,GAA0B,UAASP,OAAT,EAAkB;AAC1C,QAAIa,KAAJ;AAAA,QAAWd,KAAK,GAAG,KAAKA,KAAL,IAAce,MAAM,CAACC,SAAxC;;AACA,SAAKV,OAAL,CAAaW,KAAb;;AACA,QAAIC,EAAE,GAAGjB,OAAO,CAACJ,MAAM,CAACsB,QAAR,CAAP,EAAT;;AACA,SAAK,IAAIC,GAAG,GAAGF,EAAE,CAACG,IAAH,EAAf,EAA0B,CAACD,GAAG,CAACE,IAA/B,EAAqCF,GAAG,GAAGF,EAAE,CAACG,IAAH,EAA3C,EAAsD;AACpD,UAAI7B,CAAC,GAAG,IAAIiB,KAAJ,CAAUW,GAAG,CAACT,KAAJ,CAAU,CAAV,CAAV,EAAwBS,GAAG,CAACT,KAAJ,CAAU,CAAV,CAAxB,CAAR;;AACA,WAAKL,OAAL,CAAaiB,GAAb,CAAiB/B,CAAC,CAACkB,GAAnB,EAAwBlB,CAAxB;;AACA,UAAI,CAACsB,KAAL,EAAY;AACV,aAAKX,MAAL,GAAcX,CAAd;AACD,OAFD,MAEO;AACLsB,QAAAA,KAAK,CAAClB,KAAD,CAAL,GAAeJ,CAAf;AACAA,QAAAA,CAAC,CAACM,KAAD,CAAD,GAAWgB,KAAX;AACD;;AACDA,MAAAA,KAAK,GAAGtB,CAAR;;AACA,UAAIQ,KAAK,MAAM,CAAf,EAAkB;AAChB,cAAM,IAAIwB,KAAJ,CAAU,UAAV,CAAN;AACD;AACF;;AACD,SAAKpB,MAAL,GAAcU,KAAd;AACA,SAAKZ,IAAL,GAAY,KAAKI,OAAL,CAAaJ,IAAzB;AACD,GApBD;;AAsBAH,EAAAA,MAAM,CAACa,SAAP,CAAiBa,GAAjB,GAAuB,UAASf,GAAT,EAAc;AACnC;AACA,QAAII,KAAK,GAAG,KAAKR,OAAL,CAAamB,GAAb,CAAiBf,GAAjB,CAAZ;;AACA,QAAI,CAACI,KAAL,EAAY,OAHuB,CAGf;AACpB;;AACA,SAAKD,gBAAL,CAAsBC,KAAtB;;AACA,WAAOA,KAAK,CAACH,KAAb;AACD,GAPD;;AASAZ,EAAAA,MAAM,CAACa,SAAP,CAAiBW,GAAjB,GAAuB,UAASb,GAAT,EAAcC,KAAd,EAAqB;AAC1C,QAAIG,KAAK,GAAG,KAAKR,OAAL,CAAamB,GAAb,CAAiBf,GAAjB,CAAZ;;AAEA,QAAII,KAAJ,EAAW;AACT;AACAA,MAAAA,KAAK,CAACH,KAAN,GAAcA,KAAd;;AACA,WAAKE,gBAAL,CAAsBC,KAAtB;;AACA,aAAO,IAAP;AACD,KARyC,CAU1C;;;AACA,SAAKR,OAAL,CAAaiB,GAAb,CAAiBb,GAAjB,EAAuBI,KAAK,GAAG,IAAIL,KAAJ,CAAUC,GAAV,EAAeC,KAAf,CAA/B;;AAEA,QAAI,KAAKP,MAAT,EAAiB;AACf;AACA,WAAKA,MAAL,CAAYR,KAAZ,IAAqBkB,KAArB;AACAA,MAAAA,KAAK,CAAChB,KAAD,CAAL,GAAe,KAAKM,MAApB;AACD,KAJD,MAIO;AACL;AACA,WAAKD,MAAL,GAAcW,KAAd;AACD,KApByC,CAsB1C;;;AACA,SAAKV,MAAL,GAAcU,KAAd;AACA,MAAE,KAAKZ,IAAP;;AACA,QAAI,KAAKA,IAAL,GAAY,KAAKF,KAArB,EAA4B;AAC1B;AACA,WAAK0B,KAAL;AACD;;AAED,WAAO,IAAP;AACD,GA/BD;;AAiCA3B,EAAAA,MAAM,CAACa,SAAP,CAAiBc,KAAjB,GAAyB,YAAW;AAClC;AACA,QAAIZ,KAAK,GAAG,KAAKX,MAAjB;;AACA,QAAIW,KAAJ,EAAW;AACT,UAAI,KAAKX,MAAL,CAAYP,KAAZ,CAAJ,EAAwB;AACtB;AACA,aAAKO,MAAL,GAAc,KAAKA,MAAL,CAAYP,KAAZ,CAAd;AACA,aAAKO,MAAL,CAAYL,KAAZ,IAAqBO,SAArB;AACD,OAJD,MAIO;AACL;AACA,aAAKF,MAAL,GAAcE,SAAd;AACA,aAAKD,MAAL,GAAcC,SAAd;AACD,OATQ,CAUT;AACA;;;AACAS,MAAAA,KAAK,CAAClB,KAAD,CAAL,GAAekB,KAAK,CAAChB,KAAD,CAAL,GAAeO,SAA9B;;AACA,WAAKC,OAAL,CAAaqB,MAAb,CAAoBb,KAAK,CAACJ,GAA1B;;AACA,QAAE,KAAKR,IAAP;AACA,aAAO,CAACY,KAAK,CAACJ,GAAP,EAAYI,KAAK,CAACH,KAAlB,CAAP;AACD;AACF,GApBD,CA7H2B,CAmJ3B;AACA;AACA;;;AAEAZ,EAAAA,MAAM,CAACa,SAAP,CAAiBgB,IAAjB,GAAwB,UAASlB,GAAT,EAAc;AACpC,QAAIlB,CAAC,GAAG,KAAKc,OAAL,CAAamB,GAAb,CAAiBf,GAAjB,CAAR;;AACA,WAAOlB,CAAC,GAAGA,CAAC,CAACmB,KAAL,GAAaN,SAArB;AACD,GAHD;;AAKAN,EAAAA,MAAM,CAACa,SAAP,CAAiBiB,GAAjB,GAAuB,UAASnB,GAAT,EAAc;AACnC,WAAO,KAAKJ,OAAL,CAAauB,GAAb,CAAiBnB,GAAjB,CAAP;AACD,GAFD;;AAIAX,EAAAA,MAAM,CAACa,SAAP,CAAiB,QAAjB,IAA6B,UAASF,GAAT,EAAc;AACzC,QAAII,KAAK,GAAG,KAAKR,OAAL,CAAamB,GAAb,CAAiBf,GAAjB,CAAZ;;AACA,QAAI,CAACI,KAAL,EAAY;;AACZ,SAAKR,OAAL,CAAaqB,MAAb,CAAoBb,KAAK,CAACJ,GAA1B;;AACA,QAAII,KAAK,CAAClB,KAAD,CAAL,IAAgBkB,KAAK,CAAChB,KAAD,CAAzB,EAAkC;AAChC;AACAgB,MAAAA,KAAK,CAAChB,KAAD,CAAL,CAAaF,KAAb,IAAsBkB,KAAK,CAAClB,KAAD,CAA3B;AACAkB,MAAAA,KAAK,CAAClB,KAAD,CAAL,CAAaE,KAAb,IAAsBgB,KAAK,CAAChB,KAAD,CAA3B;AACD,KAJD,MAIO,IAAIgB,KAAK,CAAClB,KAAD,CAAT,EAAkB;AACvB;AACAkB,MAAAA,KAAK,CAAClB,KAAD,CAAL,CAAaE,KAAb,IAAsBO,SAAtB,CAFuB,CAGvB;;AACA,WAAKF,MAAL,GAAcW,KAAK,CAAClB,KAAD,CAAnB;AACD,KALM,MAKA,IAAIkB,KAAK,CAAChB,KAAD,CAAT,EAAkB;AACvB;AACAgB,MAAAA,KAAK,CAAChB,KAAD,CAAL,CAAaF,KAAb,IAAsBS,SAAtB,CAFuB,CAGvB;;AACA,WAAKD,MAAL,GAAcU,KAAK,CAAChB,KAAD,CAAnB;AACD,KALM,MAKA;AAAC;AACN,WAAKK,MAAL,GAAc,KAAKC,MAAL,GAAcC,SAA5B;AACD;;AAED,SAAKH,IAAL;AACA,WAAOY,KAAK,CAACH,KAAb;AACD,GAxBD;;AA0BAZ,EAAAA,MAAM,CAACa,SAAP,CAAiBK,KAAjB,GAAyB,YAAW;AAClC;AACA,SAAKd,MAAL,GAAc,KAAKC,MAAL,GAAcC,SAA5B;AACA,SAAKH,IAAL,GAAY,CAAZ;;AACA,SAAKI,OAAL,CAAaW,KAAb;AACD,GALD;;AAQA,WAASa,aAAT,CAAuBC,WAAvB,EAAoC;AAAE,SAAKjB,KAAL,GAAaiB,WAAb;AAA2B;;AACjED,EAAAA,aAAa,CAAClB,SAAd,CAAwBf,MAAM,CAACsB,QAA/B,IAA2C,YAAW;AAAE,WAAO,IAAP;AAAc,GAAtE;;AACAW,EAAAA,aAAa,CAAClB,SAAd,CAAwBS,IAAxB,GAA+B,YAAW;AACxC,QAAIW,GAAG,GAAG,KAAKlB,KAAf;;AACA,QAAIkB,GAAJ,EAAS;AACP,WAAKlB,KAAL,GAAakB,GAAG,CAACpC,KAAD,CAAhB;AACA,aAAO;AAAE0B,QAAAA,IAAI,EAAE,KAAR;AAAeX,QAAAA,KAAK,EAAE,CAACqB,GAAG,CAACtB,GAAL,EAAUsB,GAAG,CAACrB,KAAd;AAAtB,OAAP;AACD,KAHD,MAGO;AACL,aAAO;AAAEW,QAAAA,IAAI,EAAE,IAAR;AAAcX,QAAAA,KAAK,EAAEN;AAArB,OAAP;AACD;AACF,GARD;;AAWA,WAAS4B,WAAT,CAAqBF,WAArB,EAAkC;AAAE,SAAKjB,KAAL,GAAaiB,WAAb;AAA2B;;AAC/DE,EAAAA,WAAW,CAACrB,SAAZ,CAAsBf,MAAM,CAACsB,QAA7B,IAAyC,YAAW;AAAE,WAAO,IAAP;AAAc,GAApE;;AACAc,EAAAA,WAAW,CAACrB,SAAZ,CAAsBS,IAAtB,GAA6B,YAAW;AACtC,QAAIW,GAAG,GAAG,KAAKlB,KAAf;;AACA,QAAIkB,GAAJ,EAAS;AACP,WAAKlB,KAAL,GAAakB,GAAG,CAACpC,KAAD,CAAhB;AACA,aAAO;AAAE0B,QAAAA,IAAI,EAAE,KAAR;AAAeX,QAAAA,KAAK,EAAEqB,GAAG,CAACtB;AAA1B,OAAP;AACD,KAHD,MAGO;AACL,aAAO;AAAEY,QAAAA,IAAI,EAAE,IAAR;AAAcX,QAAAA,KAAK,EAAEN;AAArB,OAAP;AACD;AACF,GARD;;AAUA,WAAS6B,aAAT,CAAuBH,WAAvB,EAAoC;AAAE,SAAKjB,KAAL,GAAaiB,WAAb;AAA2B;;AACjEG,EAAAA,aAAa,CAACtB,SAAd,CAAwBf,MAAM,CAACsB,QAA/B,IAA2C,YAAW;AAAE,WAAO,IAAP;AAAc,GAAtE;;AACAe,EAAAA,aAAa,CAACtB,SAAd,CAAwBS,IAAxB,GAA+B,YAAW;AACxC,QAAIW,GAAG,GAAG,KAAKlB,KAAf;;AACA,QAAIkB,GAAJ,EAAS;AACP,WAAKlB,KAAL,GAAakB,GAAG,CAACpC,KAAD,CAAhB;AACA,aAAO;AAAE0B,QAAAA,IAAI,EAAE,KAAR;AAAeX,QAAAA,KAAK,EAAEqB,GAAG,CAACrB;AAA1B,OAAP;AACD,KAHD,MAGO;AACL,aAAO;AAAEW,QAAAA,IAAI,EAAE,IAAR;AAAcX,QAAAA,KAAK,EAAEN;AAArB,OAAP;AACD;AACF,GARD;;AAWAN,EAAAA,MAAM,CAACa,SAAP,CAAiBuB,IAAjB,GAAwB,YAAW;AACjC,WAAO,IAAIF,WAAJ,CAAgB,KAAK9B,MAArB,CAAP;AACD,GAFD;;AAIAJ,EAAAA,MAAM,CAACa,SAAP,CAAiBwB,MAAjB,GAA0B,YAAW;AACnC,WAAO,IAAIF,aAAJ,CAAkB,KAAK/B,MAAvB,CAAP;AACD,GAFD;;AAIAJ,EAAAA,MAAM,CAACa,SAAP,CAAiBX,OAAjB,GAA2B,YAAW;AACpC,WAAO,IAAP;AACD,GAFD;;AAIAF,EAAAA,MAAM,CAACa,SAAP,CAAiBf,MAAM,CAACsB,QAAxB,IAAoC,YAAW;AAC7C,WAAO,IAAIW,aAAJ,CAAkB,KAAK3B,MAAvB,CAAP;AACD,GAFD;;AAIAJ,EAAAA,MAAM,CAACa,SAAP,CAAiByB,OAAjB,GAA2B,UAASC,GAAT,EAAcC,OAAd,EAAuB;AAChD,QAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;AAC/BA,MAAAA,OAAO,GAAG,IAAV;AACD;;AACD,QAAIzB,KAAK,GAAG,KAAKX,MAAjB;;AACA,WAAOW,KAAP,EAAc;AACZwB,MAAAA,GAAG,CAACE,IAAJ,CAASD,OAAT,EAAkBzB,KAAK,CAACH,KAAxB,EAA+BG,KAAK,CAACJ,GAArC,EAA0C,IAA1C;AACAI,MAAAA,KAAK,GAAGA,KAAK,CAAClB,KAAD,CAAb;AACD;AACF,GATD;AAWA;;;AACAG,EAAAA,MAAM,CAACa,SAAP,CAAiB6B,MAAjB,GAA0B,YAAW;AACnC,QAAIC,CAAC,GAAG,IAAIC,KAAJ,CAAU,KAAKzC,IAAf,CAAR;AAAA,QAA8B0C,CAAC,GAAG,CAAlC;AAAA,QAAqC9B,KAAK,GAAG,KAAKX,MAAlD;;AACA,WAAOW,KAAP,EAAc;AACZ4B,MAAAA,CAAC,CAACE,CAAC,EAAF,CAAD,GAAS;AAAElC,QAAAA,GAAG,EAAEI,KAAK,CAACJ,GAAb;AAAkBC,QAAAA,KAAK,EAAEG,KAAK,CAACH;AAA/B,OAAT;AACAG,MAAAA,KAAK,GAAGA,KAAK,CAAClB,KAAD,CAAb;AACD;;AACD,WAAO8C,CAAP;AACD,GAPD;AASA;;;AACA3C,EAAAA,MAAM,CAACa,SAAP,CAAiBiC,QAAjB,GAA4B,YAAW;AACrC,QAAIH,CAAC,GAAG,EAAR;AAAA,QAAY5B,KAAK,GAAG,KAAKX,MAAzB;;AACA,WAAOW,KAAP,EAAc;AACZ4B,MAAAA,CAAC,IAAII,MAAM,CAAChC,KAAK,CAACJ,GAAP,CAAN,GAAkB,GAAlB,GAAsBI,KAAK,CAACH,KAAjC;AACAG,MAAAA,KAAK,GAAGA,KAAK,CAAClB,KAAD,CAAb;;AACA,UAAIkB,KAAJ,EAAW;AACT4B,QAAAA,CAAC,IAAI,KAAL;AACD;AACF;;AACD,WAAOA,CAAP;AACD,GAVD;AAYC,CA9RD","sourcesContent":["/**\n * A doubly linked list-based Least Recently Used (LRU) cache. Will keep most\n * recently used items while discarding least recently used items when its limit\n * is reached.\n *\n * Licensed under MIT. Copyright (c) 2010 Rasmus Andersson <http://hunch.se/>\n * See README.md for details.\n *\n * Illustration of the design:\n *\n *       entry             entry             entry             entry\n *       ______            ______            ______            ______\n *      | head |.newer => |      |.newer => |      |.newer => | tail |\n *      |  A   |          |  B   |          |  C   |          |  D   |\n *      |______| <= older.|______| <= older.|______| <= older.|______|\n *\n *  removed  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  <--  added\n */\n(function(g,f){\n  const e = typeof exports == 'object' ? exports : typeof g == 'object' ? g : {};\n  f(e);\n  if (typeof define == 'function' && define.amd) { define('lru', e); }\n})(this, function(exports) {\n\nconst NEWER = Symbol('newer');\nconst OLDER = Symbol('older');\n\nfunction LRUMap(limit, entries) {\n  if (typeof limit !== 'number') {\n    // called as (entries)\n    entries = limit;\n    limit = 0;\n  }\n\n  this.size = 0;\n  this.limit = limit;\n  this.oldest = this.newest = undefined;\n  this._keymap = new Map();\n\n  if (entries) {\n    this.assign(entries);\n    if (limit < 1) {\n      this.limit = this.size;\n    }\n  }\n}\n\nexports.LRUMap = LRUMap;\n\nfunction Entry(key, value) {\n  this.key = key;\n  this.value = value;\n  this[NEWER] = undefined;\n  this[OLDER] = undefined;\n}\n\n\nLRUMap.prototype._markEntryAsUsed = function(entry) {\n  if (entry === this.newest) {\n    // Already the most recenlty used entry, so no need to update the list\n    return;\n  }\n  // HEAD--------------TAIL\n  //   <.older   .newer>\n  //  <--- add direction --\n  //   A  B  C  <D>  E\n  if (entry[NEWER]) {\n    if (entry === this.oldest) {\n      this.oldest = entry[NEWER];\n    }\n    entry[NEWER][OLDER] = entry[OLDER]; // C <-- E.\n  }\n  if (entry[OLDER]) {\n    entry[OLDER][NEWER] = entry[NEWER]; // C. --> E\n  }\n  entry[NEWER] = undefined; // D --x\n  entry[OLDER] = this.newest; // D. --> E\n  if (this.newest) {\n    this.newest[NEWER] = entry; // E. <-- D\n  }\n  this.newest = entry;\n};\n\nLRUMap.prototype.assign = function(entries) {\n  let entry, limit = this.limit || Number.MAX_VALUE;\n  this._keymap.clear();\n  let it = entries[Symbol.iterator]();\n  for (let itv = it.next(); !itv.done; itv = it.next()) {\n    let e = new Entry(itv.value[0], itv.value[1]);\n    this._keymap.set(e.key, e);\n    if (!entry) {\n      this.oldest = e;\n    } else {\n      entry[NEWER] = e;\n      e[OLDER] = entry;\n    }\n    entry = e;\n    if (limit-- == 0) {\n      throw new Error('overflow');\n    }\n  }\n  this.newest = entry;\n  this.size = this._keymap.size;\n};\n\nLRUMap.prototype.get = function(key) {\n  // First, find our cache entry\n  var entry = this._keymap.get(key);\n  if (!entry) return; // Not cached. Sorry.\n  // As <key> was found in the cache, register it as being requested recently\n  this._markEntryAsUsed(entry);\n  return entry.value;\n};\n\nLRUMap.prototype.set = function(key, value) {\n  var entry = this._keymap.get(key);\n\n  if (entry) {\n    // update existing\n    entry.value = value;\n    this._markEntryAsUsed(entry);\n    return this;\n  }\n\n  // new entry\n  this._keymap.set(key, (entry = new Entry(key, value)));\n\n  if (this.newest) {\n    // link previous tail to the new tail (entry)\n    this.newest[NEWER] = entry;\n    entry[OLDER] = this.newest;\n  } else {\n    // we're first in -- yay\n    this.oldest = entry;\n  }\n\n  // add new entry to the end of the linked list -- it's now the freshest entry.\n  this.newest = entry;\n  ++this.size;\n  if (this.size > this.limit) {\n    // we hit the limit -- remove the head\n    this.shift();\n  }\n\n  return this;\n};\n\nLRUMap.prototype.shift = function() {\n  // todo: handle special case when limit == 1\n  var entry = this.oldest;\n  if (entry) {\n    if (this.oldest[NEWER]) {\n      // advance the list\n      this.oldest = this.oldest[NEWER];\n      this.oldest[OLDER] = undefined;\n    } else {\n      // the cache is exhausted\n      this.oldest = undefined;\n      this.newest = undefined;\n    }\n    // Remove last strong reference to <entry> and remove links from the purged\n    // entry being returned:\n    entry[NEWER] = entry[OLDER] = undefined;\n    this._keymap.delete(entry.key);\n    --this.size;\n    return [entry.key, entry.value];\n  }\n};\n\n// ----------------------------------------------------------------------------\n// Following code is optional and can be removed without breaking the core\n// functionality.\n\nLRUMap.prototype.find = function(key) {\n  let e = this._keymap.get(key);\n  return e ? e.value : undefined;\n};\n\nLRUMap.prototype.has = function(key) {\n  return this._keymap.has(key);\n};\n\nLRUMap.prototype['delete'] = function(key) {\n  var entry = this._keymap.get(key);\n  if (!entry) return;\n  this._keymap.delete(entry.key);\n  if (entry[NEWER] && entry[OLDER]) {\n    // relink the older entry with the newer entry\n    entry[OLDER][NEWER] = entry[NEWER];\n    entry[NEWER][OLDER] = entry[OLDER];\n  } else if (entry[NEWER]) {\n    // remove the link to us\n    entry[NEWER][OLDER] = undefined;\n    // link the newer entry to head\n    this.oldest = entry[NEWER];\n  } else if (entry[OLDER]) {\n    // remove the link to us\n    entry[OLDER][NEWER] = undefined;\n    // link the newer entry to head\n    this.newest = entry[OLDER];\n  } else {// if(entry[OLDER] === undefined && entry.newer === undefined) {\n    this.oldest = this.newest = undefined;\n  }\n\n  this.size--;\n  return entry.value;\n};\n\nLRUMap.prototype.clear = function() {\n  // Not clearing links should be safe, as we don't expose live links to user\n  this.oldest = this.newest = undefined;\n  this.size = 0;\n  this._keymap.clear();\n};\n\n\nfunction EntryIterator(oldestEntry) { this.entry = oldestEntry; }\nEntryIterator.prototype[Symbol.iterator] = function() { return this; }\nEntryIterator.prototype.next = function() {\n  let ent = this.entry;\n  if (ent) {\n    this.entry = ent[NEWER];\n    return { done: false, value: [ent.key, ent.value] };\n  } else {\n    return { done: true, value: undefined };\n  }\n};\n\n\nfunction KeyIterator(oldestEntry) { this.entry = oldestEntry; }\nKeyIterator.prototype[Symbol.iterator] = function() { return this; }\nKeyIterator.prototype.next = function() {\n  let ent = this.entry;\n  if (ent) {\n    this.entry = ent[NEWER];\n    return { done: false, value: ent.key };\n  } else {\n    return { done: true, value: undefined };\n  }\n};\n\nfunction ValueIterator(oldestEntry) { this.entry = oldestEntry; }\nValueIterator.prototype[Symbol.iterator] = function() { return this; }\nValueIterator.prototype.next = function() {\n  let ent = this.entry;\n  if (ent) {\n    this.entry = ent[NEWER];\n    return { done: false, value: ent.value };\n  } else {\n    return { done: true, value: undefined };\n  }\n};\n\n\nLRUMap.prototype.keys = function() {\n  return new KeyIterator(this.oldest);\n};\n\nLRUMap.prototype.values = function() {\n  return new ValueIterator(this.oldest);\n};\n\nLRUMap.prototype.entries = function() {\n  return this;\n};\n\nLRUMap.prototype[Symbol.iterator] = function() {\n  return new EntryIterator(this.oldest);\n};\n\nLRUMap.prototype.forEach = function(fun, thisObj) {\n  if (typeof thisObj !== 'object') {\n    thisObj = this;\n  }\n  let entry = this.oldest;\n  while (entry) {\n    fun.call(thisObj, entry.value, entry.key, this);\n    entry = entry[NEWER];\n  }\n};\n\n/** Returns a JSON (array) representation */\nLRUMap.prototype.toJSON = function() {\n  var s = new Array(this.size), i = 0, entry = this.oldest;\n  while (entry) {\n    s[i++] = { key: entry.key, value: entry.value };\n    entry = entry[NEWER];\n  }\n  return s;\n};\n\n/** Returns a String representation */\nLRUMap.prototype.toString = function() {\n  var s = '', entry = this.oldest;\n  while (entry) {\n    s += String(entry.key)+':'+entry.value;\n    entry = entry[NEWER];\n    if (entry) {\n      s += ' < ';\n    }\n  }\n  return s;\n};\n\n});\n"]},"metadata":{},"sourceType":"script"}