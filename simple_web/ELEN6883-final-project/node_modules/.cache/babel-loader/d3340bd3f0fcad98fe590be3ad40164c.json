{"ast":null,"code":"import { __assign, __awaiter, __generator } from \"tslib\";\nimport { API, eventToSentryRequest } from '@sentry/core';\nimport { Status } from '@sentry/types';\nimport { logger, parseRetryAfterHeader, PromiseBuffer, SentryError } from '@sentry/utils';\nimport * as fs from 'fs';\nimport * as url from 'url';\nimport { SDK_NAME, SDK_VERSION } from '../version';\n/** Base Transport class implementation */\n\nvar BaseTransport =\n/** @class */\nfunction () {\n  /** Create instance and set this.dsn */\n  function BaseTransport(options) {\n    this.options = options;\n    /** A simple buffer holding all requests. */\n\n    this._buffer = new PromiseBuffer(30);\n    /** Locks transport after receiving 429 response */\n\n    this._disabledUntil = new Date(Date.now());\n    this._api = new API(options.dsn);\n  }\n  /**\n   * @inheritDoc\n   */\n\n\n  BaseTransport.prototype.sendEvent = function (_) {\n    throw new SentryError('Transport Class has to implement `sendEvent` method.');\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  BaseTransport.prototype.close = function (timeout) {\n    return this._buffer.drain(timeout);\n  };\n  /** Returns a build request option object used by request */\n\n\n  BaseTransport.prototype._getRequestOptions = function (uri) {\n    var headers = __assign(__assign({}, this._api.getRequestHeaders(SDK_NAME, SDK_VERSION)), this.options.headers);\n\n    var hostname = uri.hostname,\n        pathname = uri.pathname,\n        port = uri.port,\n        protocol = uri.protocol; // See https://github.com/nodejs/node/blob/38146e717fed2fabe3aacb6540d839475e0ce1c6/lib/internal/url.js#L1268-L1290\n    // We ignore the query string on purpose\n\n    var path = \"\" + pathname;\n    return __assign({\n      agent: this.client,\n      headers: headers,\n      hostname: hostname,\n      method: 'POST',\n      path: path,\n      port: port,\n      protocol: protocol\n    }, this.options.caCerts && {\n      ca: fs.readFileSync(this.options.caCerts)\n    });\n  };\n  /** JSDoc */\n\n\n  BaseTransport.prototype._sendWithModule = function (httpModule, event) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        if (new Date(Date.now()) < this._disabledUntil) {\n          return [2\n          /*return*/\n          , Promise.reject(new SentryError(\"Transport locked till \" + this._disabledUntil + \" due to too many requests.\"))];\n        }\n\n        if (!this._buffer.isReady()) {\n          return [2\n          /*return*/\n          , Promise.reject(new SentryError('Not adding Promise due to buffer limit reached.'))];\n        }\n\n        return [2\n        /*return*/\n        , this._buffer.add(new Promise(function (resolve, reject) {\n          var sentryReq = eventToSentryRequest(event, _this._api);\n\n          var options = _this._getRequestOptions(new url.URL(sentryReq.url));\n\n          var req = httpModule.request(options, function (res) {\n            var statusCode = res.statusCode || 500;\n            var status = Status.fromHttpCode(statusCode);\n            res.setEncoding('utf8');\n\n            if (status === Status.Success) {\n              resolve({\n                status: status\n              });\n            } else {\n              if (status === Status.RateLimit) {\n                var now = Date.now();\n                /**\n                 * \"Key-value pairs of header names and values. Header names are lower-cased.\"\n                 * https://nodejs.org/api/http.html#http_message_headers\n                 */\n\n                var retryAfterHeader = res.headers ? res.headers['retry-after'] : '';\n                retryAfterHeader = Array.isArray(retryAfterHeader) ? retryAfterHeader[0] : retryAfterHeader;\n                _this._disabledUntil = new Date(now + parseRetryAfterHeader(now, retryAfterHeader));\n                logger.warn(\"Too many requests, backing off till: \" + _this._disabledUntil);\n              }\n\n              var rejectionMessage = \"HTTP Error (\" + statusCode + \")\";\n\n              if (res.headers && res.headers['x-sentry-error']) {\n                rejectionMessage += \": \" + res.headers['x-sentry-error'];\n              }\n\n              reject(new SentryError(rejectionMessage));\n            } // Force the socket to drain\n\n\n            res.on('data', function () {// Drain\n            });\n            res.on('end', function () {// Drain\n            });\n          });\n          req.on('error', reject);\n          req.end(sentryReq.body);\n        }))];\n      });\n    });\n  };\n\n  return BaseTransport;\n}();\n\nexport { BaseTransport };","map":{"version":3,"mappings":"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","names":["API","eventToSentryRequest","Status","logger","parseRetryAfterHeader","PromiseBuffer","SentryError","fs","url","SDK_NAME","SDK_VERSION","options","Date","now","_api","dsn","BaseTransport","_","timeout","_buffer","drain","uri","headers","getRequestHeaders","pathname","port","protocol","path","agent","client","hostname","method","caCerts","ca","readFileSync","httpModule","event","_disabledUntil","Promise","reject","isReady","add","resolve","sentryReq","_this","_getRequestOptions","URL","req","request","res","statusCode","status","fromHttpCode","setEncoding","Success","RateLimit","retryAfterHeader","Array","isArray","warn","rejectionMessage","on","end","body"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/@sentry/node/src/transports/base.ts"],"sourcesContent":["import { API, eventToSentryRequest } from '@sentry/core';\nimport { Event, Response, Status, Transport, TransportOptions } from '@sentry/types';\nimport { logger, parseRetryAfterHeader, PromiseBuffer, SentryError } from '@sentry/utils';\nimport * as fs from 'fs';\nimport * as http from 'http';\nimport * as https from 'https';\nimport * as url from 'url';\n\nimport { SDK_NAME, SDK_VERSION } from '../version';\n\n/**\n * Internal used interface for typescript.\n * @hidden\n */\nexport interface HTTPModule {\n  /**\n   * Request wrapper\n   * @param options These are {@see TransportOptions}\n   * @param callback Callback when request is finished\n   */\n  request(\n    options: http.RequestOptions | https.RequestOptions | string | url.URL,\n    callback?: (res: http.IncomingMessage) => void,\n  ): http.ClientRequest;\n\n  // This is the type for nodejs versions that handle the URL argument\n  // (v10.9.0+), but we do not use it just yet because we support older node\n  // versions:\n\n  // request(\n  //   url: string | url.URL,\n  //   options: http.RequestOptions | https.RequestOptions,\n  //   callback?: (res: http.IncomingMessage) => void,\n  // ): http.ClientRequest;\n}\n\n/** Base Transport class implementation */\nexport abstract class BaseTransport implements Transport {\n  /** The Agent used for corresponding transport */\n  public module?: HTTPModule;\n\n  /** The Agent used for corresponding transport */\n  public client?: http.Agent | https.Agent;\n\n  /** API object */\n  protected _api: API;\n\n  /** A simple buffer holding all requests. */\n  protected readonly _buffer: PromiseBuffer<Response> = new PromiseBuffer(30);\n\n  /** Locks transport after receiving 429 response */\n  private _disabledUntil: Date = new Date(Date.now());\n\n  /** Create instance and set this.dsn */\n  public constructor(public options: TransportOptions) {\n    this._api = new API(options.dsn);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendEvent(_: Event): PromiseLike<Response> {\n    throw new SentryError('Transport Class has to implement `sendEvent` method.');\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public close(timeout?: number): PromiseLike<boolean> {\n    return this._buffer.drain(timeout);\n  }\n\n  /** Returns a build request option object used by request */\n  protected _getRequestOptions(uri: url.URL): http.RequestOptions | https.RequestOptions {\n    const headers = {\n      ...this._api.getRequestHeaders(SDK_NAME, SDK_VERSION),\n      ...this.options.headers,\n    };\n    const { hostname, pathname, port, protocol } = uri;\n    // See https://github.com/nodejs/node/blob/38146e717fed2fabe3aacb6540d839475e0ce1c6/lib/internal/url.js#L1268-L1290\n    // We ignore the query string on purpose\n    const path = `${pathname}`;\n\n    return {\n      agent: this.client,\n      headers,\n      hostname,\n      method: 'POST',\n      path,\n      port,\n      protocol,\n      ...(this.options.caCerts && {\n        ca: fs.readFileSync(this.options.caCerts),\n      }),\n    };\n  }\n\n  /** JSDoc */\n  protected async _sendWithModule(httpModule: HTTPModule, event: Event): Promise<Response> {\n    if (new Date(Date.now()) < this._disabledUntil) {\n      return Promise.reject(new SentryError(`Transport locked till ${this._disabledUntil} due to too many requests.`));\n    }\n\n    if (!this._buffer.isReady()) {\n      return Promise.reject(new SentryError('Not adding Promise due to buffer limit reached.'));\n    }\n    return this._buffer.add(\n      new Promise<Response>((resolve, reject) => {\n        const sentryReq = eventToSentryRequest(event, this._api);\n        const options = this._getRequestOptions(new url.URL(sentryReq.url));\n\n        const req = httpModule.request(options, (res: http.IncomingMessage) => {\n          const statusCode = res.statusCode || 500;\n          const status = Status.fromHttpCode(statusCode);\n\n          res.setEncoding('utf8');\n\n          if (status === Status.Success) {\n            resolve({ status });\n          } else {\n            if (status === Status.RateLimit) {\n              const now = Date.now();\n              /**\n               * \"Key-value pairs of header names and values. Header names are lower-cased.\"\n               * https://nodejs.org/api/http.html#http_message_headers\n               */\n              let retryAfterHeader = res.headers ? res.headers['retry-after'] : '';\n              retryAfterHeader = (Array.isArray(retryAfterHeader) ? retryAfterHeader[0] : retryAfterHeader) as string;\n              this._disabledUntil = new Date(now + parseRetryAfterHeader(now, retryAfterHeader));\n              logger.warn(`Too many requests, backing off till: ${this._disabledUntil}`);\n            }\n\n            let rejectionMessage = `HTTP Error (${statusCode})`;\n            if (res.headers && res.headers['x-sentry-error']) {\n              rejectionMessage += `: ${res.headers['x-sentry-error']}`;\n            }\n\n            reject(new SentryError(rejectionMessage));\n          }\n\n          // Force the socket to drain\n          res.on('data', () => {\n            // Drain\n          });\n          res.on('end', () => {\n            // Drain\n          });\n        });\n        req.on('error', reject);\n        req.end(sentryReq.body);\n      }),\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}