{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.runScriptWithHardhat = exports.runScript = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst path_1 = __importDefault(require(\"path\"));\n\nconst execution_mode_1 = require(\"../core/execution-mode\");\n\nconst env_variables_1 = require(\"../core/params/env-variables\");\n\nconst log = (0, debug_1.default)(\"hardhat:core:scripts-runner\");\n\nasync function runScript(scriptPath) {\n  let scriptArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let extraNodeArgs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let extraEnvVars = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const {\n    fork\n  } = await Promise.resolve().then(() => __importStar(require(\"child_process\")));\n  return new Promise((resolve, reject) => {\n    const processExecArgv = withFixedInspectArg(process.execArgv);\n    const nodeArgs = [...processExecArgv, ...getTsNodeArgsIfNeeded(scriptPath), ...extraNodeArgs];\n    const envVars = Object.assign(Object.assign({}, process.env), extraEnvVars);\n    const childProcess = fork(scriptPath, scriptArgs, {\n      stdio: \"inherit\",\n      execArgv: nodeArgs,\n      env: envVars\n    });\n    childProcess.once(\"close\", status => {\n      log(`Script ${scriptPath} exited with status code ${status}`);\n      resolve(status);\n    });\n    childProcess.once(\"error\", reject);\n  });\n}\n\nexports.runScript = runScript;\n\nasync function runScriptWithHardhat(hardhatArguments, scriptPath) {\n  let scriptArgs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let extraNodeArgs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  let extraEnvVars = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  log(`Creating Hardhat subprocess to run ${scriptPath}`);\n  return runScript(scriptPath, scriptArgs, [...extraNodeArgs, \"--require\", path_1.default.join(__dirname, \"..\", \"..\", \"register\")], Object.assign(Object.assign({}, (0, env_variables_1.getEnvVariablesMap)(hardhatArguments)), extraEnvVars));\n}\n\nexports.runScriptWithHardhat = runScriptWithHardhat;\n/**\n * Fix debugger \"inspect\" arg from process.argv, if present.\n *\n * When running this process with a debugger, a debugger port\n * is specified via the \"--inspect-brk=\" arg param in some IDEs/setups.\n *\n * This normally works, but if we do a fork afterwards, we'll get an error stating\n * that the port is already in use (since the fork would also use the same args,\n * therefore the same port number). To prevent this issue, we could replace the port number with\n * a different free one, or simply use the port-agnostic --inspect\" flag, and leave the debugger\n * port selection to the Node process itself, which will pick an empty AND valid one.\n *\n * This way, we can properly use the debugger for this process AND for the executed\n * script itself - even if it's compiled using ts-node.\n */\n\nfunction withFixedInspectArg(argv) {\n  const fixIfInspectArg = arg => {\n    if (arg.toLowerCase().includes(\"--inspect-brk=\")) {\n      return \"--inspect\";\n    }\n\n    return arg;\n  };\n\n  return argv.map(fixIfInspectArg);\n}\n\nfunction getTsNodeArgsIfNeeded(scriptPath) {\n  if (process.execArgv.includes(\"ts-node/register\")) {\n    return [];\n  } // if we are running the tests we only want to transpile, or these tests\n  // take forever\n\n\n  if ((0, execution_mode_1.isRunningHardhatCoreTests)()) {\n    return [\"--require\", \"ts-node/register/transpile-only\"];\n  } // If the script we are going to run is .ts we need ts-node\n\n\n  if (/\\.tsx?$/i.test(scriptPath)) {\n    return [\"--require\", \"ts-node/register\"];\n  }\n\n  return [];\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AAGA;;AACA;;AAEA,MAAMA,GAAG,GAAG,qBAAM,6BAAN,CAAZ;;AAEO,eAAeC,SAAf,CACLC,UADK,EAIwC;AAAA,MAF7CC,UAE6C,uEAFtB,EAEsB;AAAA,MAD7CC,aAC6C,uEADnB,EACmB;AAAA,MAA7CC,YAA6C,uEAAF,EAAE;AAE7C,QAAM;AAAEC;AAAF,MAAW,wDAAa,eAAb,GAAjB;AAEA,SAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAoB;AACrC,UAAMC,eAAe,GAAGC,mBAAmB,CAACC,OAAO,CAACC,QAAT,CAA3C;AAEA,UAAMC,QAAQ,GAAG,CACf,GAAGJ,eADY,EAEf,GAAGK,qBAAqB,CAACb,UAAD,CAFT,EAGf,GAAGE,aAHY,CAAjB;AAMA,UAAMY,OAAO,mCAAQJ,OAAO,CAACK,GAAhB,GAAwBZ,YAAxB,CAAb;AAEA,UAAMa,YAAY,GAAGZ,IAAI,CAACJ,UAAD,EAAaC,UAAb,EAAyB;AAChDgB,WAAK,EAAE,SADyC;AAEhDN,cAAQ,EAAEC,QAFsC;AAGhDG,SAAG,EAAED;AAH2C,KAAzB,CAAzB;AAMAE,gBAAY,CAACE,IAAb,CAAkB,OAAlB,EAA4BC,MAAD,IAAW;AACpCrB,SAAG,CAAC,UAAUE,UAAU,4BAA4BmB,MAAM,EAAvD,CAAH;AAEAb,aAAO,CAACa,MAAD,CAAP;AACD,KAJD;AAKAH,gBAAY,CAACE,IAAb,CAAkB,OAAlB,EAA2BX,MAA3B;AACD,GAvBM,CAAP;AAwBD;;AAhCDa;;AAkCO,eAAeC,oBAAf,CACLC,gBADK,EAELtB,UAFK,EAKwC;AAAA,MAF7CC,UAE6C,uEAFtB,EAEsB;AAAA,MAD7CC,aAC6C,uEADnB,EACmB;AAAA,MAA7CC,YAA6C,uEAAF,EAAE;AAE7CL,KAAG,CAAC,sCAAsCE,UAAU,EAAjD,CAAH;AAEA,SAAOD,SAAS,CACdC,UADc,EAEdC,UAFc,EAGd,CACE,GAAGC,aADL,EAEE,WAFF,EAGEqB,eAAKC,IAAL,CAAUC,SAAV,EAAqB,IAArB,EAA2B,IAA3B,EAAiC,UAAjC,CAHF,CAHc,EAObC,gCAEI,wCAAmBJ,gBAAnB,CAFJ,GAGInB,YAHJ,CAPa,CAAhB;AAaD;;AAtBDiB;AAwBA;;;;;;;;;;;;;;;;AAeA,SAASX,mBAAT,CAA6BkB,IAA7B,EAA2C;AACzC,QAAMC,eAAe,GAAIC,GAAD,IAAgB;AACtC,QAAIA,GAAG,CAACC,WAAJ,GAAkBC,QAAlB,CAA2B,gBAA3B,CAAJ,EAAkD;AAChD,aAAO,WAAP;AACD;;AACD,WAAOF,GAAP;AACD,GALD;;AAMA,SAAOF,IAAI,CAACK,GAAL,CAASJ,eAAT,CAAP;AACD;;AAED,SAASf,qBAAT,CAA+Bb,UAA/B,EAAiD;AAC/C,MAAIU,OAAO,CAACC,QAAR,CAAiBoB,QAAjB,CAA0B,kBAA1B,CAAJ,EAAmD;AACjD,WAAO,EAAP;AACD,GAH8C,CAK/C;AACA;;;AACA,MAAI,iDAAJ,EAAiC;AAC/B,WAAO,CAAC,WAAD,EAAc,iCAAd,CAAP;AACD,GAT8C,CAW/C;;;AACA,MAAI,WAAWE,IAAX,CAAgBjC,UAAhB,CAAJ,EAAiC;AAC/B,WAAO,CAAC,WAAD,EAAc,kBAAd,CAAP;AACD;;AAED,SAAO,EAAP;AACD","names":["log","runScript","scriptPath","scriptArgs","extraNodeArgs","extraEnvVars","fork","Promise","resolve","reject","processExecArgv","withFixedInspectArg","process","execArgv","nodeArgs","getTsNodeArgsIfNeeded","envVars","env","childProcess","stdio","once","status","exports","runScriptWithHardhat","hardhatArguments","path_1","join","__dirname","Object","argv","fixIfInspectArg","arg","toLowerCase","includes","map","test"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/internal/util/scripts-runner.ts"],"sourcesContent":["import debug from \"debug\";\nimport path from \"path\";\n\nimport { HardhatArguments } from \"../../types\";\nimport { isRunningHardhatCoreTests } from \"../core/execution-mode\";\nimport { getEnvVariablesMap } from \"../core/params/env-variables\";\n\nconst log = debug(\"hardhat:core:scripts-runner\");\n\nexport async function runScript(\n  scriptPath: string,\n  scriptArgs: string[] = [],\n  extraNodeArgs: string[] = [],\n  extraEnvVars: { [name: string]: string } = {}\n): Promise<number> {\n  const { fork } = await import(\"child_process\");\n\n  return new Promise((resolve, reject) => {\n    const processExecArgv = withFixedInspectArg(process.execArgv);\n\n    const nodeArgs = [\n      ...processExecArgv,\n      ...getTsNodeArgsIfNeeded(scriptPath),\n      ...extraNodeArgs,\n    ];\n\n    const envVars = { ...process.env, ...extraEnvVars };\n\n    const childProcess = fork(scriptPath, scriptArgs, {\n      stdio: \"inherit\",\n      execArgv: nodeArgs,\n      env: envVars,\n    });\n\n    childProcess.once(\"close\", (status) => {\n      log(`Script ${scriptPath} exited with status code ${status}`);\n\n      resolve(status as number);\n    });\n    childProcess.once(\"error\", reject);\n  });\n}\n\nexport async function runScriptWithHardhat(\n  hardhatArguments: HardhatArguments,\n  scriptPath: string,\n  scriptArgs: string[] = [],\n  extraNodeArgs: string[] = [],\n  extraEnvVars: { [name: string]: string } = {}\n): Promise<number> {\n  log(`Creating Hardhat subprocess to run ${scriptPath}`);\n\n  return runScript(\n    scriptPath,\n    scriptArgs,\n    [\n      ...extraNodeArgs,\n      \"--require\",\n      path.join(__dirname, \"..\", \"..\", \"register\"),\n    ],\n    {\n      ...getEnvVariablesMap(hardhatArguments),\n      ...extraEnvVars,\n    }\n  );\n}\n\n/**\n * Fix debugger \"inspect\" arg from process.argv, if present.\n *\n * When running this process with a debugger, a debugger port\n * is specified via the \"--inspect-brk=\" arg param in some IDEs/setups.\n *\n * This normally works, but if we do a fork afterwards, we'll get an error stating\n * that the port is already in use (since the fork would also use the same args,\n * therefore the same port number). To prevent this issue, we could replace the port number with\n * a different free one, or simply use the port-agnostic --inspect\" flag, and leave the debugger\n * port selection to the Node process itself, which will pick an empty AND valid one.\n *\n * This way, we can properly use the debugger for this process AND for the executed\n * script itself - even if it's compiled using ts-node.\n */\nfunction withFixedInspectArg(argv: string[]) {\n  const fixIfInspectArg = (arg: string) => {\n    if (arg.toLowerCase().includes(\"--inspect-brk=\")) {\n      return \"--inspect\";\n    }\n    return arg;\n  };\n  return argv.map(fixIfInspectArg);\n}\n\nfunction getTsNodeArgsIfNeeded(scriptPath: string): string[] {\n  if (process.execArgv.includes(\"ts-node/register\")) {\n    return [];\n  }\n\n  // if we are running the tests we only want to transpile, or these tests\n  // take forever\n  if (isRunningHardhatCoreTests()) {\n    return [\"--require\", \"ts-node/register/transpile-only\"];\n  }\n\n  // If the script we are going to run is .ts we need ts-node\n  if (/\\.tsx?$/i.test(scriptPath)) {\n    return [\"--require\", \"ts-node/register\"];\n  }\n\n  return [];\n}\n"]},"metadata":{},"sourceType":"script"}