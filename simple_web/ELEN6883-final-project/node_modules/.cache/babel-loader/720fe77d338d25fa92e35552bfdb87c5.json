{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { getCurrentHub, Hub } from '@sentry/hub';\nimport { isInstanceOf, logger } from '@sentry/utils';\nimport { Span as SpanClass, SpanRecorder } from './span';\n/** JSDoc */\n\nvar Transaction =\n/** @class */\nfunction (_super) {\n  __extends(Transaction, _super);\n  /**\n   * This constructor should never be called manually. Those instrumenting tracing should use\n   * `Sentry.startTransaction()`, and internal methods should use `hub.startTransaction()`.\n   * @internal\n   * @hideconstructor\n   * @hidden\n   */\n\n\n  function Transaction(transactionContext, hub) {\n    var _this = _super.call(this, transactionContext) || this;\n\n    _this._measurements = {};\n    /**\n     * The reference to the current hub.\n     */\n\n    _this._hub = getCurrentHub();\n\n    if (isInstanceOf(hub, Hub)) {\n      _this._hub = hub;\n    }\n\n    _this.name = transactionContext.name ? transactionContext.name : '';\n    _this._trimEnd = transactionContext.trimEnd; // this is because transactions are also spans, and spans have a transaction pointer\n\n    _this.transaction = _this;\n    return _this;\n  }\n  /**\n   * JSDoc\n   */\n\n\n  Transaction.prototype.setName = function (name) {\n    this.name = name;\n  };\n  /**\n   * Attaches SpanRecorder to the span itself\n   * @param maxlen maximum number of spans that can be recorded\n   */\n\n\n  Transaction.prototype.initSpanRecorder = function (maxlen) {\n    if (maxlen === void 0) {\n      maxlen = 1000;\n    }\n\n    if (!this.spanRecorder) {\n      this.spanRecorder = new SpanRecorder(maxlen);\n    }\n\n    this.spanRecorder.add(this);\n  };\n  /**\n   * Set observed measurements for this transaction.\n   * @hidden\n   */\n\n\n  Transaction.prototype.setMeasurements = function (measurements) {\n    this._measurements = __assign({}, measurements);\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  Transaction.prototype.finish = function (endTimestamp) {\n    var _this = this; // This transaction is already finished, so we should not flush it again.\n\n\n    if (this.endTimestamp !== undefined) {\n      return undefined;\n    }\n\n    if (!this.name) {\n      logger.warn('Transaction has no name, falling back to `<unlabeled transaction>`.');\n      this.name = '<unlabeled transaction>';\n    } // just sets the end timestamp\n\n\n    _super.prototype.finish.call(this, endTimestamp);\n\n    if (this.sampled !== true) {\n      // At this point if `sampled !== true` we want to discard the transaction.\n      logger.log('[Tracing] Discarding transaction because its trace was not chosen to be sampled.');\n      return undefined;\n    }\n\n    var finishedSpans = this.spanRecorder ? this.spanRecorder.spans.filter(function (s) {\n      return s !== _this && s.endTimestamp;\n    }) : [];\n\n    if (this._trimEnd && finishedSpans.length > 0) {\n      this.endTimestamp = finishedSpans.reduce(function (prev, current) {\n        if (prev.endTimestamp && current.endTimestamp) {\n          return prev.endTimestamp > current.endTimestamp ? prev : current;\n        }\n\n        return prev;\n      }).endTimestamp;\n    }\n\n    var transaction = {\n      contexts: {\n        trace: this.getTraceContext()\n      },\n      spans: finishedSpans,\n      start_timestamp: this.startTimestamp,\n      tags: this.tags,\n      timestamp: this.endTimestamp,\n      transaction: this.name,\n      type: 'transaction'\n    };\n    var hasMeasurements = Object.keys(this._measurements).length > 0;\n\n    if (hasMeasurements) {\n      logger.log('[Measurements] Adding measurements to transaction', JSON.stringify(this._measurements, undefined, 2));\n      transaction.measurements = this._measurements;\n    }\n\n    return this._hub.captureEvent(transaction);\n  };\n\n  return Transaction;\n}(SpanClass);\n\nexport { Transaction };","map":{"version":3,"mappings":"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","names":["getCurrentHub","Hub","isInstanceOf","logger","Span","SpanClass","SpanRecorder","__extends","transactionContext","hub","_super","_this","_hub","name","_trimEnd","trimEnd","transaction","Transaction","maxlen","spanRecorder","add","measurements","_measurements","__assign","endTimestamp","undefined","warn","finish","call","sampled","log","finishedSpans","spans","filter","s","length","reduce","prev","current","contexts","trace","getTraceContext","start_timestamp","startTimestamp","tags","timestamp","type","hasMeasurements","Object","keys","JSON","stringify","captureEvent"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/@sentry/tracing/src/transaction.ts"],"sourcesContent":["import { getCurrentHub, Hub } from '@sentry/hub';\nimport { Event, Measurements, Transaction as TransactionInterface, TransactionContext } from '@sentry/types';\nimport { isInstanceOf, logger } from '@sentry/utils';\n\nimport { Span as SpanClass, SpanRecorder } from './span';\n\n/** JSDoc */\nexport class Transaction extends SpanClass implements TransactionInterface {\n  public name: string;\n  private _measurements: Measurements = {};\n\n  /**\n   * The reference to the current hub.\n   */\n  private readonly _hub: Hub = (getCurrentHub() as unknown) as Hub;\n\n  private readonly _trimEnd?: boolean;\n\n  /**\n   * This constructor should never be called manually. Those instrumenting tracing should use\n   * `Sentry.startTransaction()`, and internal methods should use `hub.startTransaction()`.\n   * @internal\n   * @hideconstructor\n   * @hidden\n   */\n  public constructor(transactionContext: TransactionContext, hub?: Hub) {\n    super(transactionContext);\n\n    if (isInstanceOf(hub, Hub)) {\n      this._hub = hub as Hub;\n    }\n\n    this.name = transactionContext.name ? transactionContext.name : '';\n\n    this._trimEnd = transactionContext.trimEnd;\n\n    // this is because transactions are also spans, and spans have a transaction pointer\n    this.transaction = this;\n  }\n\n  /**\n   * JSDoc\n   */\n  public setName(name: string): void {\n    this.name = name;\n  }\n\n  /**\n   * Attaches SpanRecorder to the span itself\n   * @param maxlen maximum number of spans that can be recorded\n   */\n  public initSpanRecorder(maxlen: number = 1000): void {\n    if (!this.spanRecorder) {\n      this.spanRecorder = new SpanRecorder(maxlen);\n    }\n    this.spanRecorder.add(this);\n  }\n\n  /**\n   * Set observed measurements for this transaction.\n   * @hidden\n   */\n  public setMeasurements(measurements: Measurements): void {\n    this._measurements = { ...measurements };\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public finish(endTimestamp?: number): string | undefined {\n    // This transaction is already finished, so we should not flush it again.\n    if (this.endTimestamp !== undefined) {\n      return undefined;\n    }\n\n    if (!this.name) {\n      logger.warn('Transaction has no name, falling back to `<unlabeled transaction>`.');\n      this.name = '<unlabeled transaction>';\n    }\n\n    // just sets the end timestamp\n    super.finish(endTimestamp);\n\n    if (this.sampled !== true) {\n      // At this point if `sampled !== true` we want to discard the transaction.\n      logger.log('[Tracing] Discarding transaction because its trace was not chosen to be sampled.');\n      return undefined;\n    }\n\n    const finishedSpans = this.spanRecorder ? this.spanRecorder.spans.filter(s => s !== this && s.endTimestamp) : [];\n\n    if (this._trimEnd && finishedSpans.length > 0) {\n      this.endTimestamp = finishedSpans.reduce((prev: SpanClass, current: SpanClass) => {\n        if (prev.endTimestamp && current.endTimestamp) {\n          return prev.endTimestamp > current.endTimestamp ? prev : current;\n        }\n        return prev;\n      }).endTimestamp;\n    }\n\n    const transaction: Event = {\n      contexts: {\n        trace: this.getTraceContext(),\n      },\n      spans: finishedSpans,\n      start_timestamp: this.startTimestamp,\n      tags: this.tags,\n      timestamp: this.endTimestamp,\n      transaction: this.name,\n      type: 'transaction',\n    };\n\n    const hasMeasurements = Object.keys(this._measurements).length > 0;\n\n    if (hasMeasurements) {\n      logger.log('[Measurements] Adding measurements to transaction', JSON.stringify(this._measurements, undefined, 2));\n      transaction.measurements = this._measurements;\n    }\n\n    return this._hub.captureEvent(transaction);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}