{"ast":null,"code":"import { __assign, __values } from \"tslib\";\n/* eslint-disable max-lines */\n\nimport { Scope } from '@sentry/hub';\nimport { SessionStatus } from '@sentry/types';\nimport { dateTimestampInSeconds, Dsn, isPrimitive, isThenable, logger, normalize, SentryError, SyncPromise, truncate, uuid4 } from '@sentry/utils';\nimport { setupIntegrations } from './integration';\n/**\n * Base implementation for all JavaScript SDK clients.\n *\n * Call the constructor with the corresponding backend constructor and options\n * specific to the client subclass. To access these options later, use\n * {@link Client.getOptions}. Also, the Backend instance is available via\n * {@link Client.getBackend}.\n *\n * If a Dsn is specified in the options, it will be parsed and stored. Use\n * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is\n * invalid, the constructor will throw a {@link SentryException}. Note that\n * without a valid Dsn, the SDK will not send any events to Sentry.\n *\n * Before sending an event via the backend, it is passed through\n * {@link BaseClient.prepareEvent} to add SDK information and scope data\n * (breadcrumbs and context). To add more custom information, override this\n * method and extend the resulting prepared event.\n *\n * To issue automatically created events (e.g. via instrumentation), use\n * {@link Client.captureEvent}. It will prepare the event and pass it through\n * the callback lifecycle. To issue auto-breadcrumbs, use\n * {@link Client.addBreadcrumb}.\n *\n * @example\n * class NodeClient extends BaseClient<NodeBackend, NodeOptions> {\n *   public constructor(options: NodeOptions) {\n *     super(NodeBackend, options);\n *   }\n *\n *   // ...\n * }\n */\n\nvar BaseClient =\n/** @class */\nfunction () {\n  /**\n   * Initializes this client instance.\n   *\n   * @param backendClass A constructor function to create the backend.\n   * @param options Options for the client.\n   */\n  function BaseClient(backendClass, options) {\n    /** Array of used integrations. */\n    this._integrations = {};\n    /** Number of call being processed */\n\n    this._processing = 0;\n    this._backend = new backendClass(options);\n    this._options = options;\n\n    if (options.dsn) {\n      this._dsn = new Dsn(options.dsn);\n    }\n  }\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n\n\n  BaseClient.prototype.captureException = function (exception, hint, scope) {\n    var _this = this;\n\n    var eventId = hint && hint.event_id;\n\n    this._process(this._getBackend().eventFromException(exception, hint).then(function (event) {\n      return _this._captureEvent(event, hint, scope);\n    }).then(function (result) {\n      eventId = result;\n    }));\n\n    return eventId;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  BaseClient.prototype.captureMessage = function (message, level, hint, scope) {\n    var _this = this;\n\n    var eventId = hint && hint.event_id;\n    var promisedEvent = isPrimitive(message) ? this._getBackend().eventFromMessage(String(message), level, hint) : this._getBackend().eventFromException(message, hint);\n\n    this._process(promisedEvent.then(function (event) {\n      return _this._captureEvent(event, hint, scope);\n    }).then(function (result) {\n      eventId = result;\n    }));\n\n    return eventId;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  BaseClient.prototype.captureEvent = function (event, hint, scope) {\n    var eventId = hint && hint.event_id;\n\n    this._process(this._captureEvent(event, hint, scope).then(function (result) {\n      eventId = result;\n    }));\n\n    return eventId;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  BaseClient.prototype.captureSession = function (session) {\n    if (!session.release) {\n      logger.warn('Discarded session because of missing release');\n    } else {\n      this._sendSession(session);\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  BaseClient.prototype.getDsn = function () {\n    return this._dsn;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  BaseClient.prototype.getOptions = function () {\n    return this._options;\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  BaseClient.prototype.flush = function (timeout) {\n    var _this = this;\n\n    return this._isClientProcessing(timeout).then(function (ready) {\n      return _this._getBackend().getTransport().close(timeout).then(function (transportFlushed) {\n        return ready && transportFlushed;\n      });\n    });\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  BaseClient.prototype.close = function (timeout) {\n    var _this = this;\n\n    return this.flush(timeout).then(function (result) {\n      _this.getOptions().enabled = false;\n      return result;\n    });\n  };\n  /**\n   * Sets up the integrations\n   */\n\n\n  BaseClient.prototype.setupIntegrations = function () {\n    if (this._isEnabled()) {\n      this._integrations = setupIntegrations(this._options);\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n\n\n  BaseClient.prototype.getIntegration = function (integration) {\n    try {\n      return this._integrations[integration.id] || null;\n    } catch (_oO) {\n      logger.warn(\"Cannot retrieve integration \" + integration.id + \" from the current Client\");\n      return null;\n    }\n  };\n  /** Updates existing session based on the provided event */\n\n\n  BaseClient.prototype._updateSessionFromEvent = function (session, event) {\n    var e_1, _a;\n\n    var crashed = false;\n    var errored = false;\n    var userAgent;\n    var exceptions = event.exception && event.exception.values;\n\n    if (exceptions) {\n      errored = true;\n\n      try {\n        for (var exceptions_1 = __values(exceptions), exceptions_1_1 = exceptions_1.next(); !exceptions_1_1.done; exceptions_1_1 = exceptions_1.next()) {\n          var ex = exceptions_1_1.value;\n          var mechanism = ex.mechanism;\n\n          if (mechanism && mechanism.handled === false) {\n            crashed = true;\n            break;\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (exceptions_1_1 && !exceptions_1_1.done && (_a = exceptions_1.return)) _a.call(exceptions_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n\n    var user = event.user;\n\n    if (!session.userAgent) {\n      var headers = event.request ? event.request.headers : {};\n\n      for (var key in headers) {\n        if (key.toLowerCase() === 'user-agent') {\n          userAgent = headers[key];\n          break;\n        }\n      }\n    }\n\n    session.update(__assign(__assign({}, crashed && {\n      status: SessionStatus.Crashed\n    }), {\n      user: user,\n      userAgent: userAgent,\n      errors: session.errors + Number(errored || crashed)\n    }));\n  };\n  /** Deliver captured session to Sentry */\n\n\n  BaseClient.prototype._sendSession = function (session) {\n    this._getBackend().sendSession(session);\n  };\n  /** Waits for the client to be done with processing. */\n\n\n  BaseClient.prototype._isClientProcessing = function (timeout) {\n    var _this = this;\n\n    return new SyncPromise(function (resolve) {\n      var ticked = 0;\n      var tick = 1;\n      var interval = setInterval(function () {\n        if (_this._processing == 0) {\n          clearInterval(interval);\n          resolve(true);\n        } else {\n          ticked += tick;\n\n          if (timeout && ticked >= timeout) {\n            clearInterval(interval);\n            resolve(false);\n          }\n        }\n      }, tick);\n    });\n  };\n  /** Returns the current backend. */\n\n\n  BaseClient.prototype._getBackend = function () {\n    return this._backend;\n  };\n  /** Determines whether this SDK is enabled and a valid Dsn is present. */\n\n\n  BaseClient.prototype._isEnabled = function () {\n    return this.getOptions().enabled !== false && this._dsn !== undefined;\n  };\n  /**\n   * Adds common information to events.\n   *\n   * The information includes release and environment from `options`,\n   * breadcrumbs and context (extra, tags and user) from the scope.\n   *\n   * Information that is already present in the event is never overwritten. For\n   * nested objects, such as the context, keys are merged.\n   *\n   * @param event The original event.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A new event with more information.\n   */\n\n\n  BaseClient.prototype._prepareEvent = function (event, scope, hint) {\n    var _this = this;\n\n    var _a = this.getOptions().normalizeDepth,\n        normalizeDepth = _a === void 0 ? 3 : _a;\n\n    var prepared = __assign(__assign({}, event), {\n      event_id: event.event_id || (hint && hint.event_id ? hint.event_id : uuid4()),\n      timestamp: event.timestamp || dateTimestampInSeconds()\n    });\n\n    this._applyClientOptions(prepared);\n\n    this._applyIntegrationsMetadata(prepared); // If we have scope given to us, use it as the base for further modifications.\n    // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.\n\n\n    var finalScope = scope;\n\n    if (hint && hint.captureContext) {\n      finalScope = Scope.clone(finalScope).update(hint.captureContext);\n    } // We prepare the result here with a resolved Event.\n\n\n    var result = SyncPromise.resolve(prepared); // This should be the last thing called, since we want that\n    // {@link Hub.addEventProcessor} gets the finished prepared event.\n\n    if (finalScope) {\n      // In case we have a hub we reassign it.\n      result = finalScope.applyToEvent(prepared, hint);\n    }\n\n    return result.then(function (evt) {\n      if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {\n        return _this._normalizeEvent(evt, normalizeDepth);\n      }\n\n      return evt;\n    });\n  };\n  /**\n   * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.\n   * Normalized keys:\n   * - `breadcrumbs.data`\n   * - `user`\n   * - `contexts`\n   * - `extra`\n   * @param event Event\n   * @returns Normalized event\n   */\n\n\n  BaseClient.prototype._normalizeEvent = function (event, depth) {\n    if (!event) {\n      return null;\n    }\n\n    var normalized = __assign(__assign(__assign(__assign(__assign({}, event), event.breadcrumbs && {\n      breadcrumbs: event.breadcrumbs.map(function (b) {\n        return __assign(__assign({}, b), b.data && {\n          data: normalize(b.data, depth)\n        });\n      })\n    }), event.user && {\n      user: normalize(event.user, depth)\n    }), event.contexts && {\n      contexts: normalize(event.contexts, depth)\n    }), event.extra && {\n      extra: normalize(event.extra, depth)\n    }); // event.contexts.trace stores information about a Transaction. Similarly,\n    // event.spans[] stores information about child Spans. Given that a\n    // Transaction is conceptually a Span, normalization should apply to both\n    // Transactions and Spans consistently.\n    // For now the decision is to skip normalization of Transactions and Spans,\n    // so this block overwrites the normalized event to add back the original\n    // Transaction information prior to normalization.\n\n\n    if (event.contexts && event.contexts.trace) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      normalized.contexts.trace = event.contexts.trace;\n    }\n\n    return normalized;\n  };\n  /**\n   *  Enhances event using the client configuration.\n   *  It takes care of all \"static\" values like environment, release and `dist`,\n   *  as well as truncating overly long values.\n   * @param event event instance to be enhanced\n   */\n\n\n  BaseClient.prototype._applyClientOptions = function (event) {\n    var options = this.getOptions();\n    var environment = options.environment,\n        release = options.release,\n        dist = options.dist,\n        _a = options.maxValueLength,\n        maxValueLength = _a === void 0 ? 250 : _a;\n\n    if (!('environment' in event)) {\n      event.environment = 'environment' in options ? environment : 'production';\n    }\n\n    if (event.release === undefined && release !== undefined) {\n      event.release = release;\n    }\n\n    if (event.dist === undefined && dist !== undefined) {\n      event.dist = dist;\n    }\n\n    if (event.message) {\n      event.message = truncate(event.message, maxValueLength);\n    }\n\n    var exception = event.exception && event.exception.values && event.exception.values[0];\n\n    if (exception && exception.value) {\n      exception.value = truncate(exception.value, maxValueLength);\n    }\n\n    var request = event.request;\n\n    if (request && request.url) {\n      request.url = truncate(request.url, maxValueLength);\n    }\n  };\n  /**\n   * This function adds all used integrations to the SDK info in the event.\n   * @param sdkInfo The sdkInfo of the event that will be filled with all integrations.\n   */\n\n\n  BaseClient.prototype._applyIntegrationsMetadata = function (event) {\n    var sdkInfo = event.sdk;\n    var integrationsArray = Object.keys(this._integrations);\n\n    if (sdkInfo && integrationsArray.length > 0) {\n      sdkInfo.integrations = integrationsArray;\n    }\n  };\n  /**\n   * Tells the backend to send this event\n   * @param event The Sentry event to send\n   */\n\n\n  BaseClient.prototype._sendEvent = function (event) {\n    this._getBackend().sendEvent(event);\n  };\n  /**\n   * Processes the event and logs an error in case of rejection\n   * @param event\n   * @param hint\n   * @param scope\n   */\n\n\n  BaseClient.prototype._captureEvent = function (event, hint, scope) {\n    return this._processEvent(event, hint, scope).then(function (finalEvent) {\n      return finalEvent.event_id;\n    }, function (reason) {\n      logger.error(reason);\n      return undefined;\n    });\n  };\n  /**\n   * Processes an event (either error or message) and sends it to Sentry.\n   *\n   * This also adds breadcrumbs and context information to the event. However,\n   * platform specific meta data (such as the User's IP address) must be added\n   * by the SDK implementor.\n   *\n   *\n   * @param event The event to send to Sentry.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.\n   */\n\n\n  BaseClient.prototype._processEvent = function (event, hint, scope) {\n    var _this = this; // eslint-disable-next-line @typescript-eslint/unbound-method\n\n\n    var _a = this.getOptions(),\n        beforeSend = _a.beforeSend,\n        sampleRate = _a.sampleRate;\n\n    if (!this._isEnabled()) {\n      return SyncPromise.reject(new SentryError('SDK not enabled, will not send event.'));\n    }\n\n    var isTransaction = event.type === 'transaction'; // 1.0 === 100% events are sent\n    // 0.0 === 0% events are sent\n    // Sampling for transaction happens somewhere else\n\n    if (!isTransaction && typeof sampleRate === 'number' && Math.random() > sampleRate) {\n      return SyncPromise.reject(new SentryError(\"Discarding event because it's not included in the random sample (sampling rate = \" + sampleRate + \")\"));\n    }\n\n    return this._prepareEvent(event, scope, hint).then(function (prepared) {\n      if (prepared === null) {\n        throw new SentryError('An event processor returned null, will not send event.');\n      }\n\n      var isInternalException = hint && hint.data && hint.data.__sentry__ === true;\n\n      if (isInternalException || isTransaction || !beforeSend) {\n        return prepared;\n      }\n\n      var beforeSendResult = beforeSend(prepared, hint);\n\n      if (typeof beforeSendResult === 'undefined') {\n        throw new SentryError('`beforeSend` method has to return `null` or a valid event.');\n      } else if (isThenable(beforeSendResult)) {\n        return beforeSendResult.then(function (event) {\n          return event;\n        }, function (e) {\n          throw new SentryError(\"beforeSend rejected with \" + e);\n        });\n      }\n\n      return beforeSendResult;\n    }).then(function (processedEvent) {\n      if (processedEvent === null) {\n        throw new SentryError('`beforeSend` returned `null`, will not send event.');\n      }\n\n      var session = scope && scope.getSession && scope.getSession();\n\n      if (!isTransaction && session) {\n        _this._updateSessionFromEvent(session, processedEvent);\n      }\n\n      _this._sendEvent(processedEvent);\n\n      return processedEvent;\n    }).then(null, function (reason) {\n      if (reason instanceof SentryError) {\n        throw reason;\n      }\n\n      _this.captureException(reason, {\n        data: {\n          __sentry__: true\n        },\n        originalException: reason\n      });\n\n      throw new SentryError(\"Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\\nReason: \" + reason);\n    });\n  };\n  /**\n   * Occupies the client with processing and event\n   */\n\n\n  BaseClient.prototype._process = function (promise) {\n    var _this = this;\n\n    this._processing += 1;\n    promise.then(function (value) {\n      _this._processing -= 1;\n      return value;\n    }, function (reason) {\n      _this._processing -= 1;\n      return reason;\n    });\n  };\n\n  return BaseClient;\n}();\n\nexport { BaseClient };","map":{"version":3,"mappings":";AAAA;;AACA,SAASA,KAAT,QAA+B,aAA/B;AACA,SAOEC,aAPF,QASO,eATP;AAUA,SACEC,sBADF,EAEEC,GAFF,EAGEC,WAHF,EAIEC,UAJF,EAKEC,MALF,EAMEC,SANF,EAOEC,WAPF,EAQEC,WARF,EASEC,QATF,EAUEC,KAVF,QAWO,eAXP;AAcA,SAA2BC,iBAA3B,QAAoD,eAApD;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCA;AAAA;AAAA;AAoBE;;;;;;AAMA,sBAAsBC,YAAtB,EAAwDC,OAAxD,EAAkE;AAZlE;AACU,yBAAkC,EAAlC;AAEV;;AACU,uBAAsB,CAAtB;AASR,SAAKC,QAAL,GAAgB,IAAIF,YAAJ,CAAiBC,OAAjB,CAAhB;AACA,SAAKE,QAAL,GAAgBF,OAAhB;;AAEA,QAAIA,OAAO,CAACG,GAAZ,EAAiB;AACf,WAAKC,IAAL,GAAY,IAAIf,GAAJ,CAAQW,OAAO,CAACG,GAAhB,CAAZ;AACD;AACF;AAED;;;AAGA;;;AACOE,0CAAP,UAAwBC,SAAxB,EAAwCC,IAAxC,EAA0DC,KAA1D,EAAuE;AAAvE;;AACE,QAAIC,OAAO,GAAuBF,IAAI,IAAIA,IAAI,CAACG,QAA/C;;AAEA,SAAKC,QAAL,CACE,KAAKC,WAAL,GACGC,kBADH,CACsBP,SADtB,EACiCC,IADjC,EAEGO,IAFH,CAEQ,iBAAK;AAAI,kBAAI,CAACC,aAAL,CAAmBC,KAAnB,EAA0BT,IAA1B,EAAgCC,KAAhC;AAAsC,KAFvD,EAGGM,IAHH,CAGQ,kBAAM;AACVL,aAAO,GAAGQ,MAAV;AACD,KALH,CADF;;AASA,WAAOR,OAAP;AACD,GAbM;AAeP;;;;;AAGOJ,wCAAP,UAAsBa,OAAtB,EAAuCC,KAAvC,EAAyDZ,IAAzD,EAA2EC,KAA3E,EAAwF;AAAxF;;AACE,QAAIC,OAAO,GAAuBF,IAAI,IAAIA,IAAI,CAACG,QAA/C;AAEA,QAAMU,aAAa,GAAG9B,WAAW,CAAC4B,OAAD,CAAX,GAClB,KAAKN,WAAL,GAAmBS,gBAAnB,CAAoCC,MAAM,CAACJ,OAAD,CAA1C,EAAqDC,KAArD,EAA4DZ,IAA5D,CADkB,GAElB,KAAKK,WAAL,GAAmBC,kBAAnB,CAAsCK,OAAtC,EAA+CX,IAA/C,CAFJ;;AAIA,SAAKI,QAAL,CACES,aAAa,CACVN,IADH,CACQ,iBAAK;AAAI,kBAAI,CAACC,aAAL,CAAmBC,KAAnB,EAA0BT,IAA1B,EAAgCC,KAAhC;AAAsC,KADvD,EAEGM,IAFH,CAEQ,kBAAM;AACVL,aAAO,GAAGQ,MAAV;AACD,KAJH,CADF;;AAQA,WAAOR,OAAP;AACD,GAhBM;AAkBP;;;;;AAGOJ,sCAAP,UAAoBW,KAApB,EAAkCT,IAAlC,EAAoDC,KAApD,EAAiE;AAC/D,QAAIC,OAAO,GAAuBF,IAAI,IAAIA,IAAI,CAACG,QAA/C;;AAEA,SAAKC,QAAL,CACE,KAAKI,aAAL,CAAmBC,KAAnB,EAA0BT,IAA1B,EAAgCC,KAAhC,EAAuCM,IAAvC,CAA4C,kBAAM;AAChDL,aAAO,GAAGQ,MAAV;AACD,KAFD,CADF;;AAMA,WAAOR,OAAP;AACD,GAVM;AAYP;;;;;AAGOJ,wCAAP,UAAsBkB,OAAtB,EAAsC;AACpC,QAAI,CAACA,OAAO,CAACC,OAAb,EAAsB;AACpBhC,YAAM,CAACiC,IAAP,CAAY,8CAAZ;AACD,KAFD,MAEO;AACL,WAAKC,YAAL,CAAkBH,OAAlB;AACD;AACF,GANM;AAQP;;;;;AAGOlB,gCAAP;AACE,WAAO,KAAKD,IAAZ;AACD,GAFM;AAIP;;;;;AAGOC,oCAAP;AACE,WAAO,KAAKH,QAAZ;AACD,GAFM;AAIP;;;;;AAGOG,+BAAP,UAAasB,OAAb,EAA6B;AAA7B;;AACE,WAAO,KAAKC,mBAAL,CAAyBD,OAAzB,EAAkCb,IAAlC,CAAuC,iBAAK;AACjD,aAAOe,KAAI,CAACjB,WAAL,GACJkB,YADI,GAEJC,KAFI,CAEEJ,OAFF,EAGJb,IAHI,CAGC,4BAAgB;AAAI,oBAAK,IAAIkB,gBAAT;AAAyB,OAH9C,CAAP;AAID,KALM,CAAP;AAMD,GAPM;AASP;;;;;AAGO3B,+BAAP,UAAasB,OAAb,EAA6B;AAA7B;;AACE,WAAO,KAAKM,KAAL,CAAWN,OAAX,EAAoBb,IAApB,CAAyB,kBAAM;AACpCe,WAAI,CAACK,UAAL,GAAkBC,OAAlB,GAA4B,KAA5B;AACA,aAAOlB,MAAP;AACD,KAHM,CAAP;AAID,GALM;AAOP;;;;;AAGOZ,2CAAP;AACE,QAAI,KAAK+B,UAAL,EAAJ,EAAuB;AACrB,WAAKC,aAAL,GAAqBvC,iBAAiB,CAAC,KAAKI,QAAN,CAAtC;AACD;AACF,GAJM;AAMP;;;;;AAGOG,wCAAP,UAA6CiC,WAA7C,EAA6E;AAC3E,QAAI;AACF,aAAQ,KAAKD,aAAL,CAAmBC,WAAW,CAACC,EAA/B,KAA4C,IAApD;AACD,KAFD,CAEE,OAAOC,GAAP,EAAY;AACZhD,YAAM,CAACiC,IAAP,CAAY,iCAA+Ba,WAAW,CAACC,EAA3C,GAA6C,0BAAzD;AACA,aAAO,IAAP;AACD;AACF,GAPM;AASP;;;AACUlC,iDAAV,UAAkCkB,OAAlC,EAAoDP,KAApD,EAAgE;;;AAC9D,QAAIyB,OAAO,GAAG,KAAd;AACA,QAAIC,OAAO,GAAG,KAAd;AACA,QAAIC,SAAJ;AACA,QAAMC,UAAU,GAAG5B,KAAK,CAACV,SAAN,IAAmBU,KAAK,CAACV,SAAN,CAAgBuC,MAAtD;;AAEA,QAAID,UAAJ,EAAgB;AACdF,aAAO,GAAG,IAAV;;;AAEA,aAAiB,yCAAUI,oCAA3B,EAA2B,oBAA3B,EAA2BA,oCAA3B,EAA6B;AAAxB,cAAMC,EAAE,uBAAR;AACH,cAAMC,SAAS,GAAGD,EAAE,CAACC,SAArB;;AACA,cAAIA,SAAS,IAAIA,SAAS,CAACC,OAAV,KAAsB,KAAvC,EAA8C;AAC5CR,mBAAO,GAAG,IAAV;AACA;AACD;AACF;;;;;;;;;;;;AACF;;AAED,QAAMS,IAAI,GAAGlC,KAAK,CAACkC,IAAnB;;AACA,QAAI,CAAC3B,OAAO,CAACoB,SAAb,EAAwB;AACtB,UAAMQ,OAAO,GAAGnC,KAAK,CAACoC,OAAN,GAAgBpC,KAAK,CAACoC,OAAN,CAAcD,OAA9B,GAAwC,EAAxD;;AACA,WAAK,IAAME,GAAX,IAAkBF,OAAlB,EAA2B;AACzB,YAAIE,GAAG,CAACC,WAAJ,OAAsB,YAA1B,EAAwC;AACtCX,mBAAS,GAAGQ,OAAO,CAACE,GAAD,CAAnB;AACA;AACD;AACF;AACF;;AAED9B,WAAO,CAACgC,MAAR,CAAcC,sBACRf,OAAO,IAAI;AAAEgB,YAAM,EAAEtE,aAAa,CAACuE;AAAxB,KADH,GACqC;AACjDR,UAAI,MAD6C;AAEjDP,eAAS,WAFwC;AAGjDgB,YAAM,EAAEpC,OAAO,CAACoC,MAAR,GAAiBC,MAAM,CAAClB,OAAO,IAAID,OAAZ;AAHkB,KADrC,CAAd;AAMD,GAnCS;AAqCV;;;AACUpC,sCAAV,UAAuBkB,OAAvB,EAAuC;AACrC,SAAKX,WAAL,GAAmBiD,WAAnB,CAA+BtC,OAA/B;AACD,GAFS;AAIV;;;AACUlB,6CAAV,UAA8BsB,OAA9B,EAA8C;AAA9C;;AACE,WAAO,IAAIhC,WAAJ,CAAgB,mBAAO;AAC5B,UAAImE,MAAM,GAAW,CAArB;AACA,UAAMC,IAAI,GAAW,CAArB;AAEA,UAAMC,QAAQ,GAAGC,WAAW,CAAC;AAC3B,YAAIpC,KAAI,CAACqC,WAAL,IAAoB,CAAxB,EAA2B;AACzBC,uBAAa,CAACH,QAAD,CAAb;AACAI,iBAAO,CAAC,IAAD,CAAP;AACD,SAHD,MAGO;AACLN,gBAAM,IAAIC,IAAV;;AACA,cAAIpC,OAAO,IAAImC,MAAM,IAAInC,OAAzB,EAAkC;AAChCwC,yBAAa,CAACH,QAAD,CAAb;AACAI,mBAAO,CAAC,KAAD,CAAP;AACD;AACF;AACF,OAX2B,EAWzBL,IAXyB,CAA5B;AAYD,KAhBM,CAAP;AAiBD,GAlBS;AAoBV;;;AACU1D,qCAAV;AACE,WAAO,KAAKJ,QAAZ;AACD,GAFS;AAIV;;;AACUI,oCAAV;AACE,WAAO,KAAK6B,UAAL,GAAkBC,OAAlB,KAA8B,KAA9B,IAAuC,KAAK/B,IAAL,KAAciE,SAA5D;AACD,GAFS;AAIV;;;;;;;;;;;;;;;;AAcUhE,uCAAV,UAAwBW,KAAxB,EAAsCR,KAAtC,EAAqDD,IAArD,EAAqE;AAArE;;AACU;AAAA;;AACR,QAAM+D,QAAQ,yBACTtD,KADS,GACJ;AACRN,cAAQ,EAAEM,KAAK,CAACN,QAAN,KAAmBH,IAAI,IAAIA,IAAI,CAACG,QAAb,GAAwBH,IAAI,CAACG,QAA7B,GAAwCb,KAAK,EAAhE,CADF;AAER0E,eAAS,EAAEvD,KAAK,CAACuD,SAAN,IAAmBnF,sBAAsB;AAF5C,KADI,CAAd;;AAMA,SAAKoF,mBAAL,CAAyBF,QAAzB;;AACA,SAAKG,0BAAL,CAAgCH,QAAhC,EATmE,CAWnE;AACA;;;AACA,QAAII,UAAU,GAAGlE,KAAjB;;AACA,QAAID,IAAI,IAAIA,IAAI,CAACoE,cAAjB,EAAiC;AAC/BD,gBAAU,GAAGxF,KAAK,CAAC0F,KAAN,CAAYF,UAAZ,EAAwBnB,MAAxB,CAA+BhD,IAAI,CAACoE,cAApC,CAAb;AACD,KAhBkE,CAkBnE;;;AACA,QAAI1D,MAAM,GAAGtB,WAAW,CAACyE,OAAZ,CAAkCE,QAAlC,CAAb,CAnBmE,CAqBnE;AACA;;AACA,QAAII,UAAJ,EAAgB;AACd;AACAzD,YAAM,GAAGyD,UAAU,CAACG,YAAX,CAAwBP,QAAxB,EAAkC/D,IAAlC,CAAT;AACD;;AAED,WAAOU,MAAM,CAACH,IAAP,CAAY,eAAG;AACpB,UAAI,OAAOgE,cAAP,KAA0B,QAA1B,IAAsCA,cAAc,GAAG,CAA3D,EAA8D;AAC5D,eAAOjD,KAAI,CAACkD,eAAL,CAAqBC,GAArB,EAA0BF,cAA1B,CAAP;AACD;;AACD,aAAOE,GAAP;AACD,KALM,CAAP;AAMD,GAlCS;AAoCV;;;;;;;;;;;;AAUU3E,yCAAV,UAA0BW,KAA1B,EAA+CiE,KAA/C,EAA4D;AAC1D,QAAI,CAACjE,KAAL,EAAY;AACV,aAAO,IAAP;AACD;;AAED,QAAMkE,UAAU,oDACXlE,KADW,GAEVA,KAAK,CAACmE,WAAN,IAAqB;AACvBA,iBAAW,EAAEnE,KAAK,CAACmE,WAAN,CAAkBC,GAAlB,CAAsB,aAAC;AAAI,qCACnCC,CADmC,GAElCA,CAAC,CAACC,IAAF,IAAU;AACZA,cAAI,EAAE7F,SAAS,CAAC4F,CAAC,CAACC,IAAH,EAASL,KAAT;AADH,SAFwB;AAKtC,OALW;AADU,KAFX,GAUVjE,KAAK,CAACkC,IAAN,IAAc;AAChBA,UAAI,EAAEzD,SAAS,CAACuB,KAAK,CAACkC,IAAP,EAAa+B,KAAb;AADC,KAVJ,GAaVjE,KAAK,CAACuE,QAAN,IAAkB;AACpBA,cAAQ,EAAE9F,SAAS,CAACuB,KAAK,CAACuE,QAAP,EAAiBN,KAAjB;AADC,KAbR,GAgBVjE,KAAK,CAACwE,KAAN,IAAe;AACjBA,WAAK,EAAE/F,SAAS,CAACuB,KAAK,CAACwE,KAAP,EAAcP,KAAd;AADC,KAhBL,CAAhB,CAL0D,CAyB1D;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,QAAIjE,KAAK,CAACuE,QAAN,IAAkBvE,KAAK,CAACuE,QAAN,CAAeE,KAArC,EAA4C;AAC1C;AACAP,gBAAU,CAACK,QAAX,CAAoBE,KAApB,GAA4BzE,KAAK,CAACuE,QAAN,CAAeE,KAA3C;AACD;;AACD,WAAOP,UAAP;AACD,GArCS;AAuCV;;;;;;;;AAMU7E,6CAAV,UAA8BW,KAA9B,EAA0C;AACxC,QAAMhB,OAAO,GAAG,KAAKkC,UAAL,EAAhB;AACQ;AAAA,QAAaV,yBAAb;AAAA,QAAsBkE,mBAAtB;AAAA,QAA4BC,2BAA5B;AAAA,QAA4BC,yCAA5B;;AAER,QAAI,EAAE,iBAAiB5E,KAAnB,CAAJ,EAA+B;AAC7BA,WAAK,CAAC6E,WAAN,GAAoB,iBAAiB7F,OAAjB,GAA2B6F,WAA3B,GAAyC,YAA7D;AACD;;AAED,QAAI7E,KAAK,CAACQ,OAAN,KAAkB6C,SAAlB,IAA+B7C,OAAO,KAAK6C,SAA/C,EAA0D;AACxDrD,WAAK,CAACQ,OAAN,GAAgBA,OAAhB;AACD;;AAED,QAAIR,KAAK,CAAC0E,IAAN,KAAerB,SAAf,IAA4BqB,IAAI,KAAKrB,SAAzC,EAAoD;AAClDrD,WAAK,CAAC0E,IAAN,GAAaA,IAAb;AACD;;AAED,QAAI1E,KAAK,CAACE,OAAV,EAAmB;AACjBF,WAAK,CAACE,OAAN,GAAgBtB,QAAQ,CAACoB,KAAK,CAACE,OAAP,EAAgB0E,cAAhB,CAAxB;AACD;;AAED,QAAMtF,SAAS,GAAGU,KAAK,CAACV,SAAN,IAAmBU,KAAK,CAACV,SAAN,CAAgBuC,MAAnC,IAA6C7B,KAAK,CAACV,SAAN,CAAgBuC,MAAhB,CAAuB,CAAvB,CAA/D;;AACA,QAAIvC,SAAS,IAAIA,SAAS,CAACwF,KAA3B,EAAkC;AAChCxF,eAAS,CAACwF,KAAV,GAAkBlG,QAAQ,CAACU,SAAS,CAACwF,KAAX,EAAkBF,cAAlB,CAA1B;AACD;;AAED,QAAMxC,OAAO,GAAGpC,KAAK,CAACoC,OAAtB;;AACA,QAAIA,OAAO,IAAIA,OAAO,CAAC2C,GAAvB,EAA4B;AAC1B3C,aAAO,CAAC2C,GAAR,GAAcnG,QAAQ,CAACwD,OAAO,CAAC2C,GAAT,EAAcH,cAAd,CAAtB;AACD;AACF,GA7BS;AA+BV;;;;;;AAIUvF,oDAAV,UAAqCW,KAArC,EAAiD;AAC/C,QAAMgF,OAAO,GAAGhF,KAAK,CAACiF,GAAtB;AACA,QAAMC,iBAAiB,GAAGC,MAAM,CAACC,IAAP,CAAY,KAAK/D,aAAjB,CAA1B;;AACA,QAAI2D,OAAO,IAAIE,iBAAiB,CAACG,MAAlB,GAA2B,CAA1C,EAA6C;AAC3CL,aAAO,CAACM,YAAR,GAAuBJ,iBAAvB;AACD;AACF,GANS;AAQV;;;;;;AAIU7F,oCAAV,UAAqBW,KAArB,EAAiC;AAC/B,SAAKJ,WAAL,GAAmB2F,SAAnB,CAA6BvF,KAA7B;AACD,GAFS;AAIV;;;;;;;;AAMUX,uCAAV,UAAwBW,KAAxB,EAAsCT,IAAtC,EAAwDC,KAAxD,EAAqE;AACnE,WAAO,KAAKgG,aAAL,CAAmBxF,KAAnB,EAA0BT,IAA1B,EAAgCC,KAAhC,EAAuCM,IAAvC,CACL,sBAAU;AACR,aAAO2F,UAAU,CAAC/F,QAAlB;AACD,KAHI,EAIL,kBAAM;AACJlB,YAAM,CAACkH,KAAP,CAAaC,MAAb;AACA,aAAOtC,SAAP;AACD,KAPI,CAAP;AASD,GAVS;AAYV;;;;;;;;;;;;;;;AAaUhE,uCAAV,UAAwBW,KAAxB,EAAsCT,IAAtC,EAAwDC,KAAxD,EAAqE;AAArE,qBAAqE,CACnE;;;AACM;AAAA,QAAEoG,0BAAF;AAAA,QAAcC,0BAAd;;AAEN,QAAI,CAAC,KAAKzE,UAAL,EAAL,EAAwB;AACtB,aAAOzC,WAAW,CAACmH,MAAZ,CAAmB,IAAIpH,WAAJ,CAAgB,uCAAhB,CAAnB,CAAP;AACD;;AAED,QAAMqH,aAAa,GAAG/F,KAAK,CAACgG,IAAN,KAAe,aAArC,CARmE,CASnE;AACA;AACA;;AACA,QAAI,CAACD,aAAD,IAAkB,OAAOF,UAAP,KAAsB,QAAxC,IAAoDI,IAAI,CAACC,MAAL,KAAgBL,UAAxE,EAAoF;AAClF,aAAOlH,WAAW,CAACmH,MAAZ,CACL,IAAIpH,WAAJ,CACE,sFAAoFmH,UAApF,GAA8F,GADhG,CADK,CAAP;AAKD;;AAED,WAAO,KAAKM,aAAL,CAAmBnG,KAAnB,EAA0BR,KAA1B,EAAiCD,IAAjC,EACJO,IADI,CACC,oBAAQ;AACZ,UAAIwD,QAAQ,KAAK,IAAjB,EAAuB;AACrB,cAAM,IAAI5E,WAAJ,CAAgB,wDAAhB,CAAN;AACD;;AAED,UAAM0H,mBAAmB,GAAG7G,IAAI,IAAIA,IAAI,CAAC+E,IAAb,IAAsB/E,IAAI,CAAC+E,IAAL,CAAsC+B,UAAtC,KAAqD,IAAvG;;AACA,UAAID,mBAAmB,IAAIL,aAAvB,IAAwC,CAACH,UAA7C,EAAyD;AACvD,eAAOtC,QAAP;AACD;;AAED,UAAMgD,gBAAgB,GAAGV,UAAU,CAACtC,QAAD,EAAW/D,IAAX,CAAnC;;AACA,UAAI,OAAO+G,gBAAP,KAA4B,WAAhC,EAA6C;AAC3C,cAAM,IAAI5H,WAAJ,CAAgB,4DAAhB,CAAN;AACD,OAFD,MAEO,IAAIH,UAAU,CAAC+H,gBAAD,CAAd,EAAkC;AACvC,eAAQA,gBAA8C,CAACxG,IAA/C,CACN,iBAAK;AAAI;AAAK,SADR,EAEN,aAAC;AACC,gBAAM,IAAIpB,WAAJ,CAAgB,8BAA4B6H,CAA5C,CAAN;AACD,SAJK,CAAR;AAMD;;AACD,aAAOD,gBAAP;AACD,KAvBI,EAwBJxG,IAxBI,CAwBC,0BAAc;AAClB,UAAI0G,cAAc,KAAK,IAAvB,EAA6B;AAC3B,cAAM,IAAI9H,WAAJ,CAAgB,oDAAhB,CAAN;AACD;;AAED,UAAM6B,OAAO,GAAGf,KAAK,IAAIA,KAAK,CAACiH,UAAf,IAA6BjH,KAAK,CAACiH,UAAN,EAA7C;;AACA,UAAI,CAACV,aAAD,IAAkBxF,OAAtB,EAA+B;AAC7BM,aAAI,CAAC6F,uBAAL,CAA6BnG,OAA7B,EAAsCiG,cAAtC;AACD;;AAED3F,WAAI,CAAC8F,UAAL,CAAgBH,cAAhB;;AACA,aAAOA,cAAP;AACD,KApCI,EAqCJ1G,IArCI,CAqCC,IArCD,EAqCO,kBAAM;AAChB,UAAI6F,MAAM,YAAYjH,WAAtB,EAAmC;AACjC,cAAMiH,MAAN;AACD;;AAED9E,WAAI,CAAC+F,gBAAL,CAAsBjB,MAAtB,EAA8B;AAC5BrB,YAAI,EAAE;AACJ+B,oBAAU,EAAE;AADR,SADsB;AAI5BQ,yBAAiB,EAAElB;AAJS,OAA9B;;AAMA,YAAM,IAAIjH,WAAJ,CACJ,gIAA8HiH,MAD1H,CAAN;AAGD,KAnDI,CAAP;AAoDD,GAxES;AA0EV;;;;;AAGUtG,kCAAV,UAAsByH,OAAtB,EAA6C;AAA7C;;AACE,SAAK5D,WAAL,IAAoB,CAApB;AACA4D,WAAO,CAAChH,IAAR,CACE,iBAAK;AACHe,WAAI,CAACqC,WAAL,IAAoB,CAApB;AACA,aAAO4B,KAAP;AACD,KAJH,EAKE,kBAAM;AACJjE,WAAI,CAACqC,WAAL,IAAoB,CAApB;AACA,aAAOyC,MAAP;AACD,KARH;AAUD,GAZS;;AAaZ;AAAC,CA7fD","names":["Scope","SessionStatus","dateTimestampInSeconds","Dsn","isPrimitive","isThenable","logger","normalize","SentryError","SyncPromise","truncate","uuid4","setupIntegrations","backendClass","options","_backend","_options","dsn","_dsn","BaseClient","exception","hint","scope","eventId","event_id","_process","_getBackend","eventFromException","then","_captureEvent","event","result","message","level","promisedEvent","eventFromMessage","String","session","release","warn","_sendSession","timeout","_isClientProcessing","_this","getTransport","close","transportFlushed","flush","getOptions","enabled","_isEnabled","_integrations","integration","id","_oO","crashed","errored","userAgent","exceptions","values","exceptions_1_1","ex","mechanism","handled","user","headers","request","key","toLowerCase","update","__assign","status","Crashed","errors","Number","sendSession","ticked","tick","interval","setInterval","_processing","clearInterval","resolve","undefined","prepared","timestamp","_applyClientOptions","_applyIntegrationsMetadata","finalScope","captureContext","clone","applyToEvent","normalizeDepth","_normalizeEvent","evt","depth","normalized","breadcrumbs","map","b","data","contexts","extra","trace","dist","_a","maxValueLength","environment","value","url","sdkInfo","sdk","integrationsArray","Object","keys","length","integrations","sendEvent","_processEvent","finalEvent","error","reason","beforeSend","sampleRate","reject","isTransaction","type","Math","random","_prepareEvent","isInternalException","__sentry__","beforeSendResult","e","processedEvent","getSession","_updateSessionFromEvent","_sendEvent","captureException","originalException","promise"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/@sentry/core/src/baseclient.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport { Scope, Session } from '@sentry/hub';\nimport {\n  Client,\n  Event,\n  EventHint,\n  Integration,\n  IntegrationClass,\n  Options,\n  SessionStatus,\n  Severity,\n} from '@sentry/types';\nimport {\n  dateTimestampInSeconds,\n  Dsn,\n  isPrimitive,\n  isThenable,\n  logger,\n  normalize,\n  SentryError,\n  SyncPromise,\n  truncate,\n  uuid4,\n} from '@sentry/utils';\n\nimport { Backend, BackendClass } from './basebackend';\nimport { IntegrationIndex, setupIntegrations } from './integration';\n\n/**\n * Base implementation for all JavaScript SDK clients.\n *\n * Call the constructor with the corresponding backend constructor and options\n * specific to the client subclass. To access these options later, use\n * {@link Client.getOptions}. Also, the Backend instance is available via\n * {@link Client.getBackend}.\n *\n * If a Dsn is specified in the options, it will be parsed and stored. Use\n * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is\n * invalid, the constructor will throw a {@link SentryException}. Note that\n * without a valid Dsn, the SDK will not send any events to Sentry.\n *\n * Before sending an event via the backend, it is passed through\n * {@link BaseClient.prepareEvent} to add SDK information and scope data\n * (breadcrumbs and context). To add more custom information, override this\n * method and extend the resulting prepared event.\n *\n * To issue automatically created events (e.g. via instrumentation), use\n * {@link Client.captureEvent}. It will prepare the event and pass it through\n * the callback lifecycle. To issue auto-breadcrumbs, use\n * {@link Client.addBreadcrumb}.\n *\n * @example\n * class NodeClient extends BaseClient<NodeBackend, NodeOptions> {\n *   public constructor(options: NodeOptions) {\n *     super(NodeBackend, options);\n *   }\n *\n *   // ...\n * }\n */\nexport abstract class BaseClient<B extends Backend, O extends Options> implements Client<O> {\n  /**\n   * The backend used to physically interact in the environment. Usually, this\n   * will correspond to the client. When composing SDKs, however, the Backend\n   * from the root SDK will be used.\n   */\n  protected readonly _backend: B;\n\n  /** Options passed to the SDK. */\n  protected readonly _options: O;\n\n  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */\n  protected readonly _dsn?: Dsn;\n\n  /** Array of used integrations. */\n  protected _integrations: IntegrationIndex = {};\n\n  /** Number of call being processed */\n  protected _processing: number = 0;\n\n  /**\n   * Initializes this client instance.\n   *\n   * @param backendClass A constructor function to create the backend.\n   * @param options Options for the client.\n   */\n  protected constructor(backendClass: BackendClass<B, O>, options: O) {\n    this._backend = new backendClass(options);\n    this._options = options;\n\n    if (options.dsn) {\n      this._dsn = new Dsn(options.dsn);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  public captureException(exception: any, hint?: EventHint, scope?: Scope): string | undefined {\n    let eventId: string | undefined = hint && hint.event_id;\n\n    this._process(\n      this._getBackend()\n        .eventFromException(exception, hint)\n        .then(event => this._captureEvent(event, hint, scope))\n        .then(result => {\n          eventId = result;\n        }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureMessage(message: string, level?: Severity, hint?: EventHint, scope?: Scope): string | undefined {\n    let eventId: string | undefined = hint && hint.event_id;\n\n    const promisedEvent = isPrimitive(message)\n      ? this._getBackend().eventFromMessage(String(message), level, hint)\n      : this._getBackend().eventFromException(message, hint);\n\n    this._process(\n      promisedEvent\n        .then(event => this._captureEvent(event, hint, scope))\n        .then(result => {\n          eventId = result;\n        }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureEvent(event: Event, hint?: EventHint, scope?: Scope): string | undefined {\n    let eventId: string | undefined = hint && hint.event_id;\n\n    this._process(\n      this._captureEvent(event, hint, scope).then(result => {\n        eventId = result;\n      }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureSession(session: Session): void {\n    if (!session.release) {\n      logger.warn('Discarded session because of missing release');\n    } else {\n      this._sendSession(session);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getDsn(): Dsn | undefined {\n    return this._dsn;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getOptions(): O {\n    return this._options;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public flush(timeout?: number): PromiseLike<boolean> {\n    return this._isClientProcessing(timeout).then(ready => {\n      return this._getBackend()\n        .getTransport()\n        .close(timeout)\n        .then(transportFlushed => ready && transportFlushed);\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public close(timeout?: number): PromiseLike<boolean> {\n    return this.flush(timeout).then(result => {\n      this.getOptions().enabled = false;\n      return result;\n    });\n  }\n\n  /**\n   * Sets up the integrations\n   */\n  public setupIntegrations(): void {\n    if (this._isEnabled()) {\n      this._integrations = setupIntegrations(this._options);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getIntegration<T extends Integration>(integration: IntegrationClass<T>): T | null {\n    try {\n      return (this._integrations[integration.id] as T) || null;\n    } catch (_oO) {\n      logger.warn(`Cannot retrieve integration ${integration.id} from the current Client`);\n      return null;\n    }\n  }\n\n  /** Updates existing session based on the provided event */\n  protected _updateSessionFromEvent(session: Session, event: Event): void {\n    let crashed = false;\n    let errored = false;\n    let userAgent;\n    const exceptions = event.exception && event.exception.values;\n\n    if (exceptions) {\n      errored = true;\n\n      for (const ex of exceptions) {\n        const mechanism = ex.mechanism;\n        if (mechanism && mechanism.handled === false) {\n          crashed = true;\n          break;\n        }\n      }\n    }\n\n    const user = event.user;\n    if (!session.userAgent) {\n      const headers = event.request ? event.request.headers : {};\n      for (const key in headers) {\n        if (key.toLowerCase() === 'user-agent') {\n          userAgent = headers[key];\n          break;\n        }\n      }\n    }\n\n    session.update({\n      ...(crashed && { status: SessionStatus.Crashed }),\n      user,\n      userAgent,\n      errors: session.errors + Number(errored || crashed),\n    });\n  }\n\n  /** Deliver captured session to Sentry */\n  protected _sendSession(session: Session): void {\n    this._getBackend().sendSession(session);\n  }\n\n  /** Waits for the client to be done with processing. */\n  protected _isClientProcessing(timeout?: number): PromiseLike<boolean> {\n    return new SyncPromise(resolve => {\n      let ticked: number = 0;\n      const tick: number = 1;\n\n      const interval = setInterval(() => {\n        if (this._processing == 0) {\n          clearInterval(interval);\n          resolve(true);\n        } else {\n          ticked += tick;\n          if (timeout && ticked >= timeout) {\n            clearInterval(interval);\n            resolve(false);\n          }\n        }\n      }, tick);\n    });\n  }\n\n  /** Returns the current backend. */\n  protected _getBackend(): B {\n    return this._backend;\n  }\n\n  /** Determines whether this SDK is enabled and a valid Dsn is present. */\n  protected _isEnabled(): boolean {\n    return this.getOptions().enabled !== false && this._dsn !== undefined;\n  }\n\n  /**\n   * Adds common information to events.\n   *\n   * The information includes release and environment from `options`,\n   * breadcrumbs and context (extra, tags and user) from the scope.\n   *\n   * Information that is already present in the event is never overwritten. For\n   * nested objects, such as the context, keys are merged.\n   *\n   * @param event The original event.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A new event with more information.\n   */\n  protected _prepareEvent(event: Event, scope?: Scope, hint?: EventHint): PromiseLike<Event | null> {\n    const { normalizeDepth = 3 } = this.getOptions();\n    const prepared: Event = {\n      ...event,\n      event_id: event.event_id || (hint && hint.event_id ? hint.event_id : uuid4()),\n      timestamp: event.timestamp || dateTimestampInSeconds(),\n    };\n\n    this._applyClientOptions(prepared);\n    this._applyIntegrationsMetadata(prepared);\n\n    // If we have scope given to us, use it as the base for further modifications.\n    // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.\n    let finalScope = scope;\n    if (hint && hint.captureContext) {\n      finalScope = Scope.clone(finalScope).update(hint.captureContext);\n    }\n\n    // We prepare the result here with a resolved Event.\n    let result = SyncPromise.resolve<Event | null>(prepared);\n\n    // This should be the last thing called, since we want that\n    // {@link Hub.addEventProcessor} gets the finished prepared event.\n    if (finalScope) {\n      // In case we have a hub we reassign it.\n      result = finalScope.applyToEvent(prepared, hint);\n    }\n\n    return result.then(evt => {\n      if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {\n        return this._normalizeEvent(evt, normalizeDepth);\n      }\n      return evt;\n    });\n  }\n\n  /**\n   * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.\n   * Normalized keys:\n   * - `breadcrumbs.data`\n   * - `user`\n   * - `contexts`\n   * - `extra`\n   * @param event Event\n   * @returns Normalized event\n   */\n  protected _normalizeEvent(event: Event | null, depth: number): Event | null {\n    if (!event) {\n      return null;\n    }\n\n    const normalized = {\n      ...event,\n      ...(event.breadcrumbs && {\n        breadcrumbs: event.breadcrumbs.map(b => ({\n          ...b,\n          ...(b.data && {\n            data: normalize(b.data, depth),\n          }),\n        })),\n      }),\n      ...(event.user && {\n        user: normalize(event.user, depth),\n      }),\n      ...(event.contexts && {\n        contexts: normalize(event.contexts, depth),\n      }),\n      ...(event.extra && {\n        extra: normalize(event.extra, depth),\n      }),\n    };\n    // event.contexts.trace stores information about a Transaction. Similarly,\n    // event.spans[] stores information about child Spans. Given that a\n    // Transaction is conceptually a Span, normalization should apply to both\n    // Transactions and Spans consistently.\n    // For now the decision is to skip normalization of Transactions and Spans,\n    // so this block overwrites the normalized event to add back the original\n    // Transaction information prior to normalization.\n    if (event.contexts && event.contexts.trace) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      normalized.contexts.trace = event.contexts.trace;\n    }\n    return normalized;\n  }\n\n  /**\n   *  Enhances event using the client configuration.\n   *  It takes care of all \"static\" values like environment, release and `dist`,\n   *  as well as truncating overly long values.\n   * @param event event instance to be enhanced\n   */\n  protected _applyClientOptions(event: Event): void {\n    const options = this.getOptions();\n    const { environment, release, dist, maxValueLength = 250 } = options;\n\n    if (!('environment' in event)) {\n      event.environment = 'environment' in options ? environment : 'production';\n    }\n\n    if (event.release === undefined && release !== undefined) {\n      event.release = release;\n    }\n\n    if (event.dist === undefined && dist !== undefined) {\n      event.dist = dist;\n    }\n\n    if (event.message) {\n      event.message = truncate(event.message, maxValueLength);\n    }\n\n    const exception = event.exception && event.exception.values && event.exception.values[0];\n    if (exception && exception.value) {\n      exception.value = truncate(exception.value, maxValueLength);\n    }\n\n    const request = event.request;\n    if (request && request.url) {\n      request.url = truncate(request.url, maxValueLength);\n    }\n  }\n\n  /**\n   * This function adds all used integrations to the SDK info in the event.\n   * @param sdkInfo The sdkInfo of the event that will be filled with all integrations.\n   */\n  protected _applyIntegrationsMetadata(event: Event): void {\n    const sdkInfo = event.sdk;\n    const integrationsArray = Object.keys(this._integrations);\n    if (sdkInfo && integrationsArray.length > 0) {\n      sdkInfo.integrations = integrationsArray;\n    }\n  }\n\n  /**\n   * Tells the backend to send this event\n   * @param event The Sentry event to send\n   */\n  protected _sendEvent(event: Event): void {\n    this._getBackend().sendEvent(event);\n  }\n\n  /**\n   * Processes the event and logs an error in case of rejection\n   * @param event\n   * @param hint\n   * @param scope\n   */\n  protected _captureEvent(event: Event, hint?: EventHint, scope?: Scope): PromiseLike<string | undefined> {\n    return this._processEvent(event, hint, scope).then(\n      finalEvent => {\n        return finalEvent.event_id;\n      },\n      reason => {\n        logger.error(reason);\n        return undefined;\n      },\n    );\n  }\n\n  /**\n   * Processes an event (either error or message) and sends it to Sentry.\n   *\n   * This also adds breadcrumbs and context information to the event. However,\n   * platform specific meta data (such as the User's IP address) must be added\n   * by the SDK implementor.\n   *\n   *\n   * @param event The event to send to Sentry.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.\n   */\n  protected _processEvent(event: Event, hint?: EventHint, scope?: Scope): PromiseLike<Event> {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const { beforeSend, sampleRate } = this.getOptions();\n\n    if (!this._isEnabled()) {\n      return SyncPromise.reject(new SentryError('SDK not enabled, will not send event.'));\n    }\n\n    const isTransaction = event.type === 'transaction';\n    // 1.0 === 100% events are sent\n    // 0.0 === 0% events are sent\n    // Sampling for transaction happens somewhere else\n    if (!isTransaction && typeof sampleRate === 'number' && Math.random() > sampleRate) {\n      return SyncPromise.reject(\n        new SentryError(\n          `Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`,\n        ),\n      );\n    }\n\n    return this._prepareEvent(event, scope, hint)\n      .then(prepared => {\n        if (prepared === null) {\n          throw new SentryError('An event processor returned null, will not send event.');\n        }\n\n        const isInternalException = hint && hint.data && (hint.data as { __sentry__: boolean }).__sentry__ === true;\n        if (isInternalException || isTransaction || !beforeSend) {\n          return prepared;\n        }\n\n        const beforeSendResult = beforeSend(prepared, hint);\n        if (typeof beforeSendResult === 'undefined') {\n          throw new SentryError('`beforeSend` method has to return `null` or a valid event.');\n        } else if (isThenable(beforeSendResult)) {\n          return (beforeSendResult as PromiseLike<Event | null>).then(\n            event => event,\n            e => {\n              throw new SentryError(`beforeSend rejected with ${e}`);\n            },\n          );\n        }\n        return beforeSendResult;\n      })\n      .then(processedEvent => {\n        if (processedEvent === null) {\n          throw new SentryError('`beforeSend` returned `null`, will not send event.');\n        }\n\n        const session = scope && scope.getSession && scope.getSession();\n        if (!isTransaction && session) {\n          this._updateSessionFromEvent(session, processedEvent);\n        }\n\n        this._sendEvent(processedEvent);\n        return processedEvent;\n      })\n      .then(null, reason => {\n        if (reason instanceof SentryError) {\n          throw reason;\n        }\n\n        this.captureException(reason, {\n          data: {\n            __sentry__: true,\n          },\n          originalException: reason as Error,\n        });\n        throw new SentryError(\n          `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\\nReason: ${reason}`,\n        );\n      });\n  }\n\n  /**\n   * Occupies the client with processing and event\n   */\n  protected _process<T>(promise: PromiseLike<T>): void {\n    this._processing += 1;\n    promise.then(\n      value => {\n        this._processing -= 1;\n        return value;\n      },\n      reason => {\n        this._processing -= 1;\n        return reason;\n      },\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}