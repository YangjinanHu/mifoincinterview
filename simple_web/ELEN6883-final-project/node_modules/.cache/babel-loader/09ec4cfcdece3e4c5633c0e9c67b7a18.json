{"ast":null,"code":"\"use strict\";\n/**\n * This file includes Solidity tracing heuristics for solc starting with version\n * 0.6.9.\n *\n * This solc version introduced a significant change to how sourcemaps are\n * handled for inline yul/internal functions. These were mapped to the\n * unmapped/-1 file before, which lead to many unmapped reverts. Now, they are\n * mapped to the part of the Solidity source that lead to their inlining.\n *\n * This change is a very positive change, as errors would point to the correct\n * line by default. The only problem is that we used to rely very heavily on\n * unmapped reverts to decide when our error detection heuristics were to be\n * run. In fact, this heuristics were first introduced because of unmapped\n * reverts.\n *\n * Instead of synthetically completing stack traces when unmapped reverts occur,\n * we now start from complete stack traces and adjust them if we can provide\n * more meaningful errors.\n */\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.adjustStackTrace = exports.stackTraceMayRequireAdjustments = void 0;\n\nconst semver_1 = __importDefault(require(\"semver\"));\n\nconst message_trace_1 = require(\"./message-trace\");\n\nconst opcodes_1 = require(\"./opcodes\");\n\nconst solidity_stack_trace_1 = require(\"./solidity-stack-trace\");\n\nconst FIRST_SOLC_VERSION_WITH_MAPPED_SMALL_INTERNAL_FUNCTIONS = \"0.6.9\";\n\nfunction stackTraceMayRequireAdjustments(stackTrace, decodedTrace) {\n  if (stackTrace.length === 0) {\n    return false;\n  }\n\n  const lastFrame = stackTrace[stackTrace.length - 1];\n  return lastFrame.type === solidity_stack_trace_1.StackTraceEntryType.REVERT_ERROR && !lastFrame.isInvalidOpcodeError && lastFrame.message.isEmpty() && semver_1.default.gte(decodedTrace.bytecode.compilerVersion, FIRST_SOLC_VERSION_WITH_MAPPED_SMALL_INTERNAL_FUNCTIONS);\n}\n\nexports.stackTraceMayRequireAdjustments = stackTraceMayRequireAdjustments;\n\nfunction adjustStackTrace(stackTrace, decodedTrace) {\n  const start = stackTrace.slice(0, -1);\n  const [revert] = stackTrace.slice(-1);\n\n  if (isNonContractAccountCalledError(decodedTrace)) {\n    return [...start, {\n      type: solidity_stack_trace_1.StackTraceEntryType.NONCONTRACT_ACCOUNT_CALLED_ERROR,\n      sourceReference: revert.sourceReference\n    }];\n  }\n\n  if (isConstructorInvalidParamsError(decodedTrace)) {\n    return [...start, {\n      type: solidity_stack_trace_1.StackTraceEntryType.INVALID_PARAMS_ERROR,\n      sourceReference: revert.sourceReference\n    }];\n  }\n\n  if (isCallInvalidParamsError(decodedTrace)) {\n    return [...start, {\n      type: solidity_stack_trace_1.StackTraceEntryType.INVALID_PARAMS_ERROR,\n      sourceReference: revert.sourceReference\n    }];\n  }\n\n  return stackTrace;\n}\n\nexports.adjustStackTrace = adjustStackTrace;\n\nfunction isNonContractAccountCalledError(decodedTrace) {\n  return matchOpcodes(decodedTrace, -9, [opcodes_1.Opcode.EXTCODESIZE, opcodes_1.Opcode.ISZERO, opcodes_1.Opcode.DUP1, opcodes_1.Opcode.ISZERO]);\n}\n\nfunction isConstructorInvalidParamsError(decodedTrace) {\n  if (!(0, message_trace_1.isDecodedCreateTrace)(decodedTrace)) {\n    return false;\n  }\n\n  return matchOpcodes(decodedTrace, -20, [opcodes_1.Opcode.CODESIZE]) && matchOpcodes(decodedTrace, -15, [opcodes_1.Opcode.CODECOPY]) && matchOpcodes(decodedTrace, -7, [opcodes_1.Opcode.LT, opcodes_1.Opcode.ISZERO]);\n}\n\nfunction isCallInvalidParamsError(decodedTrace) {\n  if (!(0, message_trace_1.isDecodedCallTrace)(decodedTrace)) {\n    return false;\n  }\n\n  return matchOpcodes(decodedTrace, -11, [opcodes_1.Opcode.CALLDATASIZE]) && matchOpcodes(decodedTrace, -7, [opcodes_1.Opcode.LT, opcodes_1.Opcode.ISZERO]);\n}\n\nfunction matchOpcode(decodedTrace, stepIndex, opcode) {\n  const [step] = decodedTrace.steps.slice(stepIndex, stepIndex + 1);\n\n  if (step === undefined || !(0, message_trace_1.isEvmStep)(step)) {\n    return false;\n  }\n\n  const instruction = decodedTrace.bytecode.getInstruction(step.pc);\n  return instruction.opcode === opcode;\n}\n\nfunction matchOpcodes(decodedTrace, firstStepIndex, opcodes) {\n  let index = firstStepIndex;\n\n  for (const opcode of opcodes) {\n    if (!matchOpcode(decodedTrace, index, opcode)) {\n      return false;\n    }\n\n    index += 1;\n  }\n\n  return true;\n}","map":{"version":3,"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoBA;;AAEA;;AAMA;;AACA;;AAKA,MAAMA,uDAAuD,GAAG,OAAhE;;AAEA,SAAgBC,+BAAhB,CACEC,UADF,EAEEC,YAFF,EAEsC;AAEpC,MAAID,UAAU,CAACE,MAAX,KAAsB,CAA1B,EAA6B;AAC3B,WAAO,KAAP;AACD;;AAED,QAAMC,SAAS,GAAGH,UAAU,CAACA,UAAU,CAACE,MAAX,GAAoB,CAArB,CAA5B;AAEA,SACEC,SAAS,CAACC,IAAV,KAAmBC,2CAAoBC,YAAvC,IACA,CAACH,SAAS,CAACI,oBADX,IAEAJ,SAAS,CAACK,OAAV,CAAkBC,OAAlB,EAFA,IAGAC,iBAAOC,GAAP,CACEV,YAAY,CAACW,QAAb,CAAsBC,eADxB,EAEEf,uDAFF,CAJF;AASD;;AAnBDgB;;AAqBA,SAAgBC,gBAAhB,CACEf,UADF,EAEEC,YAFF,EAEsC;AAEpC,QAAMe,KAAK,GAAGhB,UAAU,CAACiB,KAAX,CAAiB,CAAjB,EAAoB,CAAC,CAArB,CAAd;AACA,QAAM,CAACC,MAAD,IAAWlB,UAAU,CAACiB,KAAX,CAAiB,CAAC,CAAlB,CAAjB;;AAEA,MAAIE,+BAA+B,CAAClB,YAAD,CAAnC,EAAmD;AACjD,WAAO,CACL,GAAGe,KADE,EAEL;AACEZ,UAAI,EAAEC,2CAAoBe,gCAD5B;AAEEC,qBAAe,EAAEH,MAAM,CAACG;AAF1B,KAFK,CAAP;AAOD;;AAED,MAAIC,+BAA+B,CAACrB,YAAD,CAAnC,EAAmD;AACjD,WAAO,CACL,GAAGe,KADE,EAEL;AACEZ,UAAI,EAAEC,2CAAoBkB,oBAD5B;AAEEF,qBAAe,EAAEH,MAAM,CAACG;AAF1B,KAFK,CAAP;AAOD;;AAED,MAAIG,wBAAwB,CAACvB,YAAD,CAA5B,EAA4C;AAC1C,WAAO,CACL,GAAGe,KADE,EAEL;AACEZ,UAAI,EAAEC,2CAAoBkB,oBAD5B;AAEEF,qBAAe,EAAEH,MAAM,CAACG;AAF1B,KAFK,CAAP;AAOD;;AAED,SAAOrB,UAAP;AACD;;AAtCDc;;AAwCA,SAASK,+BAAT,CACElB,YADF,EACsC;AAEpC,SAAOwB,YAAY,CAACxB,YAAD,EAAe,CAAC,CAAhB,EAAmB,CACpCyB,iBAAOC,WAD6B,EAEpCD,iBAAOE,MAF6B,EAGpCF,iBAAOG,IAH6B,EAIpCH,iBAAOE,MAJ6B,CAAnB,CAAnB;AAMD;;AAED,SAASN,+BAAT,CAAyCrB,YAAzC,EAA6E;AAC3E,MAAI,CAAC,0CAAqBA,YAArB,CAAL,EAAyC;AACvC,WAAO,KAAP;AACD;;AAED,SACEwB,YAAY,CAACxB,YAAD,EAAe,CAAC,EAAhB,EAAoB,CAACyB,iBAAOI,QAAR,CAApB,CAAZ,IACAL,YAAY,CAACxB,YAAD,EAAe,CAAC,EAAhB,EAAoB,CAACyB,iBAAOK,QAAR,CAApB,CADZ,IAEAN,YAAY,CAACxB,YAAD,EAAe,CAAC,CAAhB,EAAmB,CAACyB,iBAAOM,EAAR,EAAYN,iBAAOE,MAAnB,CAAnB,CAHd;AAKD;;AAED,SAASJ,wBAAT,CAAkCvB,YAAlC,EAAsE;AACpE,MAAI,CAAC,wCAAmBA,YAAnB,CAAL,EAAuC;AACrC,WAAO,KAAP;AACD;;AAED,SACEwB,YAAY,CAACxB,YAAD,EAAe,CAAC,EAAhB,EAAoB,CAACyB,iBAAOO,YAAR,CAApB,CAAZ,IACAR,YAAY,CAACxB,YAAD,EAAe,CAAC,CAAhB,EAAmB,CAACyB,iBAAOM,EAAR,EAAYN,iBAAOE,MAAnB,CAAnB,CAFd;AAID;;AAED,SAASM,WAAT,CACEjC,YADF,EAEEkC,SAFF,EAGEC,MAHF,EAGgB;AAEd,QAAM,CAACC,IAAD,IAASpC,YAAY,CAACqC,KAAb,CAAmBrB,KAAnB,CAAyBkB,SAAzB,EAAoCA,SAAS,GAAG,CAAhD,CAAf;;AAEA,MAAIE,IAAI,KAAKE,SAAT,IAAsB,CAAC,+BAAUF,IAAV,CAA3B,EAA4C;AAC1C,WAAO,KAAP;AACD;;AAED,QAAMG,WAAW,GAAGvC,YAAY,CAACW,QAAb,CAAsB6B,cAAtB,CAAqCJ,IAAI,CAACK,EAA1C,CAApB;AAEA,SAAOF,WAAW,CAACJ,MAAZ,KAAuBA,MAA9B;AACD;;AAED,SAASX,YAAT,CACExB,YADF,EAEE0C,cAFF,EAGEC,OAHF,EAGmB;AAEjB,MAAIC,KAAK,GAAGF,cAAZ;;AACA,OAAK,MAAMP,MAAX,IAAqBQ,OAArB,EAA8B;AAC5B,QAAI,CAACV,WAAW,CAACjC,YAAD,EAAe4C,KAAf,EAAsBT,MAAtB,CAAhB,EAA+C;AAC7C,aAAO,KAAP;AACD;;AAEDS,SAAK,IAAI,CAAT;AACD;;AAED,SAAO,IAAP;AACD","names":["FIRST_SOLC_VERSION_WITH_MAPPED_SMALL_INTERNAL_FUNCTIONS","stackTraceMayRequireAdjustments","stackTrace","decodedTrace","length","lastFrame","type","solidity_stack_trace_1","REVERT_ERROR","isInvalidOpcodeError","message","isEmpty","semver_1","gte","bytecode","compilerVersion","exports","adjustStackTrace","start","slice","revert","isNonContractAccountCalledError","NONCONTRACT_ACCOUNT_CALLED_ERROR","sourceReference","isConstructorInvalidParamsError","INVALID_PARAMS_ERROR","isCallInvalidParamsError","matchOpcodes","opcodes_1","EXTCODESIZE","ISZERO","DUP1","CODESIZE","CODECOPY","LT","CALLDATASIZE","matchOpcode","stepIndex","opcode","step","steps","undefined","instruction","getInstruction","pc","firstStepIndex","opcodes","index"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/internal/hardhat-network/stack-traces/mapped-inlined-internal-functions-heuristics.ts"],"sourcesContent":["/**\n * This file includes Solidity tracing heuristics for solc starting with version\n * 0.6.9.\n *\n * This solc version introduced a significant change to how sourcemaps are\n * handled for inline yul/internal functions. These were mapped to the\n * unmapped/-1 file before, which lead to many unmapped reverts. Now, they are\n * mapped to the part of the Solidity source that lead to their inlining.\n *\n * This change is a very positive change, as errors would point to the correct\n * line by default. The only problem is that we used to rely very heavily on\n * unmapped reverts to decide when our error detection heuristics were to be\n * run. In fact, this heuristics were first introduced because of unmapped\n * reverts.\n *\n * Instead of synthetically completing stack traces when unmapped reverts occur,\n * we now start from complete stack traces and adjust them if we can provide\n * more meaningful errors.\n */\n\nimport semver from \"semver\";\n\nimport {\n  DecodedEvmMessageTrace,\n  isDecodedCallTrace,\n  isDecodedCreateTrace,\n  isEvmStep,\n} from \"./message-trace\";\nimport { Opcode } from \"./opcodes\";\nimport {\n  SolidityStackTrace,\n  StackTraceEntryType,\n} from \"./solidity-stack-trace\";\n\nconst FIRST_SOLC_VERSION_WITH_MAPPED_SMALL_INTERNAL_FUNCTIONS = \"0.6.9\";\n\nexport function stackTraceMayRequireAdjustments(\n  stackTrace: SolidityStackTrace,\n  decodedTrace: DecodedEvmMessageTrace\n): boolean {\n  if (stackTrace.length === 0) {\n    return false;\n  }\n\n  const lastFrame = stackTrace[stackTrace.length - 1];\n\n  return (\n    lastFrame.type === StackTraceEntryType.REVERT_ERROR &&\n    !lastFrame.isInvalidOpcodeError &&\n    lastFrame.message.isEmpty() &&\n    semver.gte(\n      decodedTrace.bytecode.compilerVersion,\n      FIRST_SOLC_VERSION_WITH_MAPPED_SMALL_INTERNAL_FUNCTIONS\n    )\n  );\n}\n\nexport function adjustStackTrace(\n  stackTrace: SolidityStackTrace,\n  decodedTrace: DecodedEvmMessageTrace\n): SolidityStackTrace {\n  const start = stackTrace.slice(0, -1);\n  const [revert] = stackTrace.slice(-1);\n\n  if (isNonContractAccountCalledError(decodedTrace)) {\n    return [\n      ...start,\n      {\n        type: StackTraceEntryType.NONCONTRACT_ACCOUNT_CALLED_ERROR,\n        sourceReference: revert.sourceReference!,\n      },\n    ];\n  }\n\n  if (isConstructorInvalidParamsError(decodedTrace)) {\n    return [\n      ...start,\n      {\n        type: StackTraceEntryType.INVALID_PARAMS_ERROR,\n        sourceReference: revert.sourceReference!,\n      },\n    ];\n  }\n\n  if (isCallInvalidParamsError(decodedTrace)) {\n    return [\n      ...start,\n      {\n        type: StackTraceEntryType.INVALID_PARAMS_ERROR,\n        sourceReference: revert.sourceReference!,\n      },\n    ];\n  }\n\n  return stackTrace;\n}\n\nfunction isNonContractAccountCalledError(\n  decodedTrace: DecodedEvmMessageTrace\n): boolean {\n  return matchOpcodes(decodedTrace, -9, [\n    Opcode.EXTCODESIZE,\n    Opcode.ISZERO,\n    Opcode.DUP1,\n    Opcode.ISZERO,\n  ]);\n}\n\nfunction isConstructorInvalidParamsError(decodedTrace: DecodedEvmMessageTrace) {\n  if (!isDecodedCreateTrace(decodedTrace)) {\n    return false;\n  }\n\n  return (\n    matchOpcodes(decodedTrace, -20, [Opcode.CODESIZE]) &&\n    matchOpcodes(decodedTrace, -15, [Opcode.CODECOPY]) &&\n    matchOpcodes(decodedTrace, -7, [Opcode.LT, Opcode.ISZERO])\n  );\n}\n\nfunction isCallInvalidParamsError(decodedTrace: DecodedEvmMessageTrace) {\n  if (!isDecodedCallTrace(decodedTrace)) {\n    return false;\n  }\n\n  return (\n    matchOpcodes(decodedTrace, -11, [Opcode.CALLDATASIZE]) &&\n    matchOpcodes(decodedTrace, -7, [Opcode.LT, Opcode.ISZERO])\n  );\n}\n\nfunction matchOpcode(\n  decodedTrace: DecodedEvmMessageTrace,\n  stepIndex: number,\n  opcode: Opcode\n): boolean {\n  const [step] = decodedTrace.steps.slice(stepIndex, stepIndex + 1);\n\n  if (step === undefined || !isEvmStep(step)) {\n    return false;\n  }\n\n  const instruction = decodedTrace.bytecode.getInstruction(step.pc);\n\n  return instruction.opcode === opcode;\n}\n\nfunction matchOpcodes(\n  decodedTrace: DecodedEvmMessageTrace,\n  firstStepIndex: number,\n  opcodes: Opcode[]\n): boolean {\n  let index = firstStepIndex;\n  for (const opcode of opcodes) {\n    if (!matchOpcode(decodedTrace, index, opcode)) {\n      return false;\n    }\n\n    index += 1;\n  }\n\n  return true;\n}\n"]},"metadata":{},"sourceType":"script"}