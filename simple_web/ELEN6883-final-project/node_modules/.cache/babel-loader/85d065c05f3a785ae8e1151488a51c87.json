{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Bytecode = exports.Instruction = exports.CustomError = exports.ContractFunction = exports.Contract = exports.SourceLocation = exports.SourceFile = exports.ContractFunctionVisibility = exports.ContractFunctionType = exports.ContractType = exports.JumpType = void 0;\n\nconst ethereumjs_util_1 = require(\"ethereumjs-util\");\n\nconst abi_helpers_1 = require(\"../../util/abi-helpers\");\n/* eslint-disable @nomiclabs/hardhat-internal-rules/only-hardhat-error */\n\n\nvar JumpType;\n\n(function (JumpType) {\n  JumpType[JumpType[\"NOT_JUMP\"] = 0] = \"NOT_JUMP\";\n  JumpType[JumpType[\"INTO_FUNCTION\"] = 1] = \"INTO_FUNCTION\";\n  JumpType[JumpType[\"OUTOF_FUNCTION\"] = 2] = \"OUTOF_FUNCTION\";\n  JumpType[JumpType[\"INTERNAL_JUMP\"] = 3] = \"INTERNAL_JUMP\";\n})(JumpType = exports.JumpType || (exports.JumpType = {}));\n\nvar ContractType;\n\n(function (ContractType) {\n  ContractType[ContractType[\"CONTRACT\"] = 0] = \"CONTRACT\";\n  ContractType[ContractType[\"LIBRARY\"] = 1] = \"LIBRARY\";\n})(ContractType = exports.ContractType || (exports.ContractType = {}));\n\nvar ContractFunctionType;\n\n(function (ContractFunctionType) {\n  ContractFunctionType[ContractFunctionType[\"CONSTRUCTOR\"] = 0] = \"CONSTRUCTOR\";\n  ContractFunctionType[ContractFunctionType[\"FUNCTION\"] = 1] = \"FUNCTION\";\n  ContractFunctionType[ContractFunctionType[\"FALLBACK\"] = 2] = \"FALLBACK\";\n  ContractFunctionType[ContractFunctionType[\"RECEIVE\"] = 3] = \"RECEIVE\";\n  ContractFunctionType[ContractFunctionType[\"GETTER\"] = 4] = \"GETTER\";\n  ContractFunctionType[ContractFunctionType[\"MODIFIER\"] = 5] = \"MODIFIER\";\n  ContractFunctionType[ContractFunctionType[\"FREE_FUNCTION\"] = 6] = \"FREE_FUNCTION\";\n})(ContractFunctionType = exports.ContractFunctionType || (exports.ContractFunctionType = {}));\n\nvar ContractFunctionVisibility;\n\n(function (ContractFunctionVisibility) {\n  ContractFunctionVisibility[ContractFunctionVisibility[\"PRIVATE\"] = 0] = \"PRIVATE\";\n  ContractFunctionVisibility[ContractFunctionVisibility[\"INTERNAL\"] = 1] = \"INTERNAL\";\n  ContractFunctionVisibility[ContractFunctionVisibility[\"PUBLIC\"] = 2] = \"PUBLIC\";\n  ContractFunctionVisibility[ContractFunctionVisibility[\"EXTERNAL\"] = 3] = \"EXTERNAL\";\n})(ContractFunctionVisibility = exports.ContractFunctionVisibility || (exports.ContractFunctionVisibility = {}));\n\nclass SourceFile {\n  constructor(sourceName, content) {\n    this.sourceName = sourceName;\n    this.content = content;\n    this.contracts = [];\n    this.functions = [];\n  }\n\n  addContract(contract) {\n    if (contract.location.file !== this) {\n      throw new Error(\"Trying to add a contract from another file\");\n    }\n\n    this.contracts.push(contract);\n  }\n\n  addFunction(func) {\n    if (func.location.file !== this) {\n      throw new Error(\"Trying to add a function from another file\");\n    }\n\n    this.functions.push(func);\n  }\n\n  getContainingFunction(location) {\n    // TODO: Optimize this with a binary search or an internal tree\n    for (const func of this.functions) {\n      if (func.location.contains(location)) {\n        return func;\n      }\n    }\n\n    return undefined;\n  }\n\n}\n\nexports.SourceFile = SourceFile;\n\nclass SourceLocation {\n  constructor(file, offset, length) {\n    this.file = file;\n    this.offset = offset;\n    this.length = length;\n  }\n\n  getStartingLineNumber() {\n    if (this._line === undefined) {\n      this._line = 1;\n\n      for (const c of this.file.content.slice(0, this.offset)) {\n        if (c === \"\\n\") {\n          this._line += 1;\n        }\n      }\n    }\n\n    return this._line;\n  }\n\n  getContainingFunction() {\n    return this.file.getContainingFunction(this);\n  }\n\n  contains(other) {\n    if (this.file !== other.file) {\n      return false;\n    }\n\n    if (other.offset < this.offset) {\n      return false;\n    }\n\n    return other.offset + other.length <= this.offset + this.length;\n  }\n\n  equals(other) {\n    return this.file === other.file && this.offset === other.offset && this.length === other.length;\n  }\n\n}\n\nexports.SourceLocation = SourceLocation;\n\nclass Contract {\n  constructor(name, type, location) {\n    this.name = name;\n    this.type = type;\n    this.location = location;\n    this.localFunctions = [];\n    this.customErrors = [];\n    this._selectorHexToFunction = new Map();\n  }\n\n  get constructorFunction() {\n    return this._constructor;\n  }\n\n  get fallback() {\n    return this._fallback;\n  }\n\n  get receive() {\n    return this._receive;\n  }\n\n  addLocalFunction(func) {\n    if (func.contract !== this) {\n      throw new Error(\"Function isn't local\");\n    }\n\n    if (func.visibility === ContractFunctionVisibility.PUBLIC || func.visibility === ContractFunctionVisibility.EXTERNAL) {\n      if (func.type === ContractFunctionType.FUNCTION || func.type === ContractFunctionType.GETTER) {\n        this._selectorHexToFunction.set((0, ethereumjs_util_1.bufferToHex)(func.selector), func);\n      } else if (func.type === ContractFunctionType.CONSTRUCTOR) {\n        this._constructor = func;\n      } else if (func.type === ContractFunctionType.FALLBACK) {\n        this._fallback = func;\n      } else if (func.type === ContractFunctionType.RECEIVE) {\n        this._receive = func;\n      }\n    }\n\n    this.localFunctions.push(func);\n  }\n\n  addCustomError(customError) {\n    this.customErrors.push(customError);\n  }\n\n  addNextLinearizedBaseContract(baseContract) {\n    if (this._fallback === undefined && baseContract._fallback !== undefined) {\n      this._fallback = baseContract._fallback;\n    }\n\n    if (this._receive === undefined && baseContract._receive !== undefined) {\n      this._receive = baseContract._receive;\n    }\n\n    for (const baseContractFunction of baseContract.localFunctions) {\n      if (baseContractFunction.type !== ContractFunctionType.GETTER && baseContractFunction.type !== ContractFunctionType.FUNCTION) {\n        continue;\n      }\n\n      if (baseContractFunction.visibility !== ContractFunctionVisibility.PUBLIC && baseContractFunction.visibility !== ContractFunctionVisibility.EXTERNAL) {\n        continue;\n      }\n\n      const selectorHex = (0, ethereumjs_util_1.bufferToHex)(baseContractFunction.selector);\n\n      if (!this._selectorHexToFunction.has(selectorHex)) {\n        this._selectorHexToFunction.set(selectorHex, baseContractFunction);\n      }\n    }\n  }\n\n  getFunctionFromSelector(selector) {\n    return this._selectorHexToFunction.get((0, ethereumjs_util_1.bufferToHex)(selector));\n  }\n  /**\n   * We compute selectors manually, which is particularly hard. We do this\n   * because we need to map selectors to AST nodes, and it seems easier to start\n   * from the AST node. This is surprisingly super hard: things like inherited\n   * enums, structs and ABIv2 complicate it.\n   *\n   * As we know that that can fail, we run a heuristic that tries to correct\n   * incorrect selectors. What it does is checking the `evm.methodIdentifiers`\n   * compiler output, and detect missing selectors. Then we take those and\n   * find contract functions with the same name. If there are multiple of those\n   * we can't do anything. If there is a single one, it must have an incorrect\n   * selector, so we update it with the `evm.methodIdentifiers`'s value.\n   */\n\n\n  correctSelector(functionName, selector) {\n    const functions = Array.from(this._selectorHexToFunction.values()).filter(cf => cf.name === functionName);\n\n    if (functions.length !== 1) {\n      return false;\n    }\n\n    const functionToCorrect = functions[0];\n\n    if (functionToCorrect.selector !== undefined) {\n      this._selectorHexToFunction.delete((0, ethereumjs_util_1.bufferToHex)(functionToCorrect.selector));\n    }\n\n    functionToCorrect.selector = selector;\n\n    this._selectorHexToFunction.set((0, ethereumjs_util_1.bufferToHex)(selector), functionToCorrect);\n\n    return true;\n  }\n\n}\n\nexports.Contract = Contract;\n\nclass ContractFunction {\n  constructor(name, type, location, contract, visibility, isPayable, selector) {\n    this.name = name;\n    this.type = type;\n    this.location = location;\n    this.contract = contract;\n    this.visibility = visibility;\n    this.isPayable = isPayable;\n    this.selector = selector;\n\n    if (contract !== undefined && !contract.location.contains(location)) {\n      throw new Error(\"Incompatible contract and function location\");\n    }\n  }\n\n}\n\nexports.ContractFunction = ContractFunction;\n\nclass CustomError {\n  constructor(selector, name, paramTypes) {\n    this.selector = selector;\n    this.name = name;\n    this.paramTypes = paramTypes;\n  }\n  /**\n   * Return a CustomError from the given ABI information: the name\n   * of the error and its inputs. Returns undefined if it can't build\n   * the CustomError.\n   */\n\n\n  static fromABI(name, inputs) {\n    const selector = abi_helpers_1.AbiHelpers.computeSelector(name, inputs);\n\n    if (selector !== undefined) {\n      return new CustomError(selector, name, inputs);\n    }\n  }\n\n}\n\nexports.CustomError = CustomError;\n\nclass Instruction {\n  constructor(pc, opcode, jumpType, pushData, location) {\n    this.pc = pc;\n    this.opcode = opcode;\n    this.jumpType = jumpType;\n    this.pushData = pushData;\n    this.location = location;\n  }\n\n}\n\nexports.Instruction = Instruction;\n\nclass Bytecode {\n  constructor(contract, isDeployment, normalizedCode, instructions, libraryAddressPositions, immutableReferences, compilerVersion) {\n    this.contract = contract;\n    this.isDeployment = isDeployment;\n    this.normalizedCode = normalizedCode;\n    this.instructions = instructions;\n    this.libraryAddressPositions = libraryAddressPositions;\n    this.immutableReferences = immutableReferences;\n    this.compilerVersion = compilerVersion;\n    this._pcToInstruction = new Map();\n\n    for (const inst of instructions) {\n      this._pcToInstruction.set(inst.pc, inst);\n    }\n  }\n\n  getInstruction(pc) {\n    const inst = this._pcToInstruction.get(pc);\n\n    if (inst === undefined) {\n      throw new Error(`There's no instruction at pc ${pc}`);\n    }\n\n    return inst;\n  }\n\n  hasInstruction(pc) {\n    return this._pcToInstruction.has(pc);\n  }\n\n}\n\nexports.Bytecode = Bytecode;","map":{"version":3,"mappings":"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","names":["JumpType","exports","ContractType","ContractFunctionType","ContractFunctionVisibility","SourceFile","constructor","sourceName","content","addContract","contract","location","file","Error","contracts","push","addFunction","func","functions","getContainingFunction","contains","undefined","SourceLocation","offset","length","getStartingLineNumber","_line","c","slice","other","equals","Contract","name","type","Map","constructorFunction","_constructor","fallback","_fallback","receive","_receive","addLocalFunction","visibility","PUBLIC","EXTERNAL","FUNCTION","GETTER","_selectorHexToFunction","set","selector","CONSTRUCTOR","FALLBACK","RECEIVE","localFunctions","addCustomError","customError","customErrors","addNextLinearizedBaseContract","baseContract","baseContractFunction","selectorHex","has","getFunctionFromSelector","get","correctSelector","functionName","Array","from","values","filter","cf","functionToCorrect","delete","ContractFunction","isPayable","CustomError","paramTypes","fromABI","inputs","abi_helpers_1","computeSelector","Instruction","pc","opcode","jumpType","pushData","Bytecode","isDeployment","normalizedCode","instructions","libraryAddressPositions","immutableReferences","compilerVersion","inst","_pcToInstruction","getInstruction","hasInstruction"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/internal/hardhat-network/stack-traces/model.ts"],"sourcesContent":["import { bufferToHex } from \"ethereumjs-util\";\n\nimport { AbiHelpers } from \"../../util/abi-helpers\";\n\nimport { Opcode } from \"./opcodes\";\n\n/* eslint-disable @nomiclabs/hardhat-internal-rules/only-hardhat-error */\n\nexport enum JumpType {\n  NOT_JUMP,\n  INTO_FUNCTION,\n  OUTOF_FUNCTION,\n  INTERNAL_JUMP,\n}\n\nexport enum ContractType {\n  CONTRACT,\n  LIBRARY,\n}\n\nexport enum ContractFunctionType {\n  CONSTRUCTOR,\n  FUNCTION,\n  FALLBACK,\n  RECEIVE,\n  GETTER,\n  MODIFIER,\n  FREE_FUNCTION,\n}\n\nexport enum ContractFunctionVisibility {\n  PRIVATE,\n  INTERNAL,\n  PUBLIC,\n  EXTERNAL,\n}\n\nexport class SourceFile {\n  public readonly contracts: Contract[] = [];\n  public readonly functions: ContractFunction[] = [];\n\n  constructor(\n    public readonly sourceName: string,\n    public readonly content: string\n  ) {}\n\n  public addContract(contract: Contract) {\n    if (contract.location.file !== this) {\n      throw new Error(\"Trying to add a contract from another file\");\n    }\n\n    this.contracts.push(contract);\n  }\n\n  public addFunction(func: ContractFunction) {\n    if (func.location.file !== this) {\n      throw new Error(\"Trying to add a function from another file\");\n    }\n\n    this.functions.push(func);\n  }\n\n  public getContainingFunction(\n    location: SourceLocation\n  ): ContractFunction | undefined {\n    // TODO: Optimize this with a binary search or an internal tree\n\n    for (const func of this.functions) {\n      if (func.location.contains(location)) {\n        return func;\n      }\n    }\n\n    return undefined;\n  }\n}\n\nexport class SourceLocation {\n  private _line: number | undefined;\n\n  constructor(\n    public readonly file: SourceFile,\n    public readonly offset: number,\n    public readonly length: number\n  ) {}\n\n  public getStartingLineNumber(): number {\n    if (this._line === undefined) {\n      this._line = 1;\n\n      for (const c of this.file.content.slice(0, this.offset)) {\n        if (c === \"\\n\") {\n          this._line += 1;\n        }\n      }\n    }\n\n    return this._line;\n  }\n\n  public getContainingFunction(): ContractFunction | undefined {\n    return this.file.getContainingFunction(this);\n  }\n\n  public contains(other: SourceLocation) {\n    if (this.file !== other.file) {\n      return false;\n    }\n\n    if (other.offset < this.offset) {\n      return false;\n    }\n\n    return other.offset + other.length <= this.offset + this.length;\n  }\n\n  public equals(other: SourceLocation) {\n    return (\n      this.file === other.file &&\n      this.offset === other.offset &&\n      this.length === other.length\n    );\n  }\n}\n\nexport class Contract {\n  public readonly localFunctions: ContractFunction[] = [];\n  public readonly customErrors: CustomError[] = [];\n\n  private _constructor: ContractFunction | undefined;\n  private _fallback: ContractFunction | undefined;\n  private _receive: ContractFunction | undefined;\n  private readonly _selectorHexToFunction: Map<string, ContractFunction> =\n    new Map();\n\n  constructor(\n    public readonly name: string,\n    public readonly type: ContractType,\n    public readonly location: SourceLocation\n  ) {}\n\n  public get constructorFunction(): ContractFunction | undefined {\n    return this._constructor;\n  }\n\n  public get fallback(): ContractFunction | undefined {\n    return this._fallback;\n  }\n\n  public get receive(): ContractFunction | undefined {\n    return this._receive;\n  }\n\n  public addLocalFunction(func: ContractFunction) {\n    if (func.contract !== this) {\n      throw new Error(\"Function isn't local\");\n    }\n\n    if (\n      func.visibility === ContractFunctionVisibility.PUBLIC ||\n      func.visibility === ContractFunctionVisibility.EXTERNAL\n    ) {\n      if (\n        func.type === ContractFunctionType.FUNCTION ||\n        func.type === ContractFunctionType.GETTER\n      ) {\n        this._selectorHexToFunction.set(bufferToHex(func.selector!), func);\n      } else if (func.type === ContractFunctionType.CONSTRUCTOR) {\n        this._constructor = func;\n      } else if (func.type === ContractFunctionType.FALLBACK) {\n        this._fallback = func;\n      } else if (func.type === ContractFunctionType.RECEIVE) {\n        this._receive = func;\n      }\n    }\n\n    this.localFunctions.push(func);\n  }\n\n  public addCustomError(customError: CustomError) {\n    this.customErrors.push(customError);\n  }\n\n  public addNextLinearizedBaseContract(baseContract: Contract) {\n    if (this._fallback === undefined && baseContract._fallback !== undefined) {\n      this._fallback = baseContract._fallback;\n    }\n    if (this._receive === undefined && baseContract._receive !== undefined) {\n      this._receive = baseContract._receive;\n    }\n\n    for (const baseContractFunction of baseContract.localFunctions) {\n      if (\n        baseContractFunction.type !== ContractFunctionType.GETTER &&\n        baseContractFunction.type !== ContractFunctionType.FUNCTION\n      ) {\n        continue;\n      }\n\n      if (\n        baseContractFunction.visibility !== ContractFunctionVisibility.PUBLIC &&\n        baseContractFunction.visibility !== ContractFunctionVisibility.EXTERNAL\n      ) {\n        continue;\n      }\n\n      const selectorHex = bufferToHex(baseContractFunction.selector!);\n      if (!this._selectorHexToFunction.has(selectorHex)) {\n        this._selectorHexToFunction.set(selectorHex, baseContractFunction);\n      }\n    }\n  }\n\n  public getFunctionFromSelector(\n    selector: Buffer\n  ): ContractFunction | undefined {\n    return this._selectorHexToFunction.get(bufferToHex(selector));\n  }\n\n  /**\n   * We compute selectors manually, which is particularly hard. We do this\n   * because we need to map selectors to AST nodes, and it seems easier to start\n   * from the AST node. This is surprisingly super hard: things like inherited\n   * enums, structs and ABIv2 complicate it.\n   *\n   * As we know that that can fail, we run a heuristic that tries to correct\n   * incorrect selectors. What it does is checking the `evm.methodIdentifiers`\n   * compiler output, and detect missing selectors. Then we take those and\n   * find contract functions with the same name. If there are multiple of those\n   * we can't do anything. If there is a single one, it must have an incorrect\n   * selector, so we update it with the `evm.methodIdentifiers`'s value.\n   */\n  public correctSelector(functionName: string, selector: Buffer): boolean {\n    const functions = Array.from(this._selectorHexToFunction.values()).filter(\n      (cf) => cf.name === functionName\n    );\n\n    if (functions.length !== 1) {\n      return false;\n    }\n\n    const functionToCorrect = functions[0];\n\n    if (functionToCorrect.selector !== undefined) {\n      this._selectorHexToFunction.delete(\n        bufferToHex(functionToCorrect.selector)\n      );\n    }\n\n    functionToCorrect.selector = selector;\n    this._selectorHexToFunction.set(bufferToHex(selector), functionToCorrect);\n    return true;\n  }\n}\n\nexport class ContractFunction {\n  constructor(\n    public readonly name: string,\n    public readonly type: ContractFunctionType,\n    public readonly location: SourceLocation,\n    public readonly contract?: Contract,\n    public readonly visibility?: ContractFunctionVisibility,\n    public readonly isPayable?: boolean,\n    public selector?: Buffer\n  ) {\n    if (contract !== undefined && !contract.location.contains(location)) {\n      throw new Error(\"Incompatible contract and function location\");\n    }\n  }\n}\n\nexport class CustomError {\n  /**\n   * Return a CustomError from the given ABI information: the name\n   * of the error and its inputs. Returns undefined if it can't build\n   * the CustomError.\n   */\n  public static fromABI(name: string, inputs: any[]): CustomError | undefined {\n    const selector = AbiHelpers.computeSelector(name, inputs);\n\n    if (selector !== undefined) {\n      return new CustomError(selector, name, inputs);\n    }\n  }\n\n  private constructor(\n    public readonly selector: Buffer,\n    public readonly name: string,\n    public readonly paramTypes: any[]\n  ) {}\n}\n\nexport class Instruction {\n  constructor(\n    public readonly pc: number,\n    public readonly opcode: Opcode,\n    public readonly jumpType: JumpType,\n    public readonly pushData?: Buffer,\n    public readonly location?: SourceLocation\n  ) {}\n}\n\ninterface ImmutableReference {\n  start: number;\n  length: number;\n}\n\nexport class Bytecode {\n  private readonly _pcToInstruction: Map<number, Instruction> = new Map();\n\n  constructor(\n    public readonly contract: Contract,\n    public readonly isDeployment: boolean,\n    public readonly normalizedCode: Buffer,\n    public readonly instructions: Instruction[],\n    public readonly libraryAddressPositions: number[],\n    public readonly immutableReferences: ImmutableReference[],\n    public readonly compilerVersion: string\n  ) {\n    for (const inst of instructions) {\n      this._pcToInstruction.set(inst.pc, inst);\n    }\n  }\n\n  public getInstruction(pc: number): Instruction {\n    const inst = this._pcToInstruction.get(pc);\n\n    if (inst === undefined) {\n      throw new Error(`There's no instruction at pc ${pc}`);\n    }\n\n    return inst;\n  }\n\n  public hasInstruction(pc: number): boolean {\n    return this._pcToInstruction.has(pc);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}