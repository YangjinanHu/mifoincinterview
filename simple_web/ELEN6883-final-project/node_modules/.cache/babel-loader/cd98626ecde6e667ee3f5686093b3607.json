{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getValidationErrors = exports.validateConfig = exports.decimalString = exports.address = exports.hexString = exports.DotPathReporter = exports.success = exports.failure = void 0;\n\nconst t = __importStar(require(\"io-ts\"));\n\nconst lib_1 = require(\"io-ts/lib\");\n\nconst constants_1 = require(\"../../constants\");\n\nconst io_ts_1 = require(\"../../util/io-ts\");\n\nconst lang_1 = require(\"../../util/lang\");\n\nconst errors_1 = require(\"../errors\");\n\nconst errors_list_1 = require(\"../errors-list\");\n\nconst hardforks_1 = require(\"../../util/hardforks\");\n\nconst default_config_1 = require(\"./default-config\");\n\nfunction stringify(v) {\n  if (typeof v === \"function\") {\n    return (0, lib_1.getFunctionName)(v);\n  }\n\n  if (typeof v === \"number\" && !isFinite(v)) {\n    if (isNaN(v)) {\n      return \"NaN\";\n    }\n\n    return v > 0 ? \"Infinity\" : \"-Infinity\";\n  }\n\n  return JSON.stringify(v);\n}\n\nfunction getContextPath(context) {\n  const keysPath = context.slice(1).map(c => c.key).join(\".\");\n  return `${context[0].type.name}.${keysPath}`;\n}\n\nfunction getMessage(e) {\n  const lastContext = e.context[e.context.length - 1];\n  return e.message !== undefined ? e.message : getErrorMessage(getContextPath(e.context), e.value, lastContext.type.name);\n}\n\nfunction getErrorMessage(path, value, expectedType) {\n  return `Invalid value ${stringify(value)} for ${path} - Expected a value of type ${expectedType}.`;\n}\n\nfunction getPrivateKeyError(index, network, message) {\n  return `Invalid account: #${index} for network: ${network} - ${message}`;\n}\n\nfunction validatePrivateKey(privateKey, index, network, errors) {\n  if (typeof privateKey !== \"string\") {\n    errors.push(getPrivateKeyError(index, network, `Expected string, received ${typeof privateKey}`));\n  } else {\n    // private key validation\n    const pkWithPrefix = /^0x/.test(privateKey) ? privateKey : `0x${privateKey}`; // 32 bytes = 64 characters + 2 char prefix = 66\n\n    if (pkWithPrefix.length < 66) {\n      errors.push(getPrivateKeyError(index, network, \"private key too short, expected 32 bytes\"));\n    } else if (pkWithPrefix.length > 66) {\n      errors.push(getPrivateKeyError(index, network, \"private key too long, expected 32 bytes\"));\n    } else if (exports.hexString.decode(pkWithPrefix).isLeft()) {\n      errors.push(getPrivateKeyError(index, network, \"invalid hex character(s) found in string\"));\n    }\n  }\n}\n\nfunction failure(es) {\n  return es.map(getMessage);\n}\n\nexports.failure = failure;\n\nfunction success() {\n  return [];\n}\n\nexports.success = success;\nexports.DotPathReporter = {\n  report: validation => validation.fold(failure, success)\n};\nconst HEX_STRING_REGEX = /^(0x)?([0-9a-f]{2})+$/gi;\nconst DEC_STRING_REGEX = /^(0|[1-9][0-9]*)$/g;\n\nfunction isHexString(v) {\n  if (typeof v !== \"string\") {\n    return false;\n  }\n\n  return v.trim().match(HEX_STRING_REGEX) !== null;\n}\n\nfunction isDecimalString(v) {\n  if (typeof v !== \"string\") {\n    return false;\n  }\n\n  return v.match(DEC_STRING_REGEX) !== null;\n}\n\nexports.hexString = new t.Type(\"hex string\", isHexString, (u, c) => isHexString(u) ? t.success(u) : t.failure(u, c), t.identity);\n\nfunction isAddress(v) {\n  if (typeof v !== \"string\") {\n    return false;\n  }\n\n  const trimmed = v.trim();\n  return trimmed.match(HEX_STRING_REGEX) !== null && trimmed.startsWith(\"0x\") && trimmed.length === 42;\n}\n\nexports.address = new t.Type(\"address\", isAddress, (u, c) => isAddress(u) ? t.success(u) : t.failure(u, c), t.identity);\nexports.decimalString = new t.Type(\"decimal string\", isDecimalString, (u, c) => isDecimalString(u) ? t.success(u) : t.failure(u, c), t.identity); // TODO: These types have outdated name. They should match the UserConfig types.\n// IMPORTANT: This t.types MUST be kept in sync with the actual types.\n\nconst HardhatNetworkAccount = t.type({\n  privateKey: exports.hexString,\n  balance: exports.decimalString\n});\nconst commonHDAccountsFields = {\n  initialIndex: (0, io_ts_1.optional)(t.number),\n  count: (0, io_ts_1.optional)(t.number),\n  path: (0, io_ts_1.optional)(t.string)\n};\nconst HardhatNetworkHDAccountsConfig = t.type(Object.assign({\n  mnemonic: (0, io_ts_1.optional)(t.string),\n  accountsBalance: (0, io_ts_1.optional)(exports.decimalString)\n}, commonHDAccountsFields));\nconst Integer = new t.Type(\"Integer\", num => typeof num === \"number\", (u, c) => {\n  try {\n    return typeof u === \"string\" ? t.success(parseInt(u, 10)) : t.failure(u, c);\n  } catch (_a) {\n    return t.failure(u, c);\n  }\n}, t.identity);\nconst HardhatNetworkForkingConfig = t.type({\n  enabled: (0, io_ts_1.optional)(t.boolean),\n  url: t.string,\n  blockNumber: (0, io_ts_1.optional)(t.number)\n});\nconst HardhatNetworkMempoolConfig = t.type({\n  order: (0, io_ts_1.optional)(t.keyof((0, lang_1.fromEntries)(constants_1.HARDHAT_MEMPOOL_SUPPORTED_ORDERS.map(order => [order, null]))))\n});\nconst HardhatNetworkMiningConfig = t.type({\n  auto: (0, io_ts_1.optional)(t.boolean),\n  interval: (0, io_ts_1.optional)(t.union([t.number, t.tuple([t.number, t.number])])),\n  mempool: (0, io_ts_1.optional)(HardhatNetworkMempoolConfig)\n});\n\nfunction isValidHardforkName(name) {\n  return Object.values(hardforks_1.HardforkName).includes(name);\n}\n\nconst HardforkNameType = new t.Type(Object.values(hardforks_1.HardforkName).map(v => `\"${v}\"`).join(\" | \"), name => typeof name === \"string\" && isValidHardforkName(name), (u, c) => {\n  return typeof u === \"string\" && isValidHardforkName(u) ? t.success(u) : t.failure(u, c);\n}, t.identity);\nconst HardhatNetworkHardforkHistory = t.record(HardforkNameType, t.number, \"HardhatNetworkHardforkHistory\");\nconst HardhatNetworkChainConfig = t.type({\n  hardforkHistory: HardhatNetworkHardforkHistory\n});\nconst HardhatNetworkChainsConfig = t.record(Integer, HardhatNetworkChainConfig);\nconst commonNetworkConfigFields = {\n  chainId: (0, io_ts_1.optional)(t.number),\n  from: (0, io_ts_1.optional)(t.string),\n  gas: (0, io_ts_1.optional)(t.union([t.literal(\"auto\"), t.number])),\n  gasPrice: (0, io_ts_1.optional)(t.union([t.literal(\"auto\"), t.number])),\n  gasMultiplier: (0, io_ts_1.optional)(t.number)\n};\nconst HardhatNetworkConfig = t.type(Object.assign(Object.assign({}, commonNetworkConfigFields), {\n  hardfork: (0, io_ts_1.optional)(t.keyof((0, lang_1.fromEntries)(constants_1.HARDHAT_NETWORK_SUPPORTED_HARDFORKS.map(hf => [hf, null])))),\n  accounts: (0, io_ts_1.optional)(t.union([t.array(HardhatNetworkAccount), HardhatNetworkHDAccountsConfig])),\n  blockGasLimit: (0, io_ts_1.optional)(t.number),\n  minGasPrice: (0, io_ts_1.optional)(t.union([t.number, t.string])),\n  throwOnTransactionFailures: (0, io_ts_1.optional)(t.boolean),\n  throwOnCallFailures: (0, io_ts_1.optional)(t.boolean),\n  allowUnlimitedContractSize: (0, io_ts_1.optional)(t.boolean),\n  initialDate: (0, io_ts_1.optional)(t.string),\n  loggingEnabled: (0, io_ts_1.optional)(t.boolean),\n  forking: (0, io_ts_1.optional)(HardhatNetworkForkingConfig),\n  mining: (0, io_ts_1.optional)(HardhatNetworkMiningConfig),\n  coinbase: (0, io_ts_1.optional)(exports.address),\n  chains: (0, io_ts_1.optional)(HardhatNetworkChainsConfig)\n}));\nconst HDAccountsConfig = t.type(Object.assign({\n  mnemonic: t.string\n}, commonHDAccountsFields));\nconst NetworkConfigAccounts = t.union([t.literal(\"remote\"), t.array(exports.hexString), HDAccountsConfig]);\nconst HttpHeaders = t.record(t.string, t.string, \"httpHeaders\");\nconst HttpNetworkConfig = t.type(Object.assign(Object.assign({}, commonNetworkConfigFields), {\n  url: (0, io_ts_1.optional)(t.string),\n  accounts: (0, io_ts_1.optional)(NetworkConfigAccounts),\n  httpHeaders: (0, io_ts_1.optional)(HttpHeaders),\n  timeout: (0, io_ts_1.optional)(t.number)\n}));\nconst NetworkConfig = t.union([HardhatNetworkConfig, HttpNetworkConfig]);\nconst Networks = t.record(t.string, NetworkConfig);\nconst ProjectPaths = t.type({\n  root: (0, io_ts_1.optional)(t.string),\n  cache: (0, io_ts_1.optional)(t.string),\n  artifacts: (0, io_ts_1.optional)(t.string),\n  sources: (0, io_ts_1.optional)(t.string),\n  tests: (0, io_ts_1.optional)(t.string)\n});\nconst SingleSolcConfig = t.type({\n  version: t.string,\n  settings: (0, io_ts_1.optional)(t.any)\n});\nconst MultiSolcConfig = t.type({\n  compilers: t.array(SingleSolcConfig),\n  overrides: (0, io_ts_1.optional)(t.record(t.string, SingleSolcConfig))\n});\nconst SolidityConfig = t.union([t.string, SingleSolcConfig, MultiSolcConfig]);\nconst HardhatConfig = t.type({\n  defaultNetwork: (0, io_ts_1.optional)(t.string),\n  networks: (0, io_ts_1.optional)(Networks),\n  paths: (0, io_ts_1.optional)(ProjectPaths),\n  solidity: (0, io_ts_1.optional)(SolidityConfig)\n}, \"HardhatConfig\");\n/**\n * Validates the config, throwing a HardhatError if invalid.\n * @param config\n */\n\nfunction validateConfig(config) {\n  const errors = getValidationErrors(config);\n\n  if (errors.length === 0) {\n    return;\n  }\n\n  let errorList = errors.join(\"\\n  * \");\n  errorList = `  * ${errorList}`;\n  throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.INVALID_CONFIG, {\n    errors: errorList\n  });\n}\n\nexports.validateConfig = validateConfig;\n\nfunction getValidationErrors(config) {\n  var _a;\n\n  const errors = []; // These can't be validated with io-ts\n\n  if (config !== undefined && typeof config.networks === \"object\") {\n    const hardhatNetwork = config.networks[constants_1.HARDHAT_NETWORK_NAME];\n\n    if (hardhatNetwork !== undefined && typeof hardhatNetwork === \"object\") {\n      if (\"url\" in hardhatNetwork) {\n        errors.push(`HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME} can't have an url`);\n      } // Validating the accounts with io-ts leads to very confusing errors messages\n\n\n      const {\n        accounts\n      } = hardhatNetwork,\n            configExceptAccounts = __rest(hardhatNetwork, [\"accounts\"]);\n\n      const netConfigResult = HardhatNetworkConfig.decode(configExceptAccounts);\n\n      if (netConfigResult.isLeft()) {\n        errors.push(getErrorMessage(`HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}`, hardhatNetwork, \"HardhatNetworkConfig\"));\n      } // manual validation of accounts\n\n\n      if (Array.isArray(accounts)) {\n        for (const [index, account] of accounts.entries()) {\n          if (typeof account !== \"object\") {\n            errors.push(getPrivateKeyError(index, constants_1.HARDHAT_NETWORK_NAME, `Expected object, received ${typeof account}`));\n            continue;\n          }\n\n          const {\n            privateKey,\n            balance\n          } = account;\n          validatePrivateKey(privateKey, index, constants_1.HARDHAT_NETWORK_NAME, errors);\n\n          if (typeof balance !== \"string\") {\n            errors.push(getErrorMessage(`HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}.accounts[].balance`, balance, \"string\"));\n          } else if (exports.decimalString.decode(balance).isLeft()) {\n            errors.push(getErrorMessage(`HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}.accounts[].balance`, balance, \"decimal(wei)\"));\n          }\n        }\n      } else if (typeof hardhatNetwork.accounts === \"object\") {\n        const hdConfigResult = HardhatNetworkHDAccountsConfig.decode(hardhatNetwork.accounts);\n\n        if (hdConfigResult.isLeft()) {\n          errors.push(getErrorMessage(`HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}.accounts`, hardhatNetwork.accounts, \"[{privateKey: string, balance: string}] | HardhatNetworkHDAccountsConfig | undefined\"));\n        }\n      } else if (hardhatNetwork.accounts !== undefined) {\n        errors.push(getErrorMessage(`HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}.accounts`, hardhatNetwork.accounts, \"[{privateKey: string, balance: string}] | HardhatNetworkHDAccountsConfig | undefined\"));\n      }\n\n      const hardfork = (_a = hardhatNetwork.hardfork) !== null && _a !== void 0 ? _a : default_config_1.defaultHardhatNetworkParams.hardfork;\n\n      if ((0, hardforks_1.hardforkGte)(hardfork, hardforks_1.HardforkName.LONDON)) {\n        if (hardhatNetwork.minGasPrice !== undefined) {\n          errors.push(`Unexpected config HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}.minGasPrice found - This field is not valid for networks with EIP-1559. Try an older hardfork or remove it.`);\n        }\n      } else {\n        if (hardhatNetwork.initialBaseFeePerGas !== undefined) {\n          errors.push(`Unexpected config HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}.initialBaseFeePerGas found - This field is only valid for networks with EIP-1559. Try a newer hardfork or remove it.`);\n        }\n      }\n\n      if (hardhatNetwork.chains !== undefined) {\n        Object.entries(hardhatNetwork.chains).forEach(chainEntry => {\n          const [chainId, chainConfig] = chainEntry;\n          const {\n            hardforkHistory\n          } = chainConfig;\n\n          if (hardforkHistory !== undefined) {\n            Object.keys(hardforkHistory).forEach(hardforkName => {\n              if (!constants_1.HARDHAT_NETWORK_SUPPORTED_HARDFORKS.includes(hardforkName)) {\n                errors.push(getErrorMessage(`HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}.chains[${chainId}].hardforkHistory`, hardforkName, `\"${constants_1.HARDHAT_NETWORK_SUPPORTED_HARDFORKS.join('\" | \"')}\"`));\n              }\n            });\n          }\n        });\n      }\n    }\n\n    for (const [networkName, netConfig] of Object.entries(config.networks)) {\n      if (networkName === constants_1.HARDHAT_NETWORK_NAME) {\n        continue;\n      }\n\n      if (networkName !== \"localhost\" || netConfig.url !== undefined) {\n        if (typeof netConfig.url !== \"string\") {\n          errors.push(getErrorMessage(`HardhatConfig.networks.${networkName}.url`, netConfig.url, \"string\"));\n        }\n      }\n\n      const {\n        accounts\n      } = netConfig,\n            configExceptAccounts = __rest(netConfig, [\"accounts\"]);\n\n      const netConfigResult = HttpNetworkConfig.decode(configExceptAccounts);\n\n      if (netConfigResult.isLeft()) {\n        errors.push(getErrorMessage(`HardhatConfig.networks.${networkName}`, netConfig, \"HttpNetworkConfig\"));\n      } // manual validation of accounts\n\n\n      if (Array.isArray(accounts)) {\n        accounts.forEach((privateKey, index) => validatePrivateKey(privateKey, index, networkName, errors));\n      } else if (typeof accounts === \"object\") {\n        const hdConfigResult = HDAccountsConfig.decode(accounts);\n\n        if (hdConfigResult.isLeft()) {\n          errors.push(getErrorMessage(`HardhatConfig.networks.${networkName}`, accounts, \"HttpNetworkHDAccountsConfig\"));\n        }\n      } else if (typeof accounts === \"string\") {\n        if (accounts !== \"remote\") {\n          errors.push(`Invalid 'accounts' entry for network '${networkName}': expected an array of accounts or the string 'remote', but got the string '${accounts}'`);\n        }\n      } else if (accounts !== undefined) {\n        errors.push(getErrorMessage(`HardhatConfig.networks.${networkName}.accounts`, accounts, '\"remote\" | string[] | HttpNetworkHDAccountsConfig | undefined'));\n      }\n    }\n  } // io-ts can get confused if there are errors that it can't understand.\n  // Especially around Hardhat Network's config. It will treat it as an HTTPConfig,\n  // and may give a loot of errors.\n\n\n  if (errors.length > 0) {\n    return errors;\n  }\n\n  const result = HardhatConfig.decode(config);\n\n  if (result.isRight()) {\n    return errors;\n  }\n\n  const ioTsErrors = exports.DotPathReporter.report(result);\n  return [...errors, ...ioTsErrors];\n}\n\nexports.getValidationErrors = getValidationErrors;","map":{"version":3,"mappings":"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","names":["stringify","v","isFinite","isNaN","JSON","getContextPath","context","keysPath","slice","map","c","key","join","type","name","getMessage","e","lastContext","length","message","undefined","getErrorMessage","value","path","expectedType","getPrivateKeyError","index","network","validatePrivateKey","privateKey","errors","push","pkWithPrefix","test","exports","decode","isLeft","failure","es","success","report","validation","fold","HEX_STRING_REGEX","DEC_STRING_REGEX","isHexString","trim","match","isDecimalString","t","Type","u","identity","isAddress","trimmed","startsWith","HardhatNetworkAccount","balance","commonHDAccountsFields","initialIndex","number","count","string","HardhatNetworkHDAccountsConfig","Object","mnemonic","accountsBalance","Integer","num","parseInt","HardhatNetworkForkingConfig","enabled","boolean","url","blockNumber","HardhatNetworkMempoolConfig","order","keyof","constants_1","HardhatNetworkMiningConfig","auto","interval","union","tuple","mempool","isValidHardforkName","values","hardforks_1","includes","HardforkNameType","HardhatNetworkHardforkHistory","record","HardhatNetworkChainConfig","hardforkHistory","HardhatNetworkChainsConfig","commonNetworkConfigFields","chainId","from","gas","literal","gasPrice","gasMultiplier","HardhatNetworkConfig","hardfork","hf","accounts","array","blockGasLimit","minGasPrice","throwOnTransactionFailures","throwOnCallFailures","allowUnlimitedContractSize","initialDate","loggingEnabled","forking","mining","coinbase","chains","HDAccountsConfig","NetworkConfigAccounts","HttpHeaders","HttpNetworkConfig","httpHeaders","timeout","NetworkConfig","Networks","ProjectPaths","root","cache","artifacts","sources","tests","SingleSolcConfig","version","settings","any","MultiSolcConfig","compilers","overrides","SolidityConfig","HardhatConfig","defaultNetwork","networks","paths","solidity","validateConfig","config","getValidationErrors","errorList","errors_1","errors_list_1","GENERAL","INVALID_CONFIG","hardhatNetwork","configExceptAccounts","netConfigResult","Array","isArray","account","entries","hdConfigResult","_a","default_config_1","LONDON","initialBaseFeePerGas","forEach","chainEntry","chainConfig","keys","hardforkName","networkName","netConfig","result","isRight","ioTsErrors"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/internal/core/config/config-validation.ts"],"sourcesContent":["import * as t from \"io-ts\";\nimport { Context, getFunctionName, ValidationError } from \"io-ts/lib\";\nimport { Reporter } from \"io-ts/lib/Reporter\";\n\nimport {\n  HARDHAT_MEMPOOL_SUPPORTED_ORDERS,\n  HARDHAT_NETWORK_NAME,\n  HARDHAT_NETWORK_SUPPORTED_HARDFORKS,\n} from \"../../constants\";\nimport { optional } from \"../../util/io-ts\";\nimport { fromEntries } from \"../../util/lang\";\nimport { HardhatError } from \"../errors\";\nimport { ERRORS } from \"../errors-list\";\nimport { hardforkGte, HardforkName } from \"../../util/hardforks\";\nimport { HardhatNetworkChainUserConfig } from \"../../../types/config\";\nimport { defaultHardhatNetworkParams } from \"./default-config\";\n\nfunction stringify(v: any): string {\n  if (typeof v === \"function\") {\n    return getFunctionName(v);\n  }\n  if (typeof v === \"number\" && !isFinite(v)) {\n    if (isNaN(v)) {\n      return \"NaN\";\n    }\n    return v > 0 ? \"Infinity\" : \"-Infinity\";\n  }\n  return JSON.stringify(v);\n}\n\nfunction getContextPath(context: Context): string {\n  const keysPath = context\n    .slice(1)\n    .map((c) => c.key)\n    .join(\".\");\n\n  return `${context[0].type.name}.${keysPath}`;\n}\n\nfunction getMessage(e: ValidationError): string {\n  const lastContext = e.context[e.context.length - 1];\n\n  return e.message !== undefined\n    ? e.message\n    : getErrorMessage(\n        getContextPath(e.context),\n        e.value,\n        lastContext.type.name\n      );\n}\n\nfunction getErrorMessage(path: string, value: any, expectedType: string) {\n  return `Invalid value ${stringify(\n    value\n  )} for ${path} - Expected a value of type ${expectedType}.`;\n}\n\nfunction getPrivateKeyError(index: number, network: string, message: string) {\n  return `Invalid account: #${index} for network: ${network} - ${message}`;\n}\n\nfunction validatePrivateKey(\n  privateKey: unknown,\n  index: number,\n  network: string,\n  errors: string[]\n) {\n  if (typeof privateKey !== \"string\") {\n    errors.push(\n      getPrivateKeyError(\n        index,\n        network,\n        `Expected string, received ${typeof privateKey}`\n      )\n    );\n  } else {\n    // private key validation\n    const pkWithPrefix = /^0x/.test(privateKey)\n      ? privateKey\n      : `0x${privateKey}`;\n\n    // 32 bytes = 64 characters + 2 char prefix = 66\n    if (pkWithPrefix.length < 66) {\n      errors.push(\n        getPrivateKeyError(\n          index,\n          network,\n          \"private key too short, expected 32 bytes\"\n        )\n      );\n    } else if (pkWithPrefix.length > 66) {\n      errors.push(\n        getPrivateKeyError(\n          index,\n          network,\n          \"private key too long, expected 32 bytes\"\n        )\n      );\n    } else if (hexString.decode(pkWithPrefix).isLeft()) {\n      errors.push(\n        getPrivateKeyError(\n          index,\n          network,\n          \"invalid hex character(s) found in string\"\n        )\n      );\n    }\n  }\n}\n\nexport function failure(es: ValidationError[]): string[] {\n  return es.map(getMessage);\n}\n\nexport function success(): string[] {\n  return [];\n}\n\nexport const DotPathReporter: Reporter<string[]> = {\n  report: (validation) => validation.fold(failure, success),\n};\n\nconst HEX_STRING_REGEX = /^(0x)?([0-9a-f]{2})+$/gi;\nconst DEC_STRING_REGEX = /^(0|[1-9][0-9]*)$/g;\n\nfunction isHexString(v: unknown): v is string {\n  if (typeof v !== \"string\") {\n    return false;\n  }\n\n  return v.trim().match(HEX_STRING_REGEX) !== null;\n}\n\nfunction isDecimalString(v: unknown): v is string {\n  if (typeof v !== \"string\") {\n    return false;\n  }\n\n  return v.match(DEC_STRING_REGEX) !== null;\n}\n\nexport const hexString = new t.Type<string>(\n  \"hex string\",\n  isHexString,\n  (u, c) => (isHexString(u) ? t.success(u) : t.failure(u, c)),\n  t.identity\n);\n\nfunction isAddress(v: unknown): v is string {\n  if (typeof v !== \"string\") {\n    return false;\n  }\n\n  const trimmed = v.trim();\n\n  return (\n    trimmed.match(HEX_STRING_REGEX) !== null &&\n    trimmed.startsWith(\"0x\") &&\n    trimmed.length === 42\n  );\n}\n\nexport const address = new t.Type<string>(\n  \"address\",\n  isAddress,\n  (u, c) => (isAddress(u) ? t.success(u) : t.failure(u, c)),\n  t.identity\n);\n\nexport const decimalString = new t.Type<string>(\n  \"decimal string\",\n  isDecimalString,\n  (u, c) => (isDecimalString(u) ? t.success(u) : t.failure(u, c)),\n  t.identity\n);\n// TODO: These types have outdated name. They should match the UserConfig types.\n// IMPORTANT: This t.types MUST be kept in sync with the actual types.\n\nconst HardhatNetworkAccount = t.type({\n  privateKey: hexString,\n  balance: decimalString,\n});\n\nconst commonHDAccountsFields = {\n  initialIndex: optional(t.number),\n  count: optional(t.number),\n  path: optional(t.string),\n};\n\nconst HardhatNetworkHDAccountsConfig = t.type({\n  mnemonic: optional(t.string),\n  accountsBalance: optional(decimalString),\n  ...commonHDAccountsFields,\n});\n\nconst Integer = new t.Type<number>(\n  \"Integer\",\n  (num: unknown): num is number => typeof num === \"number\",\n  (u, c) => {\n    try {\n      return typeof u === \"string\"\n        ? t.success(parseInt(u, 10))\n        : t.failure(u, c);\n    } catch {\n      return t.failure(u, c);\n    }\n  },\n  t.identity\n);\n\nconst HardhatNetworkForkingConfig = t.type({\n  enabled: optional(t.boolean),\n  url: t.string,\n  blockNumber: optional(t.number),\n});\n\nconst HardhatNetworkMempoolConfig = t.type({\n  order: optional(\n    t.keyof(\n      fromEntries(\n        HARDHAT_MEMPOOL_SUPPORTED_ORDERS.map((order) => [order, null])\n      )\n    )\n  ),\n});\n\nconst HardhatNetworkMiningConfig = t.type({\n  auto: optional(t.boolean),\n  interval: optional(t.union([t.number, t.tuple([t.number, t.number])])),\n  mempool: optional(HardhatNetworkMempoolConfig),\n});\n\nfunction isValidHardforkName(name: string) {\n  return Object.values(HardforkName).includes(name as HardforkName);\n}\n\nconst HardforkNameType = new t.Type<HardforkName>(\n  Object.values(HardforkName)\n    .map((v) => `\"${v}\"`)\n    .join(\" | \"),\n  (name: unknown): name is HardforkName =>\n    typeof name === \"string\" && isValidHardforkName(name),\n  (u, c) => {\n    return typeof u === \"string\" && isValidHardforkName(u)\n      ? t.success(u as HardforkName)\n      : t.failure(u, c);\n  },\n  t.identity\n);\n\nconst HardhatNetworkHardforkHistory = t.record(\n  HardforkNameType,\n  t.number,\n  \"HardhatNetworkHardforkHistory\"\n);\n\nconst HardhatNetworkChainConfig = t.type({\n  hardforkHistory: HardhatNetworkHardforkHistory,\n});\n\nconst HardhatNetworkChainsConfig = t.record(Integer, HardhatNetworkChainConfig);\n\nconst commonNetworkConfigFields = {\n  chainId: optional(t.number),\n  from: optional(t.string),\n  gas: optional(t.union([t.literal(\"auto\"), t.number])),\n  gasPrice: optional(t.union([t.literal(\"auto\"), t.number])),\n  gasMultiplier: optional(t.number),\n};\n\nconst HardhatNetworkConfig = t.type({\n  ...commonNetworkConfigFields,\n  hardfork: optional(\n    t.keyof(\n      fromEntries(HARDHAT_NETWORK_SUPPORTED_HARDFORKS.map((hf) => [hf, null]))\n    )\n  ),\n  accounts: optional(\n    t.union([t.array(HardhatNetworkAccount), HardhatNetworkHDAccountsConfig])\n  ),\n  blockGasLimit: optional(t.number),\n  minGasPrice: optional(t.union([t.number, t.string])),\n  throwOnTransactionFailures: optional(t.boolean),\n  throwOnCallFailures: optional(t.boolean),\n  allowUnlimitedContractSize: optional(t.boolean),\n  initialDate: optional(t.string),\n  loggingEnabled: optional(t.boolean),\n  forking: optional(HardhatNetworkForkingConfig),\n  mining: optional(HardhatNetworkMiningConfig),\n  coinbase: optional(address),\n  chains: optional(HardhatNetworkChainsConfig),\n});\n\nconst HDAccountsConfig = t.type({\n  mnemonic: t.string,\n  ...commonHDAccountsFields,\n});\n\nconst NetworkConfigAccounts = t.union([\n  t.literal(\"remote\"),\n  t.array(hexString),\n  HDAccountsConfig,\n]);\n\nconst HttpHeaders = t.record(t.string, t.string, \"httpHeaders\");\n\nconst HttpNetworkConfig = t.type({\n  ...commonNetworkConfigFields,\n  url: optional(t.string),\n  accounts: optional(NetworkConfigAccounts),\n  httpHeaders: optional(HttpHeaders),\n  timeout: optional(t.number),\n});\n\nconst NetworkConfig = t.union([HardhatNetworkConfig, HttpNetworkConfig]);\n\nconst Networks = t.record(t.string, NetworkConfig);\n\nconst ProjectPaths = t.type({\n  root: optional(t.string),\n  cache: optional(t.string),\n  artifacts: optional(t.string),\n  sources: optional(t.string),\n  tests: optional(t.string),\n});\n\nconst SingleSolcConfig = t.type({\n  version: t.string,\n  settings: optional(t.any),\n});\n\nconst MultiSolcConfig = t.type({\n  compilers: t.array(SingleSolcConfig),\n  overrides: optional(t.record(t.string, SingleSolcConfig)),\n});\n\nconst SolidityConfig = t.union([t.string, SingleSolcConfig, MultiSolcConfig]);\n\nconst HardhatConfig = t.type(\n  {\n    defaultNetwork: optional(t.string),\n    networks: optional(Networks),\n    paths: optional(ProjectPaths),\n    solidity: optional(SolidityConfig),\n  },\n  \"HardhatConfig\"\n);\n\n/**\n * Validates the config, throwing a HardhatError if invalid.\n * @param config\n */\nexport function validateConfig(config: any) {\n  const errors = getValidationErrors(config);\n\n  if (errors.length === 0) {\n    return;\n  }\n\n  let errorList = errors.join(\"\\n  * \");\n  errorList = `  * ${errorList}`;\n\n  throw new HardhatError(ERRORS.GENERAL.INVALID_CONFIG, { errors: errorList });\n}\n\nexport function getValidationErrors(config: any): string[] {\n  const errors: string[] = [];\n\n  // These can't be validated with io-ts\n  if (config !== undefined && typeof config.networks === \"object\") {\n    const hardhatNetwork = config.networks[HARDHAT_NETWORK_NAME];\n    if (hardhatNetwork !== undefined && typeof hardhatNetwork === \"object\") {\n      if (\"url\" in hardhatNetwork) {\n        errors.push(\n          `HardhatConfig.networks.${HARDHAT_NETWORK_NAME} can't have an url`\n        );\n      }\n\n      // Validating the accounts with io-ts leads to very confusing errors messages\n      const { accounts, ...configExceptAccounts } = hardhatNetwork;\n\n      const netConfigResult = HardhatNetworkConfig.decode(configExceptAccounts);\n      if (netConfigResult.isLeft()) {\n        errors.push(\n          getErrorMessage(\n            `HardhatConfig.networks.${HARDHAT_NETWORK_NAME}`,\n            hardhatNetwork,\n            \"HardhatNetworkConfig\"\n          )\n        );\n      }\n\n      // manual validation of accounts\n      if (Array.isArray(accounts)) {\n        for (const [index, account] of accounts.entries()) {\n          if (typeof account !== \"object\") {\n            errors.push(\n              getPrivateKeyError(\n                index,\n                HARDHAT_NETWORK_NAME,\n                `Expected object, received ${typeof account}`\n              )\n            );\n            continue;\n          }\n\n          const { privateKey, balance } = account;\n\n          validatePrivateKey(privateKey, index, HARDHAT_NETWORK_NAME, errors);\n\n          if (typeof balance !== \"string\") {\n            errors.push(\n              getErrorMessage(\n                `HardhatConfig.networks.${HARDHAT_NETWORK_NAME}.accounts[].balance`,\n                balance,\n                \"string\"\n              )\n            );\n          } else if (decimalString.decode(balance).isLeft()) {\n            errors.push(\n              getErrorMessage(\n                `HardhatConfig.networks.${HARDHAT_NETWORK_NAME}.accounts[].balance`,\n                balance,\n                \"decimal(wei)\"\n              )\n            );\n          }\n        }\n      } else if (typeof hardhatNetwork.accounts === \"object\") {\n        const hdConfigResult = HardhatNetworkHDAccountsConfig.decode(\n          hardhatNetwork.accounts\n        );\n        if (hdConfigResult.isLeft()) {\n          errors.push(\n            getErrorMessage(\n              `HardhatConfig.networks.${HARDHAT_NETWORK_NAME}.accounts`,\n              hardhatNetwork.accounts,\n              \"[{privateKey: string, balance: string}] | HardhatNetworkHDAccountsConfig | undefined\"\n            )\n          );\n        }\n      } else if (hardhatNetwork.accounts !== undefined) {\n        errors.push(\n          getErrorMessage(\n            `HardhatConfig.networks.${HARDHAT_NETWORK_NAME}.accounts`,\n            hardhatNetwork.accounts,\n            \"[{privateKey: string, balance: string}] | HardhatNetworkHDAccountsConfig | undefined\"\n          )\n        );\n      }\n\n      const hardfork =\n        hardhatNetwork.hardfork ?? defaultHardhatNetworkParams.hardfork;\n      if (hardforkGte(hardfork, HardforkName.LONDON)) {\n        if (hardhatNetwork.minGasPrice !== undefined) {\n          errors.push(\n            `Unexpected config HardhatConfig.networks.${HARDHAT_NETWORK_NAME}.minGasPrice found - This field is not valid for networks with EIP-1559. Try an older hardfork or remove it.`\n          );\n        }\n      } else {\n        if (hardhatNetwork.initialBaseFeePerGas !== undefined) {\n          errors.push(\n            `Unexpected config HardhatConfig.networks.${HARDHAT_NETWORK_NAME}.initialBaseFeePerGas found - This field is only valid for networks with EIP-1559. Try a newer hardfork or remove it.`\n          );\n        }\n      }\n\n      if (hardhatNetwork.chains !== undefined) {\n        Object.entries(hardhatNetwork.chains).forEach((chainEntry) => {\n          const [chainId, chainConfig] = chainEntry as [\n            string,\n            HardhatNetworkChainUserConfig\n          ];\n          const { hardforkHistory } = chainConfig;\n          if (hardforkHistory !== undefined) {\n            Object.keys(hardforkHistory).forEach((hardforkName) => {\n              if (!HARDHAT_NETWORK_SUPPORTED_HARDFORKS.includes(hardforkName)) {\n                errors.push(\n                  getErrorMessage(\n                    `HardhatConfig.networks.${HARDHAT_NETWORK_NAME}.chains[${chainId}].hardforkHistory`,\n                    hardforkName,\n                    `\"${HARDHAT_NETWORK_SUPPORTED_HARDFORKS.join('\" | \"')}\"`\n                  )\n                );\n              }\n            });\n          }\n        });\n      }\n    }\n\n    for (const [networkName, netConfig] of Object.entries<any>(\n      config.networks\n    )) {\n      if (networkName === HARDHAT_NETWORK_NAME) {\n        continue;\n      }\n\n      if (networkName !== \"localhost\" || netConfig.url !== undefined) {\n        if (typeof netConfig.url !== \"string\") {\n          errors.push(\n            getErrorMessage(\n              `HardhatConfig.networks.${networkName}.url`,\n              netConfig.url,\n              \"string\"\n            )\n          );\n        }\n      }\n\n      const { accounts, ...configExceptAccounts } = netConfig;\n\n      const netConfigResult = HttpNetworkConfig.decode(configExceptAccounts);\n      if (netConfigResult.isLeft()) {\n        errors.push(\n          getErrorMessage(\n            `HardhatConfig.networks.${networkName}`,\n            netConfig,\n            \"HttpNetworkConfig\"\n          )\n        );\n      }\n\n      // manual validation of accounts\n      if (Array.isArray(accounts)) {\n        accounts.forEach((privateKey, index) =>\n          validatePrivateKey(privateKey, index, networkName, errors)\n        );\n      } else if (typeof accounts === \"object\") {\n        const hdConfigResult = HDAccountsConfig.decode(accounts);\n        if (hdConfigResult.isLeft()) {\n          errors.push(\n            getErrorMessage(\n              `HardhatConfig.networks.${networkName}`,\n              accounts,\n              \"HttpNetworkHDAccountsConfig\"\n            )\n          );\n        }\n      } else if (typeof accounts === \"string\") {\n        if (accounts !== \"remote\") {\n          errors.push(\n            `Invalid 'accounts' entry for network '${networkName}': expected an array of accounts or the string 'remote', but got the string '${accounts}'`\n          );\n        }\n      } else if (accounts !== undefined) {\n        errors.push(\n          getErrorMessage(\n            `HardhatConfig.networks.${networkName}.accounts`,\n            accounts,\n            '\"remote\" | string[] | HttpNetworkHDAccountsConfig | undefined'\n          )\n        );\n      }\n    }\n  }\n\n  // io-ts can get confused if there are errors that it can't understand.\n  // Especially around Hardhat Network's config. It will treat it as an HTTPConfig,\n  // and may give a loot of errors.\n  if (errors.length > 0) {\n    return errors;\n  }\n\n  const result = HardhatConfig.decode(config);\n\n  if (result.isRight()) {\n    return errors;\n  }\n\n  const ioTsErrors = DotPathReporter.report(result);\n  return [...errors, ...ioTsErrors];\n}\n"]},"metadata":{},"sourceType":"script"}