{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JsonRpcHandler = void 0;\n\nconst raw_body_1 = __importDefault(require(\"raw-body\"));\n\nconst errors_1 = require(\"../../core/providers/errors\");\n\nconst jsonrpc_1 = require(\"../../util/jsonrpc\");\n/* eslint-disable @nomiclabs/hardhat-internal-rules/only-hardhat-error */\n\n\nclass JsonRpcHandler {\n  constructor(_provider) {\n    this._provider = _provider;\n\n    this.handleHttp = async (req, res) => {\n      this._setCorsHeaders(res);\n\n      if (req.method === \"OPTIONS\") {\n        this._sendEmptyResponse(res);\n\n        return;\n      }\n\n      let jsonHttpRequest;\n\n      try {\n        jsonHttpRequest = await _readJsonHttpRequest(req);\n      } catch (error) {\n        this._sendResponse(res, _handleError(error));\n\n        return;\n      }\n\n      if (Array.isArray(jsonHttpRequest)) {\n        const responses = await Promise.all(jsonHttpRequest.map(singleReq => this._handleSingleRequest(singleReq)));\n\n        this._sendResponse(res, responses);\n\n        return;\n      }\n\n      const rpcResp = await this._handleSingleRequest(jsonHttpRequest);\n\n      this._sendResponse(res, rpcResp);\n    };\n\n    this.handleWs = async ws => {\n      const subscriptions = [];\n      let isClosed = false;\n\n      const listener = payload => {\n        // Don't attempt to send a message to the websocket if we already know it is closed,\n        // or the current websocket connection isn't interested in the particular subscription.\n        if (isClosed || !subscriptions.includes(payload.subscription)) {\n          return;\n        }\n\n        try {\n          ws.send(JSON.stringify({\n            jsonrpc: \"2.0\",\n            method: \"eth_subscription\",\n            params: payload\n          }));\n        } catch (error) {\n          _handleError(error);\n        }\n      }; // Handle eth_subscribe notifications.\n\n\n      this._provider.addListener(\"notification\", listener);\n\n      ws.on(\"message\", async msg => {\n        let rpcReq;\n        let rpcResp;\n\n        try {\n          rpcReq = _readWsRequest(msg);\n\n          if (!(0, jsonrpc_1.isValidJsonRequest)(rpcReq)) {\n            throw new errors_1.InvalidRequestError(\"Invalid request\");\n          }\n\n          rpcResp = await this._handleRequest(rpcReq); // If eth_subscribe was successful, keep track of the subscription id,\n          // so we can cleanup on websocket close.\n\n          if (rpcReq.method === \"eth_subscribe\" && (0, jsonrpc_1.isSuccessfulJsonResponse)(rpcResp)) {\n            subscriptions.push(rpcResp.result);\n          }\n        } catch (error) {\n          rpcResp = _handleError(error);\n        } // Validate the RPC response.\n\n\n        if (!(0, jsonrpc_1.isValidJsonResponse)(rpcResp)) {\n          // Malformed response coming from the provider, report to user as an internal error.\n          rpcResp = _handleError(new errors_1.InternalError(\"Internal error\"));\n        }\n\n        if (rpcReq !== undefined) {\n          rpcResp.id = rpcReq.id;\n        }\n\n        ws.send(JSON.stringify(rpcResp));\n      });\n      ws.on(\"close\", () => {\n        // Remove eth_subscribe listener.\n        this._provider.removeListener(\"notification\", listener); // Clear any active subscriptions for the closed websocket connection.\n\n\n        isClosed = true;\n        subscriptions.forEach(async subscriptionId => {\n          await this._provider.request({\n            method: \"eth_unsubscribe\",\n            params: [subscriptionId]\n          });\n        });\n      });\n    };\n\n    this._handleRequest = async req => {\n      const result = await this._provider.request({\n        method: req.method,\n        params: req.params\n      });\n      return {\n        jsonrpc: \"2.0\",\n        id: req.id,\n        result\n      };\n    };\n  }\n\n  _sendEmptyResponse(res) {\n    res.writeHead(200);\n    res.end();\n  }\n\n  _setCorsHeaders(res) {\n    res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n    res.setHeader(\"Access-Control-Request-Method\", \"*\");\n    res.setHeader(\"Access-Control-Allow-Methods\", \"OPTIONS, GET\");\n    res.setHeader(\"Access-Control-Allow-Headers\", \"*\");\n  }\n\n  _sendResponse(res, rpcResp) {\n    res.statusCode = 200;\n    res.setHeader(\"Content-Type\", \"application/json\");\n    res.end(JSON.stringify(rpcResp));\n  }\n\n  async _handleSingleRequest(req) {\n    if (!(0, jsonrpc_1.isValidJsonRequest)(req)) {\n      return _handleError(new errors_1.InvalidRequestError(\"Invalid request\"));\n    }\n\n    const rpcReq = req;\n    let rpcResp;\n\n    try {\n      rpcResp = await this._handleRequest(rpcReq);\n    } catch (error) {\n      rpcResp = _handleError(error);\n    } // Validate the RPC response.\n\n\n    if (!(0, jsonrpc_1.isValidJsonResponse)(rpcResp)) {\n      // Malformed response coming from the provider, report to user as an internal error.\n      rpcResp = _handleError(new errors_1.InternalError(\"Internal error\"));\n    }\n\n    if (rpcReq !== undefined) {\n      rpcResp.id = rpcReq.id !== undefined ? rpcReq.id : null;\n    }\n\n    return rpcResp;\n  }\n\n}\n\nexports.JsonRpcHandler = JsonRpcHandler;\n\nconst _readJsonHttpRequest = async req => {\n  let json;\n\n  try {\n    const buf = await (0, raw_body_1.default)(req);\n    const text = buf.toString();\n    json = JSON.parse(text);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new errors_1.InvalidJsonInputError(`Parse error: ${error.message}`);\n    } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n    throw error;\n  }\n\n  return json;\n};\n\nconst _readWsRequest = msg => {\n  let json;\n\n  try {\n    json = JSON.parse(msg);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new errors_1.InvalidJsonInputError(`Parse error: ${error.message}`);\n    } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n    throw error;\n  }\n\n  return json;\n};\n\nconst _handleError = error => {\n  let txHash;\n\n  if (error.transactionHash !== undefined) {\n    txHash = error.transactionHash;\n  } // In case of non-hardhat error, treat it as internal and associate the appropriate error code.\n\n\n  if (!errors_1.ProviderError.isProviderError(error)) {\n    error = new errors_1.InternalError(error);\n  }\n\n  const response = {\n    jsonrpc: \"2.0\",\n    id: null,\n    error: {\n      code: error.code,\n      message: error.message\n    }\n  };\n\n  if (txHash !== undefined) {\n    response.error.data = {\n      txHash\n    };\n  }\n\n  return response;\n};","map":{"version":3,"mappings":"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","names":["JsonRpcHandler","constructor","_provider","req","res","_setCorsHeaders","method","_sendEmptyResponse","jsonHttpRequest","_readJsonHttpRequest","error","_sendResponse","_handleError","Array","isArray","responses","Promise","all","map","singleReq","_handleSingleRequest","rpcResp","ws","subscriptions","isClosed","listener","payload","includes","subscription","send","JSON","stringify","jsonrpc","params","addListener","on","msg","rpcReq","_readWsRequest","errors_1","_handleRequest","push","result","undefined","id","removeListener","forEach","subscriptionId","request","writeHead","end","setHeader","statusCode","exports","json","buf","text","toString","parse","Error","message","txHash","transactionHash","isProviderError","response","code","data"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/internal/hardhat-network/jsonrpc/handler.ts"],"sourcesContent":["import { IncomingMessage, ServerResponse } from \"http\";\nimport getRawBody from \"raw-body\";\nimport WebSocket from \"ws\";\n\nimport { EIP1193Provider } from \"../../../types\";\nimport {\n  InternalError,\n  InvalidJsonInputError,\n  InvalidRequestError,\n  ProviderError,\n} from \"../../core/providers/errors\";\nimport {\n  FailedJsonRpcResponse,\n  isSuccessfulJsonResponse,\n  isValidJsonRequest,\n  isValidJsonResponse,\n  JsonRpcRequest,\n  JsonRpcResponse,\n} from \"../../util/jsonrpc\";\n\n/* eslint-disable @nomiclabs/hardhat-internal-rules/only-hardhat-error */\n\nexport class JsonRpcHandler {\n  constructor(private readonly _provider: EIP1193Provider) {}\n\n  public handleHttp = async (req: IncomingMessage, res: ServerResponse) => {\n    this._setCorsHeaders(res);\n    if (req.method === \"OPTIONS\") {\n      this._sendEmptyResponse(res);\n      return;\n    }\n\n    let jsonHttpRequest: any;\n    try {\n      jsonHttpRequest = await _readJsonHttpRequest(req);\n    } catch (error) {\n      this._sendResponse(res, _handleError(error));\n      return;\n    }\n\n    if (Array.isArray(jsonHttpRequest)) {\n      const responses = await Promise.all(\n        jsonHttpRequest.map((singleReq: any) =>\n          this._handleSingleRequest(singleReq)\n        )\n      );\n\n      this._sendResponse(res, responses);\n      return;\n    }\n\n    const rpcResp = await this._handleSingleRequest(jsonHttpRequest);\n\n    this._sendResponse(res, rpcResp);\n  };\n\n  public handleWs = async (ws: WebSocket) => {\n    const subscriptions: string[] = [];\n    let isClosed = false;\n\n    const listener = (payload: { subscription: string; result: any }) => {\n      // Don't attempt to send a message to the websocket if we already know it is closed,\n      // or the current websocket connection isn't interested in the particular subscription.\n      if (isClosed || !subscriptions.includes(payload.subscription)) {\n        return;\n      }\n\n      try {\n        ws.send(\n          JSON.stringify({\n            jsonrpc: \"2.0\",\n            method: \"eth_subscription\",\n            params: payload,\n          })\n        );\n      } catch (error) {\n        _handleError(error);\n      }\n    };\n\n    // Handle eth_subscribe notifications.\n    this._provider.addListener(\"notification\", listener);\n\n    ws.on(\"message\", async (msg) => {\n      let rpcReq: JsonRpcRequest | undefined;\n      let rpcResp: JsonRpcResponse | undefined;\n\n      try {\n        rpcReq = _readWsRequest(msg as string);\n\n        if (!isValidJsonRequest(rpcReq)) {\n          throw new InvalidRequestError(\"Invalid request\");\n        }\n\n        rpcResp = await this._handleRequest(rpcReq);\n\n        // If eth_subscribe was successful, keep track of the subscription id,\n        // so we can cleanup on websocket close.\n        if (\n          rpcReq.method === \"eth_subscribe\" &&\n          isSuccessfulJsonResponse(rpcResp)\n        ) {\n          subscriptions.push(rpcResp.result);\n        }\n      } catch (error) {\n        rpcResp = _handleError(error);\n      }\n\n      // Validate the RPC response.\n      if (!isValidJsonResponse(rpcResp)) {\n        // Malformed response coming from the provider, report to user as an internal error.\n        rpcResp = _handleError(new InternalError(\"Internal error\"));\n      }\n\n      if (rpcReq !== undefined) {\n        rpcResp.id = rpcReq.id;\n      }\n\n      ws.send(JSON.stringify(rpcResp));\n    });\n\n    ws.on(\"close\", () => {\n      // Remove eth_subscribe listener.\n      this._provider.removeListener(\"notification\", listener);\n\n      // Clear any active subscriptions for the closed websocket connection.\n      isClosed = true;\n      subscriptions.forEach(async (subscriptionId) => {\n        await this._provider.request({\n          method: \"eth_unsubscribe\",\n          params: [subscriptionId],\n        });\n      });\n    });\n  };\n\n  private _sendEmptyResponse(res: ServerResponse) {\n    res.writeHead(200);\n    res.end();\n  }\n\n  private _setCorsHeaders(res: ServerResponse) {\n    res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n    res.setHeader(\"Access-Control-Request-Method\", \"*\");\n    res.setHeader(\"Access-Control-Allow-Methods\", \"OPTIONS, GET\");\n    res.setHeader(\"Access-Control-Allow-Headers\", \"*\");\n  }\n\n  private _sendResponse(\n    res: ServerResponse,\n    rpcResp: JsonRpcResponse | JsonRpcResponse[]\n  ) {\n    res.statusCode = 200;\n    res.setHeader(\"Content-Type\", \"application/json\");\n    res.end(JSON.stringify(rpcResp));\n  }\n\n  private async _handleSingleRequest(req: any): Promise<JsonRpcResponse> {\n    if (!isValidJsonRequest(req)) {\n      return _handleError(new InvalidRequestError(\"Invalid request\"));\n    }\n\n    const rpcReq: JsonRpcRequest = req;\n    let rpcResp: JsonRpcResponse | undefined;\n\n    try {\n      rpcResp = await this._handleRequest(rpcReq);\n    } catch (error) {\n      rpcResp = _handleError(error);\n    }\n\n    // Validate the RPC response.\n    if (!isValidJsonResponse(rpcResp)) {\n      // Malformed response coming from the provider, report to user as an internal error.\n      rpcResp = _handleError(new InternalError(\"Internal error\"));\n    }\n\n    if (rpcReq !== undefined) {\n      rpcResp.id = rpcReq.id !== undefined ? rpcReq.id : null;\n    }\n\n    return rpcResp;\n  }\n\n  private _handleRequest = async (\n    req: JsonRpcRequest\n  ): Promise<JsonRpcResponse> => {\n    const result = await this._provider.request({\n      method: req.method,\n      params: req.params,\n    });\n\n    return {\n      jsonrpc: \"2.0\",\n      id: req.id,\n      result,\n    };\n  };\n}\n\nconst _readJsonHttpRequest = async (req: IncomingMessage): Promise<any> => {\n  let json;\n\n  try {\n    const buf = await getRawBody(req);\n    const text = buf.toString();\n\n    json = JSON.parse(text);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new InvalidJsonInputError(`Parse error: ${error.message}`);\n    }\n\n    // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n\n  return json;\n};\n\nconst _readWsRequest = (msg: string): JsonRpcRequest => {\n  let json: any;\n  try {\n    json = JSON.parse(msg);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new InvalidJsonInputError(`Parse error: ${error.message}`);\n    }\n\n    // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n\n  return json;\n};\n\nconst _handleError = (error: any): JsonRpcResponse => {\n  let txHash: string | undefined;\n  if (error.transactionHash !== undefined) {\n    txHash = error.transactionHash;\n  }\n\n  // In case of non-hardhat error, treat it as internal and associate the appropriate error code.\n  if (!ProviderError.isProviderError(error)) {\n    error = new InternalError(error);\n  }\n\n  const response: FailedJsonRpcResponse = {\n    jsonrpc: \"2.0\",\n    id: null,\n    error: {\n      code: error.code,\n      message: error.message,\n    },\n  };\n\n  if (txHash !== undefined) {\n    response.error.data = {\n      txHash,\n    };\n  }\n\n  return response;\n};\n"]},"metadata":{},"sourceType":"script"}