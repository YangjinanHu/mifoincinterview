{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HttpProvider = void 0;\n\nconst events_1 = require(\"events\");\n\nconst constants_1 = require(\"../../constants\");\n\nconst jsonrpc_1 = require(\"../../util/jsonrpc\");\n\nconst errors_1 = require(\"../errors\");\n\nconst errors_list_1 = require(\"../errors-list\");\n\nconst errors_2 = require(\"./errors\");\n\nfunction isErrorResponse(response) {\n  return typeof response.error !== \"undefined\";\n}\n\nconst MAX_RETRIES = 6;\nconst MAX_RETRY_AWAIT_SECONDS = 5;\nconst TOO_MANY_REQUEST_STATUS = 429;\n\nclass HttpProvider extends events_1.EventEmitter {\n  constructor(_url, _networkName) {\n    let _extraHeaders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    let _timeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 20000;\n\n    super();\n    this._url = _url;\n    this._networkName = _networkName;\n    this._extraHeaders = _extraHeaders;\n    this._timeout = _timeout;\n    this._nextRequestId = 1;\n  }\n\n  get url() {\n    return this._url;\n  }\n\n  async request(args) {\n    // We create the error here to capture the stack traces at this point,\n    // the async call that follows would probably loose of the stack trace\n    const error = new errors_2.ProviderError(\"HttpProviderError\", -1);\n\n    const jsonRpcRequest = this._getJsonRpcRequest(args.method, args.params);\n\n    const jsonRpcResponse = await this._fetchJsonRpcResponse(jsonRpcRequest);\n\n    if (isErrorResponse(jsonRpcResponse)) {\n      error.message = jsonRpcResponse.error.message;\n      error.code = jsonRpcResponse.error.code;\n      error.data = jsonRpcResponse.error.data; // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n      throw error;\n    }\n\n    if (args.method === \"hardhat_reset\") {\n      this.emit(constants_1.HARDHAT_NETWORK_RESET_EVENT);\n    }\n\n    if (args.method === \"evm_revert\") {\n      this.emit(constants_1.HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT);\n    }\n\n    return jsonRpcResponse.result;\n  }\n  /**\n   * Sends a batch of requests. Fails if any of them fails.\n   */\n\n\n  async sendBatch(batch) {\n    // We create the errors here to capture the stack traces at this point,\n    // the async call that follows would probably loose of the stack trace\n    const error = new errors_2.ProviderError(\"HttpProviderError\", -1); // we need this to sort the responses\n\n    const idToIndexMap = {};\n    const requests = batch.map((r, i) => {\n      const jsonRpcRequest = this._getJsonRpcRequest(r.method, r.params);\n\n      idToIndexMap[jsonRpcRequest.id] = i;\n      return jsonRpcRequest;\n    });\n    const jsonRpcResponses = await this._fetchJsonRpcResponse(requests);\n\n    for (const response of jsonRpcResponses) {\n      if (isErrorResponse(response)) {\n        error.message = response.error.message;\n        error.code = response.error.code;\n        error.data = response.error.data; // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n        throw error;\n      }\n    } // We already know that it has this type, but TS can't infer it.\n\n\n    const responses = jsonRpcResponses; // we use the id to sort the responses so that they match the order of the requests\n\n    const sortedResponses = responses.map(response => [idToIndexMap[response.id], response.result]).sort((_ref, _ref2) => {\n      let [indexA] = _ref;\n      let [indexB] = _ref2;\n      return indexA - indexB;\n    }).map(_ref3 => {\n      let [, result] = _ref3;\n      return result;\n    });\n    return sortedResponses;\n  }\n\n  async _fetchJsonRpcResponse(request) {\n    let retryNumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const {\n      default: fetch\n    } = await Promise.resolve().then(() => __importStar(require(\"node-fetch\")));\n\n    try {\n      const response = await fetch(this._url, {\n        method: \"POST\",\n        body: JSON.stringify(request),\n        redirect: \"follow\",\n        timeout: process.env.DO_NOT_SET_THIS_ENV_VAR____IS_HARDHAT_CI !== undefined ? 0 : this._timeout,\n        headers: Object.assign({\n          \"Content-Type\": \"application/json\"\n        }, this._extraHeaders)\n      });\n\n      if (this._isRateLimitResponse(response)) {\n        // Consume the response stream and discard its result\n        // See: https://github.com/node-fetch/node-fetch/issues/83\n        const _discarded = await response.text();\n\n        const seconds = this._getRetryAfterSeconds(response);\n\n        if (seconds !== undefined && this._shouldRetry(retryNumber, seconds)) {\n          return await this._retry(request, seconds, retryNumber);\n        }\n\n        const url = new URL(this._url); // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n        throw new errors_2.ProviderError(`Too Many Requests error received from ${url.hostname}`, -32005 // Limit exceeded according to EIP1474\n        );\n      }\n\n      return (0, jsonrpc_1.parseJsonResponse)(await response.text());\n    } catch (error) {\n      if (error.code === \"ECONNREFUSED\") {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.NODE_IS_NOT_RUNNING, {\n          network: this._networkName\n        }, error);\n      }\n\n      if (error.type === \"request-timeout\") {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.NETWORK_TIMEOUT, {}, error);\n      } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n      throw error;\n    }\n  }\n\n  async _retry(request, seconds, retryNumber) {\n    await new Promise(resolve => setTimeout(resolve, 1000 * seconds));\n    return this._fetchJsonRpcResponse(request, retryNumber + 1);\n  }\n\n  _getJsonRpcRequest(method) {\n    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return {\n      jsonrpc: \"2.0\",\n      method,\n      params,\n      id: this._nextRequestId++\n    };\n  }\n\n  _shouldRetry(retryNumber, retryAfterSeconds) {\n    if (retryNumber > MAX_RETRIES) {\n      return false;\n    }\n\n    if (retryAfterSeconds > MAX_RETRY_AWAIT_SECONDS) {\n      return false;\n    }\n\n    return true;\n  }\n\n  _isRateLimitResponse(response) {\n    return response.status === TOO_MANY_REQUEST_STATUS;\n  }\n\n  _getRetryAfterSeconds(response) {\n    const header = response.headers.get(\"Retry-After\");\n\n    if (header === undefined || header === null) {\n      return undefined;\n    }\n\n    const parsed = parseInt(header, 10);\n\n    if (isNaN(parsed)) {\n      return undefined;\n    }\n\n    return parsed;\n  }\n\n}\n\nexports.HttpProvider = HttpProvider;","map":{"version":3,"mappings":"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","names":["isErrorResponse","response","error","MAX_RETRIES","MAX_RETRY_AWAIT_SECONDS","TOO_MANY_REQUEST_STATUS","HttpProvider","events_1","constructor","_url","_networkName","_extraHeaders","_timeout","url","request","args","errors_2","jsonRpcRequest","_getJsonRpcRequest","method","params","jsonRpcResponse","_fetchJsonRpcResponse","message","code","data","emit","constants_1","result","sendBatch","batch","idToIndexMap","requests","map","r","i","id","jsonRpcResponses","responses","sortedResponses","sort","indexA","indexB","retryNumber","default","fetch","body","JSON","stringify","redirect","timeout","process","env","DO_NOT_SET_THIS_ENV_VAR____IS_HARDHAT_CI","undefined","headers","_isRateLimitResponse","_discarded","text","seconds","_getRetryAfterSeconds","_shouldRetry","_retry","URL","hostname","errors_1","errors_list_1","NETWORK","NODE_IS_NOT_RUNNING","network","type","NETWORK_TIMEOUT","Promise","resolve","setTimeout","jsonrpc","_nextRequestId","retryAfterSeconds","status","header","get","parsed","parseInt","isNaN","exports"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/internal/core/providers/http.ts"],"sourcesContent":["import { EventEmitter } from \"events\";\nimport type { Response } from \"node-fetch\";\n\nimport { EIP1193Provider, RequestArguments } from \"../../../types\";\nimport {\n  HARDHAT_NETWORK_RESET_EVENT,\n  HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT,\n} from \"../../constants\";\nimport {\n  FailedJsonRpcResponse,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  parseJsonResponse,\n  SuccessfulJsonRpcResponse,\n} from \"../../util/jsonrpc\";\nimport { HardhatError } from \"../errors\";\nimport { ERRORS } from \"../errors-list\";\n\nimport { ProviderError } from \"./errors\";\n\nfunction isErrorResponse(response: any): response is FailedJsonRpcResponse {\n  return typeof response.error !== \"undefined\";\n}\n\nconst MAX_RETRIES = 6;\nconst MAX_RETRY_AWAIT_SECONDS = 5;\n\nconst TOO_MANY_REQUEST_STATUS = 429;\n\nexport class HttpProvider extends EventEmitter implements EIP1193Provider {\n  private _nextRequestId = 1;\n\n  constructor(\n    private readonly _url: string,\n    private readonly _networkName: string,\n    private readonly _extraHeaders: { [name: string]: string } = {},\n    private readonly _timeout = 20000\n  ) {\n    super();\n  }\n\n  public get url(): string {\n    return this._url;\n  }\n\n  public async request(args: RequestArguments): Promise<unknown> {\n    // We create the error here to capture the stack traces at this point,\n    // the async call that follows would probably loose of the stack trace\n    const error = new ProviderError(\"HttpProviderError\", -1);\n\n    const jsonRpcRequest = this._getJsonRpcRequest(\n      args.method,\n      args.params as any[]\n    );\n    const jsonRpcResponse = await this._fetchJsonRpcResponse(jsonRpcRequest);\n\n    if (isErrorResponse(jsonRpcResponse)) {\n      error.message = jsonRpcResponse.error.message;\n      error.code = jsonRpcResponse.error.code;\n      error.data = jsonRpcResponse.error.data;\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n\n    if (args.method === \"hardhat_reset\") {\n      this.emit(HARDHAT_NETWORK_RESET_EVENT);\n    }\n    if (args.method === \"evm_revert\") {\n      this.emit(HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT);\n    }\n\n    return jsonRpcResponse.result;\n  }\n\n  /**\n   * Sends a batch of requests. Fails if any of them fails.\n   */\n  public async sendBatch(\n    batch: Array<{ method: string; params: any[] }>\n  ): Promise<any[]> {\n    // We create the errors here to capture the stack traces at this point,\n    // the async call that follows would probably loose of the stack trace\n    const error = new ProviderError(\"HttpProviderError\", -1);\n\n    // we need this to sort the responses\n    const idToIndexMap: Record<string, number> = {};\n\n    const requests = batch.map((r, i) => {\n      const jsonRpcRequest = this._getJsonRpcRequest(r.method, r.params);\n      idToIndexMap[jsonRpcRequest.id] = i;\n      return jsonRpcRequest;\n    });\n\n    const jsonRpcResponses = await this._fetchJsonRpcResponse(requests);\n\n    for (const response of jsonRpcResponses) {\n      if (isErrorResponse(response)) {\n        error.message = response.error.message;\n        error.code = response.error.code;\n        error.data = response.error.data;\n        // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n        throw error;\n      }\n    }\n\n    // We already know that it has this type, but TS can't infer it.\n    const responses = jsonRpcResponses as SuccessfulJsonRpcResponse[];\n\n    // we use the id to sort the responses so that they match the order of the requests\n    const sortedResponses = responses\n      .map(\n        (response) =>\n          [idToIndexMap[response.id], response.result] as [number, any]\n      )\n      .sort(([indexA], [indexB]) => indexA - indexB)\n      .map(([, result]) => result);\n\n    return sortedResponses;\n  }\n\n  private async _fetchJsonRpcResponse(\n    request: JsonRpcRequest,\n    retryNumber?: number\n  ): Promise<JsonRpcResponse>;\n  private async _fetchJsonRpcResponse(\n    request: JsonRpcRequest[],\n    retryNumber?: number\n  ): Promise<JsonRpcResponse[]>;\n  private async _fetchJsonRpcResponse(\n    request: JsonRpcRequest | JsonRpcRequest[],\n    retryNumber?: number\n  ): Promise<JsonRpcResponse | JsonRpcResponse[]>;\n  private async _fetchJsonRpcResponse(\n    request: JsonRpcRequest | JsonRpcRequest[],\n    retryNumber = 0\n  ): Promise<JsonRpcResponse | JsonRpcResponse[]> {\n    const { default: fetch } = await import(\"node-fetch\");\n\n    try {\n      const response = await fetch(this._url, {\n        method: \"POST\",\n        body: JSON.stringify(request),\n        redirect: \"follow\",\n        timeout:\n          process.env.DO_NOT_SET_THIS_ENV_VAR____IS_HARDHAT_CI !== undefined\n            ? 0\n            : this._timeout,\n        headers: {\n          \"Content-Type\": \"application/json\",\n          ...this._extraHeaders,\n        },\n      });\n\n      if (this._isRateLimitResponse(response)) {\n        // Consume the response stream and discard its result\n        // See: https://github.com/node-fetch/node-fetch/issues/83\n        const _discarded = await response.text();\n\n        const seconds = this._getRetryAfterSeconds(response);\n        if (seconds !== undefined && this._shouldRetry(retryNumber, seconds)) {\n          return await this._retry(request, seconds, retryNumber);\n        }\n\n        const url = new URL(this._url);\n\n        // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n        throw new ProviderError(\n          `Too Many Requests error received from ${url.hostname}`,\n          -32005 // Limit exceeded according to EIP1474\n        );\n      }\n\n      return parseJsonResponse(await response.text());\n    } catch (error: any) {\n      if (error.code === \"ECONNREFUSED\") {\n        throw new HardhatError(\n          ERRORS.NETWORK.NODE_IS_NOT_RUNNING,\n          { network: this._networkName },\n          error\n        );\n      }\n\n      if (error.type === \"request-timeout\") {\n        throw new HardhatError(ERRORS.NETWORK.NETWORK_TIMEOUT, {}, error);\n      }\n\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n  }\n\n  private async _retry(\n    request: JsonRpcRequest | JsonRpcRequest[],\n    seconds: number,\n    retryNumber: number\n  ) {\n    await new Promise((resolve) => setTimeout(resolve, 1000 * seconds));\n    return this._fetchJsonRpcResponse(request, retryNumber + 1);\n  }\n\n  private _getJsonRpcRequest(\n    method: string,\n    params: any[] = []\n  ): JsonRpcRequest {\n    return {\n      jsonrpc: \"2.0\",\n      method,\n      params,\n      id: this._nextRequestId++,\n    };\n  }\n\n  private _shouldRetry(retryNumber: number, retryAfterSeconds: number) {\n    if (retryNumber > MAX_RETRIES) {\n      return false;\n    }\n\n    if (retryAfterSeconds > MAX_RETRY_AWAIT_SECONDS) {\n      return false;\n    }\n\n    return true;\n  }\n\n  private _isRateLimitResponse(response: Response) {\n    return response.status === TOO_MANY_REQUEST_STATUS;\n  }\n\n  private _getRetryAfterSeconds(response: Response): number | undefined {\n    const header = response.headers.get(\"Retry-After\");\n\n    if (header === undefined || header === null) {\n      return undefined;\n    }\n\n    const parsed = parseInt(header, 10);\n    if (isNaN(parsed)) {\n      return undefined;\n    }\n\n    return parsed;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}