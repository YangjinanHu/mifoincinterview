{"ast":null,"code":"import { __assign, __values } from \"tslib\";\nimport { isInstanceOf, isString } from './is';\nimport { logger } from './logger';\nimport { getGlobalObject } from './misc';\nimport { fill } from './object';\nimport { getFunctionName } from './stacktrace';\nimport { supportsHistory, supportsNativeFetch } from './supports';\nvar global = getGlobalObject();\n/**\n * Instrument native APIs to call handlers that can be used to create breadcrumbs, APM spans etc.\n *  - Console API\n *  - Fetch API\n *  - XHR API\n *  - History API\n *  - DOM API (click/typing)\n *  - Error API\n *  - UnhandledRejection API\n */\n\nvar handlers = {};\nvar instrumented = {};\n/** Instruments given API */\n\nfunction instrument(type) {\n  if (instrumented[type]) {\n    return;\n  }\n\n  instrumented[type] = true;\n\n  switch (type) {\n    case 'console':\n      instrumentConsole();\n      break;\n\n    case 'dom':\n      instrumentDOM();\n      break;\n\n    case 'xhr':\n      instrumentXHR();\n      break;\n\n    case 'fetch':\n      instrumentFetch();\n      break;\n\n    case 'history':\n      instrumentHistory();\n      break;\n\n    case 'error':\n      instrumentError();\n      break;\n\n    case 'unhandledrejection':\n      instrumentUnhandledRejection();\n      break;\n\n    default:\n      logger.warn('unknown instrumentation type:', type);\n  }\n}\n/**\n * Add handler that will be called when given type of instrumentation triggers.\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\n\n\nexport function addInstrumentationHandler(handler) {\n  if (!handler || typeof handler.type !== 'string' || typeof handler.callback !== 'function') {\n    return;\n  }\n\n  handlers[handler.type] = handlers[handler.type] || [];\n  handlers[handler.type].push(handler.callback);\n  instrument(handler.type);\n}\n/** JSDoc */\n\nfunction triggerHandlers(type, data) {\n  var e_1, _a;\n\n  if (!type || !handlers[type]) {\n    return;\n  }\n\n  try {\n    for (var _b = __values(handlers[type] || []), _c = _b.next(); !_c.done; _c = _b.next()) {\n      var handler = _c.value;\n\n      try {\n        handler(data);\n      } catch (e) {\n        logger.error(\"Error while triggering instrumentation handler.\\nType: \" + type + \"\\nName: \" + getFunctionName(handler) + \"\\nError: \" + e);\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n}\n/** JSDoc */\n\n\nfunction instrumentConsole() {\n  if (!('console' in global)) {\n    return;\n  }\n\n  ['debug', 'info', 'warn', 'error', 'log', 'assert'].forEach(function (level) {\n    if (!(level in global.console)) {\n      return;\n    }\n\n    fill(global.console, level, function (originalConsoleLevel) {\n      return function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        triggerHandlers('console', {\n          args: args,\n          level: level\n        }); // this fails for some browsers. :(\n\n        if (originalConsoleLevel) {\n          Function.prototype.apply.call(originalConsoleLevel, global.console, args);\n        }\n      };\n    });\n  });\n}\n/** JSDoc */\n\n\nfunction instrumentFetch() {\n  if (!supportsNativeFetch()) {\n    return;\n  }\n\n  fill(global, 'fetch', function (originalFetch) {\n    return function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var handlerData = {\n        args: args,\n        fetchData: {\n          method: getFetchMethod(args),\n          url: getFetchUrl(args)\n        },\n        startTimestamp: Date.now()\n      };\n      triggerHandlers('fetch', __assign({}, handlerData)); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n      return originalFetch.apply(global, args).then(function (response) {\n        triggerHandlers('fetch', __assign(__assign({}, handlerData), {\n          endTimestamp: Date.now(),\n          response: response\n        }));\n        return response;\n      }, function (error) {\n        triggerHandlers('fetch', __assign(__assign({}, handlerData), {\n          endTimestamp: Date.now(),\n          error: error\n        })); // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n        //       it means the sentry.javascript SDK caught an error invoking your application code.\n        //       This is expected behavior and NOT indicative of a bug with sentry.javascript.\n\n        throw error;\n      });\n    };\n  });\n}\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n\n/** Extract `method` from fetch call arguments */\n\n\nfunction getFetchMethod(fetchArgs) {\n  if (fetchArgs === void 0) {\n    fetchArgs = [];\n  }\n\n  if ('Request' in global && isInstanceOf(fetchArgs[0], Request) && fetchArgs[0].method) {\n    return String(fetchArgs[0].method).toUpperCase();\n  }\n\n  if (fetchArgs[1] && fetchArgs[1].method) {\n    return String(fetchArgs[1].method).toUpperCase();\n  }\n\n  return 'GET';\n}\n/** Extract `url` from fetch call arguments */\n\n\nfunction getFetchUrl(fetchArgs) {\n  if (fetchArgs === void 0) {\n    fetchArgs = [];\n  }\n\n  if (typeof fetchArgs[0] === 'string') {\n    return fetchArgs[0];\n  }\n\n  if ('Request' in global && isInstanceOf(fetchArgs[0], Request)) {\n    return fetchArgs[0].url;\n  }\n\n  return String(fetchArgs[0]);\n}\n/* eslint-enable @typescript-eslint/no-unsafe-member-access */\n\n/** JSDoc */\n\n\nfunction instrumentXHR() {\n  if (!('XMLHttpRequest' in global)) {\n    return;\n  } // Poor man's implementation of ES6 `Map`, tracking and keeping in sync key and value separately.\n\n\n  var requestKeys = [];\n  var requestValues = [];\n  var xhrproto = XMLHttpRequest.prototype;\n  fill(xhrproto, 'open', function (originalOpen) {\n    return function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      } // eslint-disable-next-line @typescript-eslint/no-this-alias\n\n\n      var xhr = this;\n      var url = args[1];\n      xhr.__sentry_xhr__ = {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        method: isString(args[0]) ? args[0].toUpperCase() : args[0],\n        url: args[1]\n      }; // if Sentry key appears in URL, don't capture it as a request\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n      if (isString(url) && xhr.__sentry_xhr__.method === 'POST' && url.match(/sentry_key/)) {\n        xhr.__sentry_own_request__ = true;\n      }\n\n      var onreadystatechangeHandler = function () {\n        if (xhr.readyState === 4) {\n          try {\n            // touching statusCode in some platforms throws\n            // an exception\n            if (xhr.__sentry_xhr__) {\n              xhr.__sentry_xhr__.status_code = xhr.status;\n            }\n          } catch (e) {\n            /* do nothing */\n          }\n\n          try {\n            var requestPos = requestKeys.indexOf(xhr);\n\n            if (requestPos !== -1) {\n              // Make sure to pop both key and value to keep it in sync.\n              requestKeys.splice(requestPos);\n              var args_1 = requestValues.splice(requestPos)[0];\n\n              if (xhr.__sentry_xhr__ && args_1[0] !== undefined) {\n                xhr.__sentry_xhr__.body = args_1[0];\n              }\n            }\n          } catch (e) {\n            /* do nothing */\n          }\n\n          triggerHandlers('xhr', {\n            args: args,\n            endTimestamp: Date.now(),\n            startTimestamp: Date.now(),\n            xhr: xhr\n          });\n        }\n      };\n\n      if ('onreadystatechange' in xhr && typeof xhr.onreadystatechange === 'function') {\n        fill(xhr, 'onreadystatechange', function (original) {\n          return function () {\n            var readyStateArgs = [];\n\n            for (var _i = 0; _i < arguments.length; _i++) {\n              readyStateArgs[_i] = arguments[_i];\n            }\n\n            onreadystatechangeHandler();\n            return original.apply(xhr, readyStateArgs);\n          };\n        });\n      } else {\n        xhr.addEventListener('readystatechange', onreadystatechangeHandler);\n      }\n\n      return originalOpen.apply(xhr, args);\n    };\n  });\n  fill(xhrproto, 'send', function (originalSend) {\n    return function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      requestKeys.push(this);\n      requestValues.push(args);\n      triggerHandlers('xhr', {\n        args: args,\n        startTimestamp: Date.now(),\n        xhr: this\n      });\n      return originalSend.apply(this, args);\n    };\n  });\n}\n\nvar lastHref;\n/** JSDoc */\n\nfunction instrumentHistory() {\n  if (!supportsHistory()) {\n    return;\n  }\n\n  var oldOnPopState = global.onpopstate;\n\n  global.onpopstate = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var to = global.location.href; // keep track of the current URL state, as we always receive only the updated state\n\n    var from = lastHref;\n    lastHref = to;\n    triggerHandlers('history', {\n      from: from,\n      to: to\n    });\n\n    if (oldOnPopState) {\n      return oldOnPopState.apply(this, args);\n    }\n  };\n  /** @hidden */\n\n\n  function historyReplacementFunction(originalHistoryFunction) {\n    return function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var url = args.length > 2 ? args[2] : undefined;\n\n      if (url) {\n        // coerce to string (this is what pushState does)\n        var from = lastHref;\n        var to = String(url); // keep track of the current URL state, as we always receive only the updated state\n\n        lastHref = to;\n        triggerHandlers('history', {\n          from: from,\n          to: to\n        });\n      }\n\n      return originalHistoryFunction.apply(this, args);\n    };\n  }\n\n  fill(global.history, 'pushState', historyReplacementFunction);\n  fill(global.history, 'replaceState', historyReplacementFunction);\n}\n/** JSDoc */\n\n\nfunction instrumentDOM() {\n  if (!('document' in global)) {\n    return;\n  } // Capture breadcrumbs from any click that is unhandled / bubbled up all the way\n  // to the document. Do this before we instrument addEventListener.\n\n\n  global.document.addEventListener('click', domEventHandler('click', triggerHandlers.bind(null, 'dom')), false);\n  global.document.addEventListener('keypress', keypressEventHandler(triggerHandlers.bind(null, 'dom')), false); // After hooking into document bubbled up click and keypresses events, we also hook into user handled click & keypresses.\n\n  ['EventTarget', 'Node'].forEach(function (target) {\n    /* eslint-disable @typescript-eslint/no-unsafe-member-access */\n    var proto = global[target] && global[target].prototype; // eslint-disable-next-line no-prototype-builtins\n\n    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n      return;\n    }\n    /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n\n\n    fill(proto, 'addEventListener', function (original) {\n      return function (eventName, fn, options) {\n        if (fn && fn.handleEvent) {\n          if (eventName === 'click') {\n            fill(fn, 'handleEvent', function (innerOriginal) {\n              return function (event) {\n                domEventHandler('click', triggerHandlers.bind(null, 'dom'))(event);\n                return innerOriginal.call(this, event);\n              };\n            });\n          }\n\n          if (eventName === 'keypress') {\n            fill(fn, 'handleEvent', function (innerOriginal) {\n              return function (event) {\n                keypressEventHandler(triggerHandlers.bind(null, 'dom'))(event);\n                return innerOriginal.call(this, event);\n              };\n            });\n          }\n        } else {\n          if (eventName === 'click') {\n            domEventHandler('click', triggerHandlers.bind(null, 'dom'), true)(this);\n          }\n\n          if (eventName === 'keypress') {\n            keypressEventHandler(triggerHandlers.bind(null, 'dom'))(this);\n          }\n        }\n\n        return original.call(this, eventName, fn, options);\n      };\n    });\n    fill(proto, 'removeEventListener', function (original) {\n      return function (eventName, fn, options) {\n        try {\n          original.call(this, eventName, fn.__sentry_wrapped__, options);\n        } catch (e) {// ignore, accessing __sentry_wrapped__ will throw in some Selenium environments\n        }\n\n        return original.call(this, eventName, fn, options);\n      };\n    });\n  });\n}\n\nvar debounceDuration = 1000;\nvar debounceTimer = 0;\nvar keypressTimeout;\nvar lastCapturedEvent;\n/**\n * Wraps addEventListener to capture UI breadcrumbs\n * @param name the event name (e.g. \"click\")\n * @param handler function that will be triggered\n * @param debounce decides whether it should wait till another event loop\n * @returns wrapped breadcrumb events handler\n * @hidden\n */\n\nfunction domEventHandler(name, handler, debounce) {\n  if (debounce === void 0) {\n    debounce = false;\n  }\n\n  return function (event) {\n    // reset keypress timeout; e.g. triggering a 'click' after\n    // a 'keypress' will reset the keypress debounce so that a new\n    // set of keypresses can be recorded\n    keypressTimeout = undefined; // It's possible this handler might trigger multiple times for the same\n    // event (e.g. event propagation through node ancestors). Ignore if we've\n    // already captured the event.\n\n    if (!event || lastCapturedEvent === event) {\n      return;\n    }\n\n    lastCapturedEvent = event;\n\n    if (debounceTimer) {\n      clearTimeout(debounceTimer);\n    }\n\n    if (debounce) {\n      debounceTimer = setTimeout(function () {\n        handler({\n          event: event,\n          name: name\n        });\n      });\n    } else {\n      handler({\n        event: event,\n        name: name\n      });\n    }\n  };\n}\n/**\n * Wraps addEventListener to capture keypress UI events\n * @param handler function that will be triggered\n * @returns wrapped keypress events handler\n * @hidden\n */\n\n\nfunction keypressEventHandler(handler) {\n  // TODO: if somehow user switches keypress target before\n  //       debounce timeout is triggered, we will only capture\n  //       a single breadcrumb from the FIRST target (acceptable?)\n  return function (event) {\n    var target;\n\n    try {\n      target = event.target;\n    } catch (e) {\n      // just accessing event properties can throw an exception in some rare circumstances\n      // see: https://github.com/getsentry/raven-js/issues/838\n      return;\n    }\n\n    var tagName = target && target.tagName; // only consider keypress events on actual input elements\n    // this will disregard keypresses targeting body (e.g. tabbing\n    // through elements, hotkeys, etc)\n\n    if (!tagName || tagName !== 'INPUT' && tagName !== 'TEXTAREA' && !target.isContentEditable) {\n      return;\n    } // record first keypress in a series, but ignore subsequent\n    // keypresses until debounce clears\n\n\n    if (!keypressTimeout) {\n      domEventHandler('input', handler)(event);\n    }\n\n    clearTimeout(keypressTimeout);\n    keypressTimeout = setTimeout(function () {\n      keypressTimeout = undefined;\n    }, debounceDuration);\n  };\n}\n\nvar _oldOnErrorHandler = null;\n/** JSDoc */\n\nfunction instrumentError() {\n  _oldOnErrorHandler = global.onerror;\n\n  global.onerror = function (msg, url, line, column, error) {\n    triggerHandlers('error', {\n      column: column,\n      error: error,\n      line: line,\n      msg: msg,\n      url: url\n    });\n\n    if (_oldOnErrorHandler) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnErrorHandler.apply(this, arguments);\n    }\n\n    return false;\n  };\n}\n\nvar _oldOnUnhandledRejectionHandler = null;\n/** JSDoc */\n\nfunction instrumentUnhandledRejection() {\n  _oldOnUnhandledRejectionHandler = global.onunhandledrejection;\n\n  global.onunhandledrejection = function (e) {\n    triggerHandlers('unhandledrejection', e);\n\n    if (_oldOnUnhandledRejectionHandler) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnUnhandledRejectionHandler.apply(this, arguments);\n    }\n\n    return true;\n  };\n}","map":{"version":3,"mappings":"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","names":["isInstanceOf","isString","logger","getGlobalObject","fill","getFunctionName","supportsHistory","supportsNativeFetch","global","handlers","instrumented","instrument","type","instrumentConsole","instrumentDOM","instrumentXHR","instrumentFetch","instrumentHistory","instrumentError","instrumentUnhandledRejection","warn","addInstrumentationHandler","handler","callback","push","triggerHandlers","data","_c","e","error","forEach","level","console","originalConsoleLevel","args","Function","prototype","apply","call","originalFetch","handlerData","fetchData","method","getFetchMethod","url","getFetchUrl","startTimestamp","Date","now","__assign","then","response","endTimestamp","fetchArgs","Request","String","toUpperCase","requestKeys","requestValues","xhrproto","XMLHttpRequest","originalOpen","xhr","__sentry_xhr__","match","__sentry_own_request__","onreadystatechangeHandler","readyState","status_code","status","requestPos","indexOf","splice","args_1","undefined","body","onreadystatechange","original","readyStateArgs","addEventListener","originalSend","lastHref","oldOnPopState","onpopstate","to","location","href","from","historyReplacementFunction","originalHistoryFunction","length","history","document","domEventHandler","bind","keypressEventHandler","target","proto","hasOwnProperty","eventName","fn","options","handleEvent","innerOriginal","event","__sentry_wrapped__","debounceDuration","debounceTimer","keypressTimeout","lastCapturedEvent","name","debounce","clearTimeout","setTimeout","tagName","isContentEditable","_oldOnErrorHandler","onerror","msg","line","column","arguments","_oldOnUnhandledRejectionHandler","onunhandledrejection"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/@sentry/utils/src/instrument.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/ban-types */\nimport { WrappedFunction } from '@sentry/types';\n\nimport { isInstanceOf, isString } from './is';\nimport { logger } from './logger';\nimport { getGlobalObject } from './misc';\nimport { fill } from './object';\nimport { getFunctionName } from './stacktrace';\nimport { supportsHistory, supportsNativeFetch } from './supports';\n\nconst global = getGlobalObject<Window>();\n\n/** Object describing handler that will be triggered for a given `type` of instrumentation */\ninterface InstrumentHandler {\n  type: InstrumentHandlerType;\n  callback: InstrumentHandlerCallback;\n}\ntype InstrumentHandlerType =\n  | 'console'\n  | 'dom'\n  | 'fetch'\n  | 'history'\n  | 'sentry'\n  | 'xhr'\n  | 'error'\n  | 'unhandledrejection';\ntype InstrumentHandlerCallback = (data: any) => void;\n\n/**\n * Instrument native APIs to call handlers that can be used to create breadcrumbs, APM spans etc.\n *  - Console API\n *  - Fetch API\n *  - XHR API\n *  - History API\n *  - DOM API (click/typing)\n *  - Error API\n *  - UnhandledRejection API\n */\n\nconst handlers: { [key in InstrumentHandlerType]?: InstrumentHandlerCallback[] } = {};\nconst instrumented: { [key in InstrumentHandlerType]?: boolean } = {};\n\n/** Instruments given API */\nfunction instrument(type: InstrumentHandlerType): void {\n  if (instrumented[type]) {\n    return;\n  }\n\n  instrumented[type] = true;\n\n  switch (type) {\n    case 'console':\n      instrumentConsole();\n      break;\n    case 'dom':\n      instrumentDOM();\n      break;\n    case 'xhr':\n      instrumentXHR();\n      break;\n    case 'fetch':\n      instrumentFetch();\n      break;\n    case 'history':\n      instrumentHistory();\n      break;\n    case 'error':\n      instrumentError();\n      break;\n    case 'unhandledrejection':\n      instrumentUnhandledRejection();\n      break;\n    default:\n      logger.warn('unknown instrumentation type:', type);\n  }\n}\n\n/**\n * Add handler that will be called when given type of instrumentation triggers.\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nexport function addInstrumentationHandler(handler: InstrumentHandler): void {\n  if (!handler || typeof handler.type !== 'string' || typeof handler.callback !== 'function') {\n    return;\n  }\n  handlers[handler.type] = handlers[handler.type] || [];\n  (handlers[handler.type] as InstrumentHandlerCallback[]).push(handler.callback);\n  instrument(handler.type);\n}\n\n/** JSDoc */\nfunction triggerHandlers(type: InstrumentHandlerType, data: any): void {\n  if (!type || !handlers[type]) {\n    return;\n  }\n\n  for (const handler of handlers[type] || []) {\n    try {\n      handler(data);\n    } catch (e) {\n      logger.error(\n        `Error while triggering instrumentation handler.\\nType: ${type}\\nName: ${getFunctionName(\n          handler,\n        )}\\nError: ${e}`,\n      );\n    }\n  }\n}\n\n/** JSDoc */\nfunction instrumentConsole(): void {\n  if (!('console' in global)) {\n    return;\n  }\n\n  ['debug', 'info', 'warn', 'error', 'log', 'assert'].forEach(function(level: string): void {\n    if (!(level in global.console)) {\n      return;\n    }\n\n    fill(global.console, level, function(originalConsoleLevel: () => any): Function {\n      return function(...args: any[]): void {\n        triggerHandlers('console', { args, level });\n\n        // this fails for some browsers. :(\n        if (originalConsoleLevel) {\n          Function.prototype.apply.call(originalConsoleLevel, global.console, args);\n        }\n      };\n    });\n  });\n}\n\n/** JSDoc */\nfunction instrumentFetch(): void {\n  if (!supportsNativeFetch()) {\n    return;\n  }\n\n  fill(global, 'fetch', function(originalFetch: () => void): () => void {\n    return function(...args: any[]): void {\n      const handlerData = {\n        args,\n        fetchData: {\n          method: getFetchMethod(args),\n          url: getFetchUrl(args),\n        },\n        startTimestamp: Date.now(),\n      };\n\n      triggerHandlers('fetch', {\n        ...handlerData,\n      });\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      return originalFetch.apply(global, args).then(\n        (response: Response) => {\n          triggerHandlers('fetch', {\n            ...handlerData,\n            endTimestamp: Date.now(),\n            response,\n          });\n          return response;\n        },\n        (error: Error) => {\n          triggerHandlers('fetch', {\n            ...handlerData,\n            endTimestamp: Date.now(),\n            error,\n          });\n          // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n          //       it means the sentry.javascript SDK caught an error invoking your application code.\n          //       This is expected behavior and NOT indicative of a bug with sentry.javascript.\n          throw error;\n        },\n      );\n    };\n  });\n}\n\ntype XHRSendInput = null | Blob | BufferSource | FormData | URLSearchParams | string;\n\n/** JSDoc */\ninterface SentryWrappedXMLHttpRequest extends XMLHttpRequest {\n  [key: string]: any;\n  __sentry_xhr__?: {\n    method?: string;\n    url?: string;\n    status_code?: number;\n    body?: XHRSendInput;\n  };\n}\n\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/** Extract `method` from fetch call arguments */\nfunction getFetchMethod(fetchArgs: any[] = []): string {\n  if ('Request' in global && isInstanceOf(fetchArgs[0], Request) && fetchArgs[0].method) {\n    return String(fetchArgs[0].method).toUpperCase();\n  }\n  if (fetchArgs[1] && fetchArgs[1].method) {\n    return String(fetchArgs[1].method).toUpperCase();\n  }\n  return 'GET';\n}\n\n/** Extract `url` from fetch call arguments */\nfunction getFetchUrl(fetchArgs: any[] = []): string {\n  if (typeof fetchArgs[0] === 'string') {\n    return fetchArgs[0];\n  }\n  if ('Request' in global && isInstanceOf(fetchArgs[0], Request)) {\n    return fetchArgs[0].url;\n  }\n  return String(fetchArgs[0]);\n}\n/* eslint-enable @typescript-eslint/no-unsafe-member-access */\n\n/** JSDoc */\nfunction instrumentXHR(): void {\n  if (!('XMLHttpRequest' in global)) {\n    return;\n  }\n\n  // Poor man's implementation of ES6 `Map`, tracking and keeping in sync key and value separately.\n  const requestKeys: XMLHttpRequest[] = [];\n  const requestValues: Array<any>[] = [];\n  const xhrproto = XMLHttpRequest.prototype;\n\n  fill(xhrproto, 'open', function(originalOpen: () => void): () => void {\n    return function(this: SentryWrappedXMLHttpRequest, ...args: any[]): void {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const xhr = this;\n      const url = args[1];\n      xhr.__sentry_xhr__ = {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        method: isString(args[0]) ? args[0].toUpperCase() : args[0],\n        url: args[1],\n      };\n\n      // if Sentry key appears in URL, don't capture it as a request\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      if (isString(url) && xhr.__sentry_xhr__.method === 'POST' && url.match(/sentry_key/)) {\n        xhr.__sentry_own_request__ = true;\n      }\n\n      const onreadystatechangeHandler = function(): void {\n        if (xhr.readyState === 4) {\n          try {\n            // touching statusCode in some platforms throws\n            // an exception\n            if (xhr.__sentry_xhr__) {\n              xhr.__sentry_xhr__.status_code = xhr.status;\n            }\n          } catch (e) {\n            /* do nothing */\n          }\n\n          try {\n            const requestPos = requestKeys.indexOf(xhr);\n            if (requestPos !== -1) {\n              // Make sure to pop both key and value to keep it in sync.\n              requestKeys.splice(requestPos);\n              const args = requestValues.splice(requestPos)[0];\n              if (xhr.__sentry_xhr__ && args[0] !== undefined) {\n                xhr.__sentry_xhr__.body = args[0] as XHRSendInput;\n              }\n            }\n          } catch (e) {\n            /* do nothing */\n          }\n\n          triggerHandlers('xhr', {\n            args,\n            endTimestamp: Date.now(),\n            startTimestamp: Date.now(),\n            xhr,\n          });\n        }\n      };\n\n      if ('onreadystatechange' in xhr && typeof xhr.onreadystatechange === 'function') {\n        fill(xhr, 'onreadystatechange', function(original: WrappedFunction): Function {\n          return function(...readyStateArgs: any[]): void {\n            onreadystatechangeHandler();\n            return original.apply(xhr, readyStateArgs);\n          };\n        });\n      } else {\n        xhr.addEventListener('readystatechange', onreadystatechangeHandler);\n      }\n\n      return originalOpen.apply(xhr, args);\n    };\n  });\n\n  fill(xhrproto, 'send', function(originalSend: () => void): () => void {\n    return function(this: SentryWrappedXMLHttpRequest, ...args: any[]): void {\n      requestKeys.push(this);\n      requestValues.push(args);\n\n      triggerHandlers('xhr', {\n        args,\n        startTimestamp: Date.now(),\n        xhr: this,\n      });\n\n      return originalSend.apply(this, args);\n    };\n  });\n}\n\nlet lastHref: string;\n\n/** JSDoc */\nfunction instrumentHistory(): void {\n  if (!supportsHistory()) {\n    return;\n  }\n\n  const oldOnPopState = global.onpopstate;\n  global.onpopstate = function(this: WindowEventHandlers, ...args: any[]): any {\n    const to = global.location.href;\n    // keep track of the current URL state, as we always receive only the updated state\n    const from = lastHref;\n    lastHref = to;\n    triggerHandlers('history', {\n      from,\n      to,\n    });\n    if (oldOnPopState) {\n      return oldOnPopState.apply(this, args);\n    }\n  };\n\n  /** @hidden */\n  function historyReplacementFunction(originalHistoryFunction: () => void): () => void {\n    return function(this: History, ...args: any[]): void {\n      const url = args.length > 2 ? args[2] : undefined;\n      if (url) {\n        // coerce to string (this is what pushState does)\n        const from = lastHref;\n        const to = String(url);\n        // keep track of the current URL state, as we always receive only the updated state\n        lastHref = to;\n        triggerHandlers('history', {\n          from,\n          to,\n        });\n      }\n      return originalHistoryFunction.apply(this, args);\n    };\n  }\n\n  fill(global.history, 'pushState', historyReplacementFunction);\n  fill(global.history, 'replaceState', historyReplacementFunction);\n}\n\n/** JSDoc */\nfunction instrumentDOM(): void {\n  if (!('document' in global)) {\n    return;\n  }\n\n  // Capture breadcrumbs from any click that is unhandled / bubbled up all the way\n  // to the document. Do this before we instrument addEventListener.\n  global.document.addEventListener('click', domEventHandler('click', triggerHandlers.bind(null, 'dom')), false);\n  global.document.addEventListener('keypress', keypressEventHandler(triggerHandlers.bind(null, 'dom')), false);\n\n  // After hooking into document bubbled up click and keypresses events, we also hook into user handled click & keypresses.\n  ['EventTarget', 'Node'].forEach((target: string) => {\n    /* eslint-disable @typescript-eslint/no-unsafe-member-access */\n    const proto = (global as any)[target] && (global as any)[target].prototype;\n\n    // eslint-disable-next-line no-prototype-builtins\n    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n      return;\n    }\n    /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n\n    fill(proto, 'addEventListener', function(\n      original: () => void,\n    ): (\n      eventName: string,\n      fn: EventListenerOrEventListenerObject,\n      options?: boolean | AddEventListenerOptions,\n    ) => void {\n      return function(\n        this: any,\n        eventName: string,\n        fn: EventListenerOrEventListenerObject,\n        options?: boolean | AddEventListenerOptions,\n      ): (eventName: string, fn: EventListenerOrEventListenerObject, capture?: boolean, secure?: boolean) => void {\n        if (fn && (fn as EventListenerObject).handleEvent) {\n          if (eventName === 'click') {\n            fill(fn, 'handleEvent', function(innerOriginal: () => void): (caughtEvent: Event) => void {\n              return function(this: any, event: Event): (event: Event) => void {\n                domEventHandler('click', triggerHandlers.bind(null, 'dom'))(event);\n                return innerOriginal.call(this, event);\n              };\n            });\n          }\n          if (eventName === 'keypress') {\n            fill(fn, 'handleEvent', function(innerOriginal: () => void): (caughtEvent: Event) => void {\n              return function(this: any, event: Event): (event: Event) => void {\n                keypressEventHandler(triggerHandlers.bind(null, 'dom'))(event);\n                return innerOriginal.call(this, event);\n              };\n            });\n          }\n        } else {\n          if (eventName === 'click') {\n            domEventHandler('click', triggerHandlers.bind(null, 'dom'), true)(this);\n          }\n          if (eventName === 'keypress') {\n            keypressEventHandler(triggerHandlers.bind(null, 'dom'))(this);\n          }\n        }\n\n        return original.call(this, eventName, fn, options);\n      };\n    });\n\n    fill(proto, 'removeEventListener', function(\n      original: () => void,\n    ): (\n      this: any,\n      eventName: string,\n      fn: EventListenerOrEventListenerObject,\n      options?: boolean | EventListenerOptions,\n    ) => () => void {\n      return function(\n        this: any,\n        eventName: string,\n        fn: EventListenerOrEventListenerObject,\n        options?: boolean | EventListenerOptions,\n      ): () => void {\n        try {\n          original.call(this, eventName, ((fn as unknown) as WrappedFunction).__sentry_wrapped__, options);\n        } catch (e) {\n          // ignore, accessing __sentry_wrapped__ will throw in some Selenium environments\n        }\n        return original.call(this, eventName, fn, options);\n      };\n    });\n  });\n}\n\nconst debounceDuration: number = 1000;\nlet debounceTimer: number = 0;\nlet keypressTimeout: number | undefined;\nlet lastCapturedEvent: Event | undefined;\n\n/**\n * Wraps addEventListener to capture UI breadcrumbs\n * @param name the event name (e.g. \"click\")\n * @param handler function that will be triggered\n * @param debounce decides whether it should wait till another event loop\n * @returns wrapped breadcrumb events handler\n * @hidden\n */\nfunction domEventHandler(name: string, handler: Function, debounce: boolean = false): (event: Event) => void {\n  return (event: Event): void => {\n    // reset keypress timeout; e.g. triggering a 'click' after\n    // a 'keypress' will reset the keypress debounce so that a new\n    // set of keypresses can be recorded\n    keypressTimeout = undefined;\n    // It's possible this handler might trigger multiple times for the same\n    // event (e.g. event propagation through node ancestors). Ignore if we've\n    // already captured the event.\n    if (!event || lastCapturedEvent === event) {\n      return;\n    }\n\n    lastCapturedEvent = event;\n\n    if (debounceTimer) {\n      clearTimeout(debounceTimer);\n    }\n\n    if (debounce) {\n      debounceTimer = setTimeout(() => {\n        handler({ event, name });\n      });\n    } else {\n      handler({ event, name });\n    }\n  };\n}\n\n/**\n * Wraps addEventListener to capture keypress UI events\n * @param handler function that will be triggered\n * @returns wrapped keypress events handler\n * @hidden\n */\nfunction keypressEventHandler(handler: Function): (event: Event) => void {\n  // TODO: if somehow user switches keypress target before\n  //       debounce timeout is triggered, we will only capture\n  //       a single breadcrumb from the FIRST target (acceptable?)\n  return (event: Event): void => {\n    let target;\n\n    try {\n      target = event.target;\n    } catch (e) {\n      // just accessing event properties can throw an exception in some rare circumstances\n      // see: https://github.com/getsentry/raven-js/issues/838\n      return;\n    }\n\n    const tagName = target && (target as HTMLElement).tagName;\n\n    // only consider keypress events on actual input elements\n    // this will disregard keypresses targeting body (e.g. tabbing\n    // through elements, hotkeys, etc)\n    if (!tagName || (tagName !== 'INPUT' && tagName !== 'TEXTAREA' && !(target as HTMLElement).isContentEditable)) {\n      return;\n    }\n\n    // record first keypress in a series, but ignore subsequent\n    // keypresses until debounce clears\n    if (!keypressTimeout) {\n      domEventHandler('input', handler)(event);\n    }\n    clearTimeout(keypressTimeout);\n\n    keypressTimeout = (setTimeout(() => {\n      keypressTimeout = undefined;\n    }, debounceDuration) as any) as number;\n  };\n}\n\nlet _oldOnErrorHandler: OnErrorEventHandler = null;\n/** JSDoc */\nfunction instrumentError(): void {\n  _oldOnErrorHandler = global.onerror;\n\n  global.onerror = function(msg: any, url: any, line: any, column: any, error: any): boolean {\n    triggerHandlers('error', {\n      column,\n      error,\n      line,\n      msg,\n      url,\n    });\n\n    if (_oldOnErrorHandler) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnErrorHandler.apply(this, arguments);\n    }\n\n    return false;\n  };\n}\n\nlet _oldOnUnhandledRejectionHandler: ((e: any) => void) | null = null;\n/** JSDoc */\nfunction instrumentUnhandledRejection(): void {\n  _oldOnUnhandledRejectionHandler = global.onunhandledrejection;\n\n  global.onunhandledrejection = function(e: any): boolean {\n    triggerHandlers('unhandledrejection', e);\n\n    if (_oldOnUnhandledRejectionHandler) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnUnhandledRejectionHandler.apply(this, arguments);\n    }\n\n    return true;\n  };\n}\n"]},"metadata":{},"sourceType":"module"}