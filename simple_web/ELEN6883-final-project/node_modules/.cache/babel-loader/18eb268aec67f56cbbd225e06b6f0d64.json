{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DependencyGraph = void 0;\n\nclass DependencyGraph {\n  constructor() {\n    this._resolvedFiles = new Map();\n    this._dependenciesPerFile = new Map();\n    this._visitedFiles = new Set();\n  }\n\n  static async createFromResolvedFiles(resolver, resolvedFiles) {\n    const graph = new DependencyGraph();\n\n    for (const resolvedFile of resolvedFiles) {\n      await graph._addDependenciesFrom(resolver, resolvedFile);\n    }\n\n    return graph;\n  }\n\n  getResolvedFiles() {\n    return Array.from(this._resolvedFiles.values());\n  }\n\n  has(file) {\n    return this._resolvedFiles.has(file.sourceName);\n  }\n\n  isEmpty() {\n    return this._resolvedFiles.size === 0;\n  }\n\n  entries() {\n    return Array.from(this._dependenciesPerFile.entries()).map(_ref => {\n      let [key, value] = _ref;\n      return [this._resolvedFiles.get(key), value];\n    });\n  }\n\n  getDependencies(file) {\n    var _a;\n\n    const dependencies = (_a = this._dependenciesPerFile.get(file.sourceName)) !== null && _a !== void 0 ? _a : new Set();\n    return [...dependencies];\n  }\n\n  getTransitiveDependencies(file) {\n    const visited = new Set();\n\n    const transitiveDependencies = this._getTransitiveDependencies(file, visited, []);\n\n    return [...transitiveDependencies];\n  }\n\n  getConnectedComponents() {\n    var _a, _b;\n\n    const undirectedGraph = {};\n\n    for (const [sourceName, dependencies] of this._dependenciesPerFile.entries()) {\n      undirectedGraph[sourceName] = (_a = undirectedGraph[sourceName]) !== null && _a !== void 0 ? _a : new Set();\n\n      for (const dependency of dependencies) {\n        undirectedGraph[dependency.sourceName] = (_b = undirectedGraph[dependency.sourceName]) !== null && _b !== void 0 ? _b : new Set();\n        undirectedGraph[sourceName].add(dependency.sourceName);\n        undirectedGraph[dependency.sourceName].add(sourceName);\n      }\n    }\n\n    const components = [];\n    const visited = new Set();\n\n    for (const node of Object.keys(undirectedGraph)) {\n      if (visited.has(node)) {\n        continue;\n      }\n\n      visited.add(node);\n      const component = new Set([node]);\n      const stack = [...undirectedGraph[node]];\n\n      while (stack.length > 0) {\n        const newNode = stack.pop();\n\n        if (visited.has(newNode)) {\n          continue;\n        }\n\n        visited.add(newNode);\n        component.add(newNode);\n        [...undirectedGraph[newNode]].forEach(adjacent => {\n          if (!visited.has(adjacent)) {\n            stack.push(adjacent);\n          }\n        });\n      }\n\n      components.push(component);\n    }\n\n    const connectedComponents = [];\n\n    for (const component of components) {\n      const dependencyGraph = new DependencyGraph();\n\n      for (const sourceName of component) {\n        const file = this._resolvedFiles.get(sourceName);\n\n        const dependencies = this._dependenciesPerFile.get(sourceName);\n\n        dependencyGraph._resolvedFiles.set(sourceName, file);\n\n        dependencyGraph._dependenciesPerFile.set(sourceName, dependencies);\n      }\n\n      connectedComponents.push(dependencyGraph);\n    }\n\n    return connectedComponents;\n  }\n\n  _getTransitiveDependencies(file, visited, path) {\n    if (visited.has(file)) {\n      return new Set();\n    }\n\n    visited.add(file);\n    const directDependencies = this.getDependencies(file).map(dependency => ({\n      dependency,\n      path\n    }));\n    const transitiveDependencies = new Set(directDependencies);\n\n    for (const {\n      dependency\n    } of transitiveDependencies) {\n      this._getTransitiveDependencies(dependency, visited, path.concat(dependency)).forEach(x => transitiveDependencies.add(x));\n    }\n\n    return transitiveDependencies;\n  }\n\n  async _addDependenciesFrom(resolver, file) {\n    if (this._visitedFiles.has(file.absolutePath)) {\n      return;\n    }\n\n    this._visitedFiles.add(file.absolutePath);\n\n    const dependencies = new Set();\n\n    this._resolvedFiles.set(file.sourceName, file);\n\n    this._dependenciesPerFile.set(file.sourceName, dependencies);\n\n    for (const imp of file.content.imports) {\n      const dependency = await resolver.resolveImport(file, imp);\n      dependencies.add(dependency);\n      await this._addDependenciesFrom(resolver, dependency);\n    }\n  }\n\n}\n\nexports.DependencyGraph = DependencyGraph;","map":{"version":3,"mappings":"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","names":["DependencyGraph","constructor","Map","Set","createFromResolvedFiles","resolver","resolvedFiles","graph","resolvedFile","_addDependenciesFrom","getResolvedFiles","Array","from","_resolvedFiles","values","has","file","sourceName","isEmpty","size","entries","_dependenciesPerFile","map","key","value","get","getDependencies","dependencies","_a","getTransitiveDependencies","visited","transitiveDependencies","_getTransitiveDependencies","getConnectedComponents","undirectedGraph","dependency","_b","add","components","node","Object","keys","component","stack","length","newNode","pop","forEach","adjacent","push","connectedComponents","dependencyGraph","set","path","directDependencies","concat","x","_visitedFiles","absolutePath","imp","content","imports","resolveImport","exports"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/internal/solidity/dependencyGraph.ts"],"sourcesContent":["import * as taskTypes from \"../../types/builtin-tasks\";\n\nimport { ResolvedFile, Resolver } from \"./resolver\";\n\nexport class DependencyGraph implements taskTypes.DependencyGraph {\n  public static async createFromResolvedFiles(\n    resolver: Resolver,\n    resolvedFiles: ResolvedFile[]\n  ): Promise<DependencyGraph> {\n    const graph = new DependencyGraph();\n\n    for (const resolvedFile of resolvedFiles) {\n      await graph._addDependenciesFrom(resolver, resolvedFile);\n    }\n\n    return graph;\n  }\n\n  private _resolvedFiles = new Map<string, ResolvedFile>();\n  private _dependenciesPerFile = new Map<string, Set<ResolvedFile>>();\n\n  private readonly _visitedFiles = new Set<string>();\n\n  private constructor() {}\n\n  public getResolvedFiles(): ResolvedFile[] {\n    return Array.from(this._resolvedFiles.values());\n  }\n\n  public has(file: ResolvedFile): boolean {\n    return this._resolvedFiles.has(file.sourceName);\n  }\n\n  public isEmpty(): boolean {\n    return this._resolvedFiles.size === 0;\n  }\n\n  public entries(): Array<[ResolvedFile, Set<ResolvedFile>]> {\n    return Array.from(this._dependenciesPerFile.entries()).map(\n      ([key, value]) => [this._resolvedFiles.get(key)!, value]\n    );\n  }\n\n  public getDependencies(file: ResolvedFile): ResolvedFile[] {\n    const dependencies =\n      this._dependenciesPerFile.get(file.sourceName) ?? new Set();\n\n    return [...dependencies];\n  }\n\n  public getTransitiveDependencies(\n    file: ResolvedFile\n  ): taskTypes.TransitiveDependency[] {\n    const visited = new Set<ResolvedFile>();\n\n    const transitiveDependencies = this._getTransitiveDependencies(\n      file,\n      visited,\n      []\n    );\n\n    return [...transitiveDependencies];\n  }\n\n  public getConnectedComponents(): DependencyGraph[] {\n    const undirectedGraph: Record<string, Set<string>> = {};\n\n    for (const [\n      sourceName,\n      dependencies,\n    ] of this._dependenciesPerFile.entries()) {\n      undirectedGraph[sourceName] = undirectedGraph[sourceName] ?? new Set();\n      for (const dependency of dependencies) {\n        undirectedGraph[dependency.sourceName] =\n          undirectedGraph[dependency.sourceName] ?? new Set();\n        undirectedGraph[sourceName].add(dependency.sourceName);\n        undirectedGraph[dependency.sourceName].add(sourceName);\n      }\n    }\n\n    const components: Array<Set<string>> = [];\n    const visited = new Set<string>();\n\n    for (const node of Object.keys(undirectedGraph)) {\n      if (visited.has(node)) {\n        continue;\n      }\n      visited.add(node);\n      const component = new Set([node]);\n      const stack = [...undirectedGraph[node]];\n      while (stack.length > 0) {\n        const newNode = stack.pop()!;\n        if (visited.has(newNode)) {\n          continue;\n        }\n        visited.add(newNode);\n        component.add(newNode);\n        [...undirectedGraph[newNode]].forEach((adjacent) => {\n          if (!visited.has(adjacent)) {\n            stack.push(adjacent);\n          }\n        });\n      }\n\n      components.push(component);\n    }\n\n    const connectedComponents: DependencyGraph[] = [];\n    for (const component of components) {\n      const dependencyGraph = new DependencyGraph();\n\n      for (const sourceName of component) {\n        const file = this._resolvedFiles.get(sourceName)!;\n        const dependencies = this._dependenciesPerFile.get(sourceName)!;\n\n        dependencyGraph._resolvedFiles.set(sourceName, file);\n        dependencyGraph._dependenciesPerFile.set(sourceName, dependencies);\n      }\n      connectedComponents.push(dependencyGraph);\n    }\n\n    return connectedComponents;\n  }\n\n  private _getTransitiveDependencies(\n    file: ResolvedFile,\n    visited: Set<ResolvedFile>,\n    path: ResolvedFile[]\n  ): Set<taskTypes.TransitiveDependency> {\n    if (visited.has(file)) {\n      return new Set();\n    }\n    visited.add(file);\n\n    const directDependencies: taskTypes.TransitiveDependency[] =\n      this.getDependencies(file).map((dependency) => ({\n        dependency,\n        path,\n      }));\n\n    const transitiveDependencies = new Set<taskTypes.TransitiveDependency>(\n      directDependencies\n    );\n\n    for (const { dependency } of transitiveDependencies) {\n      this._getTransitiveDependencies(\n        dependency,\n        visited,\n        path.concat(dependency)\n      ).forEach((x) => transitiveDependencies.add(x));\n    }\n\n    return transitiveDependencies;\n  }\n\n  private async _addDependenciesFrom(\n    resolver: Resolver,\n    file: ResolvedFile\n  ): Promise<void> {\n    if (this._visitedFiles.has(file.absolutePath)) {\n      return;\n    }\n\n    this._visitedFiles.add(file.absolutePath);\n\n    const dependencies = new Set<ResolvedFile>();\n    this._resolvedFiles.set(file.sourceName, file);\n    this._dependenciesPerFile.set(file.sourceName, dependencies);\n\n    for (const imp of file.content.imports) {\n      const dependency = await resolver.resolveImport(file, imp);\n      dependencies.add(dependency);\n\n      await this._addDependenciesFrom(resolver, dependency);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}