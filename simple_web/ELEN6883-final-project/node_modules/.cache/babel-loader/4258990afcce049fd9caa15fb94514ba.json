{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.writeTelemetryConsent = exports.hasConsentedTelemetry = exports.getCompilersDir = exports.writeAnalyticsId = exports.readSecondLegacyAnalyticsId = exports.readFirstLegacyAnalyticsId = exports.readAnalyticsId = exports.getCacheDir = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\n\nconst os_1 = __importDefault(require(\"os\"));\n\nconst path_1 = __importDefault(require(\"path\"));\n\nconst log = (0, debug_1.default)(\"hardhat:core:global-dir\");\n\nasync function generatePaths() {\n  let packageName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"hardhat\";\n  const {\n    default: envPaths\n  } = await Promise.resolve().then(() => __importStar(require(\"env-paths\")));\n  return envPaths(packageName);\n}\n\nfunction generatePathsSync() {\n  let packageName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"hardhat\";\n\n  const envPaths = require(\"env-paths\");\n\n  return envPaths(packageName);\n}\n\nfunction getConfigDirSync() {\n  const {\n    config\n  } = generatePathsSync();\n  fs_extra_1.default.ensureDirSync(config);\n  return config;\n}\n\nasync function getDataDir(packageName) {\n  const {\n    data\n  } = await generatePaths(packageName);\n  await fs_extra_1.default.ensureDir(data);\n  return data;\n}\n\nasync function getCacheDir() {\n  const {\n    cache\n  } = await generatePaths();\n  await fs_extra_1.default.ensureDir(cache);\n  return cache;\n}\n\nexports.getCacheDir = getCacheDir;\n\nasync function readAnalyticsId() {\n  const globalDataDir = await getDataDir();\n  const idFile = path_1.default.join(globalDataDir, \"analytics.json\");\n  return readId(idFile);\n}\n\nexports.readAnalyticsId = readAnalyticsId;\n/**\n * This is the first way that the analytics id was saved.\n */\n\nfunction readFirstLegacyAnalyticsId() {\n  const oldIdFile = path_1.default.join(os_1.default.homedir(), \".buidler\", \"config.json\");\n  return readId(oldIdFile);\n}\n\nexports.readFirstLegacyAnalyticsId = readFirstLegacyAnalyticsId;\n/**\n * This is the same way the analytics id is saved now, but using buidler as the\n * name of the project for env-paths\n */\n\nasync function readSecondLegacyAnalyticsId() {\n  const globalDataDir = await getDataDir(\"buidler\");\n  const idFile = path_1.default.join(globalDataDir, \"analytics.json\");\n  return readId(idFile);\n}\n\nexports.readSecondLegacyAnalyticsId = readSecondLegacyAnalyticsId;\n\nasync function readId(idFile) {\n  log(`Looking up Client Id at ${idFile}`);\n  let clientId;\n\n  try {\n    const data = await fs_extra_1.default.readJSON(idFile, {\n      encoding: \"utf8\"\n    });\n    clientId = data.analytics.clientId;\n  } catch (error) {\n    return undefined;\n  }\n\n  log(`Client Id found: ${clientId}`);\n  return clientId;\n}\n\nasync function writeAnalyticsId(clientId) {\n  const globalDataDir = await getDataDir();\n  const idFile = path_1.default.join(globalDataDir, \"analytics.json\");\n  await fs_extra_1.default.writeJSON(idFile, {\n    analytics: {\n      clientId\n    }\n  }, {\n    encoding: \"utf-8\",\n    spaces: 2\n  });\n  log(`Stored clientId ${clientId}`);\n}\n\nexports.writeAnalyticsId = writeAnalyticsId;\n\nasync function getCompilersDir() {\n  const cache = await getCacheDir();\n  const compilersCache = path_1.default.join(cache, \"compilers\");\n  await fs_extra_1.default.ensureDir(compilersCache);\n  return compilersCache;\n}\n\nexports.getCompilersDir = getCompilersDir;\n/**\n * Checks if the user has given (or refused) consent for telemetry.\n *\n * Returns undefined if it can't be determined.\n */\n\nfunction hasConsentedTelemetry() {\n  const configDir = getConfigDirSync();\n  const telemetryConsentPath = path_1.default.join(configDir, \"telemetry-consent.json\");\n  const fileExists = fs_extra_1.default.pathExistsSync(telemetryConsentPath);\n\n  if (!fileExists) {\n    return undefined;\n  }\n\n  const {\n    consent\n  } = fs_extra_1.default.readJSONSync(telemetryConsentPath);\n  return consent;\n}\n\nexports.hasConsentedTelemetry = hasConsentedTelemetry;\n\nfunction writeTelemetryConsent(consent) {\n  const configDir = getConfigDirSync();\n  const telemetryConsentPath = path_1.default.join(configDir, \"telemetry-consent.json\");\n  fs_extra_1.default.writeJSONSync(telemetryConsentPath, {\n    consent\n  }, {\n    spaces: 2\n  });\n}\n\nexports.writeTelemetryConsent = writeTelemetryConsent;","map":{"version":3,"mappings":"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","names":["log","generatePaths","packageName","default","envPaths","generatePathsSync","require","getConfigDirSync","config","fs_extra_1","ensureDirSync","getDataDir","data","ensureDir","getCacheDir","cache","exports","readAnalyticsId","globalDataDir","idFile","path_1","join","readId","readFirstLegacyAnalyticsId","oldIdFile","os_1","homedir","readSecondLegacyAnalyticsId","clientId","readJSON","encoding","analytics","error","undefined","writeAnalyticsId","writeJSON","spaces","getCompilersDir","compilersCache","hasConsentedTelemetry","configDir","telemetryConsentPath","fileExists","pathExistsSync","consent","readJSONSync","writeTelemetryConsent","writeJSONSync"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/internal/util/global-dir.ts"],"sourcesContent":["import debug from \"debug\";\nimport type envPathsT from \"env-paths\";\nimport fs from \"fs-extra\";\nimport os from \"os\";\nimport path from \"path\";\n\nconst log = debug(\"hardhat:core:global-dir\");\n\nasync function generatePaths(packageName = \"hardhat\") {\n  const { default: envPaths } = await import(\"env-paths\");\n  return envPaths(packageName);\n}\n\nfunction generatePathsSync(packageName = \"hardhat\") {\n  const envPaths: typeof envPathsT = require(\"env-paths\");\n  return envPaths(packageName);\n}\n\nfunction getConfigDirSync(): string {\n  const { config } = generatePathsSync();\n  fs.ensureDirSync(config);\n  return config;\n}\n\nasync function getDataDir(packageName?: string): Promise<string> {\n  const { data } = await generatePaths(packageName);\n  await fs.ensureDir(data);\n  return data;\n}\n\nexport async function getCacheDir(): Promise<string> {\n  const { cache } = await generatePaths();\n  await fs.ensureDir(cache);\n  return cache;\n}\n\nexport async function readAnalyticsId() {\n  const globalDataDir = await getDataDir();\n  const idFile = path.join(globalDataDir, \"analytics.json\");\n  return readId(idFile);\n}\n\n/**\n * This is the first way that the analytics id was saved.\n */\nexport function readFirstLegacyAnalyticsId() {\n  const oldIdFile = path.join(os.homedir(), \".buidler\", \"config.json\");\n  return readId(oldIdFile);\n}\n\n/**\n * This is the same way the analytics id is saved now, but using buidler as the\n * name of the project for env-paths\n */\nexport async function readSecondLegacyAnalyticsId() {\n  const globalDataDir = await getDataDir(\"buidler\");\n  const idFile = path.join(globalDataDir, \"analytics.json\");\n  return readId(idFile);\n}\n\nasync function readId(idFile: string): Promise<string | undefined> {\n  log(`Looking up Client Id at ${idFile}`);\n  let clientId: string;\n  try {\n    const data = await fs.readJSON(idFile, { encoding: \"utf8\" });\n    clientId = data.analytics.clientId;\n  } catch (error) {\n    return undefined;\n  }\n\n  log(`Client Id found: ${clientId}`);\n  return clientId;\n}\n\nexport async function writeAnalyticsId(clientId: string) {\n  const globalDataDir = await getDataDir();\n  const idFile = path.join(globalDataDir, \"analytics.json\");\n  await fs.writeJSON(\n    idFile,\n    {\n      analytics: {\n        clientId,\n      },\n    },\n    { encoding: \"utf-8\", spaces: 2 }\n  );\n  log(`Stored clientId ${clientId}`);\n}\n\nexport async function getCompilersDir() {\n  const cache = await getCacheDir();\n  const compilersCache = path.join(cache, \"compilers\");\n  await fs.ensureDir(compilersCache);\n  return compilersCache;\n}\n\n/**\n * Checks if the user has given (or refused) consent for telemetry.\n *\n * Returns undefined if it can't be determined.\n */\nexport function hasConsentedTelemetry(): boolean | undefined {\n  const configDir = getConfigDirSync();\n  const telemetryConsentPath = path.join(configDir, \"telemetry-consent.json\");\n\n  const fileExists = fs.pathExistsSync(telemetryConsentPath);\n\n  if (!fileExists) {\n    return undefined;\n  }\n\n  const { consent } = fs.readJSONSync(telemetryConsentPath);\n  return consent;\n}\n\nexport function writeTelemetryConsent(consent: boolean) {\n  const configDir = getConfigDirSync();\n  const telemetryConsentPath = path.join(configDir, \"telemetry-consent.json\");\n\n  fs.writeJSONSync(telemetryConsentPath, { consent }, { spaces: 2 });\n}\n"]},"metadata":{},"sourceType":"script"}