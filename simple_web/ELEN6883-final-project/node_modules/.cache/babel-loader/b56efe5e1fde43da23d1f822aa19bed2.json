{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.download = void 0;\n\nconst fs_1 = __importDefault(require(\"fs\"));\n\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\n\nconst https_proxy_agent_1 = __importDefault(require(\"https-proxy-agent\"));\n\nconst path_1 = __importDefault(require(\"path\"));\n\nconst util_1 = __importDefault(require(\"util\"));\n\nconst TEMP_FILE_PREFIX = \"tmp-\";\n\nfunction resolveTempFileName(filePath) {\n  const {\n    dir,\n    ext,\n    name\n  } = path_1.default.parse(filePath);\n  return path_1.default.format({\n    dir,\n    ext,\n    name: `${TEMP_FILE_PREFIX}${name}`\n  });\n}\n\nasync function download(url, filePath) {\n  let timeoutMillis = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10000;\n  const {\n    pipeline\n  } = await Promise.resolve().then(() => __importStar(require(\"stream\")));\n  const {\n    default: fetch\n  } = await Promise.resolve().then(() => __importStar(require(\"node-fetch\")));\n  const streamPipeline = util_1.default.promisify(pipeline);\n  const fetchOptions = {\n    timeout: timeoutMillis,\n    agent: undefined\n  }; // Check if Proxy is set https\n\n  if (process.env.HTTPS_PROXY !== undefined) {\n    // Create the proxy from the environment variables\n    const proxy = process.env.HTTPS_PROXY;\n    fetchOptions.agent = new https_proxy_agent_1.default.HttpsProxyAgent(proxy);\n  } // Check if Proxy is set http and `fetchOptions.agent` was not already set for https\n\n\n  if (process.env.HTTP_PROXY !== undefined && fetchOptions.agent === undefined) {\n    // Create the proxy from the environment variables\n    const proxy = process.env.HTTP_PROXY;\n    fetchOptions.agent = new https_proxy_agent_1.default.HttpsProxyAgent(proxy);\n  } // Fetch the url\n\n\n  const response = await fetch(url, fetchOptions);\n\n  if (response.ok && response.body !== null) {\n    const tmpFilePath = resolveTempFileName(filePath);\n    await fs_extra_1.default.ensureDir(path_1.default.dirname(filePath));\n    await streamPipeline(response.body, fs_1.default.createWriteStream(tmpFilePath));\n    return fs_extra_1.default.move(tmpFilePath, filePath, {\n      overwrite: true\n    });\n  } // Consume the response stream and discard its result\n  // See: https://github.com/node-fetch/node-fetch/issues/83\n\n\n  const _discarded = await response.arrayBuffer(); // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n  throw new Error(`Failed to download ${url} - ${response.statusText} received`);\n}\n\nexports.download = download;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AACA;;AACA;;AACA;;AAOA,MAAMA,gBAAgB,GAAG,MAAzB;;AAEA,SAASC,mBAAT,CAA6BC,QAA7B,EAA6C;AAC3C,QAAM;AAAEC,OAAF;AAAOC,OAAP;AAAYC;AAAZ,MAAqBC,eAAKC,KAAL,CAAWL,QAAX,CAA3B;AAEA,SAAOI,eAAKE,MAAL,CAAY;AACjBL,OADiB;AAEjBC,OAFiB;AAGjBC,QAAI,EAAE,GAAGL,gBAAgB,GAAGK,IAAI;AAHf,GAAZ,CAAP;AAKD;;AAEM,eAAeI,QAAf,CACLC,GADK,EAELR,QAFK,EAGgB;AAAA,MAArBS,aAAqB,uEAAL,KAAK;AAErB,QAAM;AAAEC;AAAF,MAAe,wDAAa,QAAb,GAArB;AACA,QAAM;AAAEC,WAAO,EAAEC;AAAX,MAAqB,wDAAa,YAAb,GAA3B;AACA,QAAMC,cAAc,GAAGC,eAAKC,SAAL,CAAeL,QAAf,CAAvB;AACA,QAAMM,YAAY,GAAiB;AACjCC,WAAO,EAAER,aADwB;AAEjCS,SAAK,EAAEC;AAF0B,GAAnC,CALqB,CAUrB;;AACA,MAAIC,OAAO,CAACC,GAAR,CAAYC,WAAZ,KAA4BH,SAAhC,EAA2C;AACzC;AACA,UAAMI,KAAK,GAAWH,OAAO,CAACC,GAAR,CAAYC,WAAlC;AACAN,gBAAY,CAACE,KAAb,GAAqB,IAAIM,4BAAgBC,eAApB,CAAoCF,KAApC,CAArB;AACD,GAfoB,CAiBrB;;;AACA,MACEH,OAAO,CAACC,GAAR,CAAYK,UAAZ,KAA2BP,SAA3B,IACAH,YAAY,CAACE,KAAb,KAAuBC,SAFzB,EAGE;AACA;AACA,UAAMI,KAAK,GAAWH,OAAO,CAACC,GAAR,CAAYK,UAAlC;AACAV,gBAAY,CAACE,KAAb,GAAqB,IAAIM,4BAAgBC,eAApB,CAAoCF,KAApC,CAArB;AACD,GAzBoB,CA2BrB;;;AACA,QAAMI,QAAQ,GAAG,MAAMf,KAAK,CAACJ,GAAD,EAAMQ,YAAN,CAA5B;;AAEA,MAAIW,QAAQ,CAACC,EAAT,IAAeD,QAAQ,CAACE,IAAT,KAAkB,IAArC,EAA2C;AACzC,UAAMC,WAAW,GAAG/B,mBAAmB,CAACC,QAAD,CAAvC;AACA,UAAM+B,mBAAQC,SAAR,CAAkB5B,eAAK6B,OAAL,CAAajC,QAAb,CAAlB,CAAN;AAEA,UAAMa,cAAc,CAACc,QAAQ,CAACE,IAAV,EAAgBK,aAAGC,iBAAH,CAAqBL,WAArB,CAAhB,CAApB;AACA,WAAOC,mBAAQK,IAAR,CAAaN,WAAb,EAA0B9B,QAA1B,EAAoC;AAAEqC,eAAS,EAAE;AAAb,KAApC,CAAP;AACD,GApCoB,CAsCrB;AACA;;;AACA,QAAMC,UAAU,GAAG,MAAMX,QAAQ,CAACY,WAAT,EAAzB,CAxCqB,CA0CrB;;;AACA,QAAM,IAAIC,KAAJ,CACJ,sBAAsBhC,GAAG,MAAMmB,QAAQ,CAACc,UAAU,WAD9C,CAAN;AAGD;;AAjDDC","names":["TEMP_FILE_PREFIX","resolveTempFileName","filePath","dir","ext","name","path_1","parse","format","download","url","timeoutMillis","pipeline","default","fetch","streamPipeline","util_1","promisify","fetchOptions","timeout","agent","undefined","process","env","HTTPS_PROXY","proxy","https_proxy_agent_1","HttpsProxyAgent","HTTP_PROXY","response","ok","body","tmpFilePath","fs_extra_1","ensureDir","dirname","fs_1","createWriteStream","move","overwrite","_discarded","arrayBuffer","Error","statusText","exports"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/internal/util/download.ts"],"sourcesContent":["import fs from \"fs\";\nimport fsExtra from \"fs-extra\";\nimport HttpsProxyAgent from \"https-proxy-agent\";\nimport path from \"path\";\nimport util from \"util\";\n\ninterface FetchOptions {\n  timeout: number;\n  agent?: undefined | HttpsProxyAgent.HttpsProxyAgent;\n}\n\nconst TEMP_FILE_PREFIX = \"tmp-\";\n\nfunction resolveTempFileName(filePath: string): string {\n  const { dir, ext, name } = path.parse(filePath);\n\n  return path.format({\n    dir,\n    ext,\n    name: `${TEMP_FILE_PREFIX}${name}`,\n  });\n}\n\nexport async function download(\n  url: string,\n  filePath: string,\n  timeoutMillis = 10000\n) {\n  const { pipeline } = await import(\"stream\");\n  const { default: fetch } = await import(\"node-fetch\");\n  const streamPipeline = util.promisify(pipeline);\n  const fetchOptions: FetchOptions = {\n    timeout: timeoutMillis,\n    agent: undefined,\n  };\n\n  // Check if Proxy is set https\n  if (process.env.HTTPS_PROXY !== undefined) {\n    // Create the proxy from the environment variables\n    const proxy: string = process.env.HTTPS_PROXY;\n    fetchOptions.agent = new HttpsProxyAgent.HttpsProxyAgent(proxy);\n  }\n\n  // Check if Proxy is set http and `fetchOptions.agent` was not already set for https\n  if (\n    process.env.HTTP_PROXY !== undefined &&\n    fetchOptions.agent === undefined\n  ) {\n    // Create the proxy from the environment variables\n    const proxy: string = process.env.HTTP_PROXY;\n    fetchOptions.agent = new HttpsProxyAgent.HttpsProxyAgent(proxy);\n  }\n\n  // Fetch the url\n  const response = await fetch(url, fetchOptions);\n\n  if (response.ok && response.body !== null) {\n    const tmpFilePath = resolveTempFileName(filePath);\n    await fsExtra.ensureDir(path.dirname(filePath));\n\n    await streamPipeline(response.body, fs.createWriteStream(tmpFilePath));\n    return fsExtra.move(tmpFilePath, filePath, { overwrite: true });\n  }\n\n  // Consume the response stream and discard its result\n  // See: https://github.com/node-fetch/node-fetch/issues/83\n  const _discarded = await response.arrayBuffer();\n\n  // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n  throw new Error(\n    `Failed to download ${url} - ${response.statusText} received`\n  );\n}\n"]},"metadata":{},"sourceType":"script"}