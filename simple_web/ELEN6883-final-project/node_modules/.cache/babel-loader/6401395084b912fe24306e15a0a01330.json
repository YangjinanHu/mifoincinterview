{"ast":null,"code":"import { addContextToFrame, basename, dirname, SyncPromise } from '@sentry/utils';\nimport { readFile } from 'fs';\nimport { LRUMap } from 'lru_map';\nimport * as stacktrace from './stacktrace';\nvar DEFAULT_LINES_OF_CONTEXT = 7;\nvar FILE_CONTENT_CACHE = new LRUMap(100);\n/**\n * Resets the file cache. Exists for testing purposes.\n * @hidden\n */\n\nexport function resetFileContentCache() {\n  FILE_CONTENT_CACHE.clear();\n}\n/** JSDoc */\n\nfunction getFunction(frame) {\n  try {\n    return frame.functionName || frame.typeName + \".\" + (frame.methodName || '<anonymous>');\n  } catch (e) {\n    // This seems to happen sometimes when using 'use strict',\n    // stemming from `getTypeName`.\n    // [TypeError: Cannot read property 'constructor' of undefined]\n    return '<anonymous>';\n  }\n}\n\nvar mainModule = (require.main && require.main.filename && dirname(require.main.filename) || global.process.cwd()) + \"/\";\n/** JSDoc */\n\nfunction getModule(filename, base) {\n  if (!base) {\n    // eslint-disable-next-line no-param-reassign\n    base = mainModule;\n  } // It's specifically a module\n\n\n  var file = basename(filename, '.js'); // eslint-disable-next-line no-param-reassign\n\n  filename = dirname(filename);\n  var n = filename.lastIndexOf('/node_modules/');\n\n  if (n > -1) {\n    // /node_modules/ is 14 chars\n    return filename.substr(n + 14).replace(/\\//g, '.') + \":\" + file;\n  } // Let's see if it's a part of the main module\n  // To be a part of main module, it has to share the same base\n\n\n  n = (filename + \"/\").lastIndexOf(base, 0);\n\n  if (n === 0) {\n    var moduleName = filename.substr(base.length).replace(/\\//g, '.');\n\n    if (moduleName) {\n      moduleName += ':';\n    }\n\n    moduleName += file;\n    return moduleName;\n  }\n\n  return file;\n}\n/**\n * This function reads file contents and caches them in a global LRU cache.\n * Returns a Promise filepath => content array for all files that we were able to read.\n *\n * @param filenames Array of filepaths to read content from.\n */\n\n\nfunction readSourceFiles(filenames) {\n  // we're relying on filenames being de-duped already\n  if (filenames.length === 0) {\n    return SyncPromise.resolve({});\n  }\n\n  return new SyncPromise(function (resolve) {\n    var sourceFiles = {};\n    var count = 0;\n\n    var _loop_1 = function (i) {\n      var filename = filenames[i];\n      var cache = FILE_CONTENT_CACHE.get(filename); // We have a cache hit\n\n      if (cache !== undefined) {\n        // If it's not null (which means we found a file and have a content)\n        // we set the content and return it later.\n        if (cache !== null) {\n          sourceFiles[filename] = cache;\n        } // eslint-disable-next-line no-plusplus\n\n\n        count++; // In any case we want to skip here then since we have a content already or we couldn't\n        // read the file and don't want to try again.\n\n        if (count === filenames.length) {\n          resolve(sourceFiles);\n        }\n\n        return \"continue\";\n      }\n\n      readFile(filename, function (err, data) {\n        var content = err ? null : data.toString();\n        sourceFiles[filename] = content; // We always want to set the cache, even to null which means there was an error reading the file.\n        // We do not want to try to read the file again.\n\n        FILE_CONTENT_CACHE.set(filename, content); // eslint-disable-next-line no-plusplus\n\n        count++;\n\n        if (count === filenames.length) {\n          resolve(sourceFiles);\n        }\n      });\n    }; // eslint-disable-next-line @typescript-eslint/prefer-for-of\n\n\n    for (var i = 0; i < filenames.length; i++) {\n      _loop_1(i);\n    }\n  });\n}\n/**\n * @hidden\n */\n\n\nexport function extractStackFromError(error) {\n  var stack = stacktrace.parse(error);\n\n  if (!stack) {\n    return [];\n  }\n\n  return stack;\n}\n/**\n * @hidden\n */\n\nexport function parseStack(stack, options) {\n  var filesToRead = [];\n  var linesOfContext = options && options.frameContextLines !== undefined ? options.frameContextLines : DEFAULT_LINES_OF_CONTEXT;\n  var frames = stack.map(function (frame) {\n    var parsedFrame = {\n      colno: frame.columnNumber,\n      filename: frame.fileName || '',\n      function: getFunction(frame),\n      lineno: frame.lineNumber\n    };\n    var isInternal = frame.native || parsedFrame.filename && !parsedFrame.filename.startsWith('/') && !parsedFrame.filename.startsWith('.') && parsedFrame.filename.indexOf(':\\\\') !== 1; // in_app is all that's not an internal Node function or a module within node_modules\n    // note that isNative appears to return true even for node core libraries\n    // see https://github.com/getsentry/raven-node/issues/176\n\n    parsedFrame.in_app = !isInternal && parsedFrame.filename !== undefined && parsedFrame.filename.indexOf('node_modules/') === -1; // Extract a module name based on the filename\n\n    if (parsedFrame.filename) {\n      parsedFrame.module = getModule(parsedFrame.filename);\n\n      if (!isInternal && linesOfContext > 0 && filesToRead.indexOf(parsedFrame.filename) === -1) {\n        filesToRead.push(parsedFrame.filename);\n      }\n    }\n\n    return parsedFrame;\n  }); // We do an early return if we do not want to fetch context liens\n\n  if (linesOfContext <= 0) {\n    return SyncPromise.resolve(frames);\n  }\n\n  try {\n    return addPrePostContext(filesToRead, frames, linesOfContext);\n  } catch (_) {\n    // This happens in electron for example where we are not able to read files from asar.\n    // So it's fine, we recover be just returning all frames without pre/post context.\n    return SyncPromise.resolve(frames);\n  }\n}\n/**\n * This function tries to read the source files + adding pre and post context (source code)\n * to a frame.\n * @param filesToRead string[] of filepaths\n * @param frames StackFrame[] containg all frames\n */\n\nfunction addPrePostContext(filesToRead, frames, linesOfContext) {\n  return new SyncPromise(function (resolve) {\n    return readSourceFiles(filesToRead).then(function (sourceFiles) {\n      var result = frames.map(function (frame) {\n        if (frame.filename && sourceFiles[frame.filename]) {\n          try {\n            var lines = sourceFiles[frame.filename].split('\\n');\n            addContextToFrame(lines, frame, linesOfContext);\n          } catch (e) {// anomaly, being defensive in case\n            // unlikely to ever happen in practice but can definitely happen in theory\n          }\n        }\n\n        return frame;\n      });\n      resolve(result);\n    });\n  });\n}\n/**\n * @hidden\n */\n\n\nexport function getExceptionFromError(error, options) {\n  var name = error.name || error.constructor.name;\n  var stack = extractStackFromError(error);\n  return new SyncPromise(function (resolve) {\n    return parseStack(stack, options).then(function (frames) {\n      var result = {\n        stacktrace: {\n          frames: prepareFramesForEvent(frames)\n        },\n        type: name,\n        value: error.message\n      };\n      resolve(result);\n    });\n  });\n}\n/**\n * @hidden\n */\n\nexport function parseError(error, options) {\n  return new SyncPromise(function (resolve) {\n    return getExceptionFromError(error, options).then(function (exception) {\n      resolve({\n        exception: {\n          values: [exception]\n        }\n      });\n    });\n  });\n}\n/**\n * @hidden\n */\n\nexport function prepareFramesForEvent(stack) {\n  if (!stack || !stack.length) {\n    return [];\n  }\n\n  var localStack = stack;\n  var firstFrameFunction = localStack[0].function || '';\n\n  if (firstFrameFunction.indexOf('captureMessage') !== -1 || firstFrameFunction.indexOf('captureException') !== -1) {\n    localStack = localStack.slice(1);\n  } // The frame where the crash happened, should be the last entry in the array\n\n\n  return localStack.reverse();\n}","map":{"version":3,"mappings":"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","names":["addContextToFrame","basename","dirname","SyncPromise","readFile","LRUMap","stacktrace","DEFAULT_LINES_OF_CONTEXT","FILE_CONTENT_CACHE","resetFileContentCache","clear","getFunction","frame","functionName","typeName","methodName","e","mainModule","require","main","filename","global","process","cwd","getModule","base","file","n","lastIndexOf","substr","replace","moduleName","length","readSourceFiles","filenames","resolve","sourceFiles","count","i","cache","get","undefined","err","data","content","toString","set","extractStackFromError","error","stack","parse","parseStack","options","filesToRead","linesOfContext","frameContextLines","frames","map","parsedFrame","colno","columnNumber","fileName","function","lineno","lineNumber","isInternal","native","startsWith","indexOf","in_app","module","push","addPrePostContext","_","then","result","lines","split","getExceptionFromError","name","constructor","prepareFramesForEvent","type","value","message","parseError","exception","values","localStack","firstFrameFunction","slice","reverse"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/@sentry/node/src/parsers.ts"],"sourcesContent":["import { Event, Exception, ExtendedError, StackFrame } from '@sentry/types';\nimport { addContextToFrame, basename, dirname, SyncPromise } from '@sentry/utils';\nimport { readFile } from 'fs';\nimport { LRUMap } from 'lru_map';\n\nimport { NodeOptions } from './backend';\nimport * as stacktrace from './stacktrace';\n\nconst DEFAULT_LINES_OF_CONTEXT: number = 7;\nconst FILE_CONTENT_CACHE = new LRUMap<string, string | null>(100);\n\n/**\n * Resets the file cache. Exists for testing purposes.\n * @hidden\n */\nexport function resetFileContentCache(): void {\n  FILE_CONTENT_CACHE.clear();\n}\n\n/** JSDoc */\nfunction getFunction(frame: stacktrace.StackFrame): string {\n  try {\n    return frame.functionName || `${frame.typeName}.${frame.methodName || '<anonymous>'}`;\n  } catch (e) {\n    // This seems to happen sometimes when using 'use strict',\n    // stemming from `getTypeName`.\n    // [TypeError: Cannot read property 'constructor' of undefined]\n    return '<anonymous>';\n  }\n}\n\nconst mainModule: string = `${(require.main && require.main.filename && dirname(require.main.filename)) ||\n  global.process.cwd()}/`;\n\n/** JSDoc */\nfunction getModule(filename: string, base?: string): string {\n  if (!base) {\n    // eslint-disable-next-line no-param-reassign\n    base = mainModule;\n  }\n\n  // It's specifically a module\n  const file = basename(filename, '.js');\n  // eslint-disable-next-line no-param-reassign\n  filename = dirname(filename);\n  let n = filename.lastIndexOf('/node_modules/');\n  if (n > -1) {\n    // /node_modules/ is 14 chars\n    return `${filename.substr(n + 14).replace(/\\//g, '.')}:${file}`;\n  }\n  // Let's see if it's a part of the main module\n  // To be a part of main module, it has to share the same base\n  n = `${filename}/`.lastIndexOf(base, 0);\n  if (n === 0) {\n    let moduleName = filename.substr(base.length).replace(/\\//g, '.');\n    if (moduleName) {\n      moduleName += ':';\n    }\n    moduleName += file;\n    return moduleName;\n  }\n  return file;\n}\n\n/**\n * This function reads file contents and caches them in a global LRU cache.\n * Returns a Promise filepath => content array for all files that we were able to read.\n *\n * @param filenames Array of filepaths to read content from.\n */\nfunction readSourceFiles(filenames: string[]): PromiseLike<{ [key: string]: string | null }> {\n  // we're relying on filenames being de-duped already\n  if (filenames.length === 0) {\n    return SyncPromise.resolve({});\n  }\n\n  return new SyncPromise<{\n    [key: string]: string | null;\n  }>(resolve => {\n    const sourceFiles: {\n      [key: string]: string | null;\n    } = {};\n\n    let count = 0;\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of\n    for (let i = 0; i < filenames.length; i++) {\n      const filename = filenames[i];\n\n      const cache = FILE_CONTENT_CACHE.get(filename);\n      // We have a cache hit\n      if (cache !== undefined) {\n        // If it's not null (which means we found a file and have a content)\n        // we set the content and return it later.\n        if (cache !== null) {\n          sourceFiles[filename] = cache;\n        }\n        // eslint-disable-next-line no-plusplus\n        count++;\n        // In any case we want to skip here then since we have a content already or we couldn't\n        // read the file and don't want to try again.\n        if (count === filenames.length) {\n          resolve(sourceFiles);\n        }\n        continue;\n      }\n\n      readFile(filename, (err: Error | null, data: Buffer) => {\n        const content = err ? null : data.toString();\n        sourceFiles[filename] = content;\n\n        // We always want to set the cache, even to null which means there was an error reading the file.\n        // We do not want to try to read the file again.\n        FILE_CONTENT_CACHE.set(filename, content);\n        // eslint-disable-next-line no-plusplus\n        count++;\n        if (count === filenames.length) {\n          resolve(sourceFiles);\n        }\n      });\n    }\n  });\n}\n\n/**\n * @hidden\n */\nexport function extractStackFromError(error: Error): stacktrace.StackFrame[] {\n  const stack = stacktrace.parse(error);\n  if (!stack) {\n    return [];\n  }\n  return stack;\n}\n\n/**\n * @hidden\n */\nexport function parseStack(stack: stacktrace.StackFrame[], options?: NodeOptions): PromiseLike<StackFrame[]> {\n  const filesToRead: string[] = [];\n\n  const linesOfContext =\n    options && options.frameContextLines !== undefined ? options.frameContextLines : DEFAULT_LINES_OF_CONTEXT;\n\n  const frames: StackFrame[] = stack.map(frame => {\n    const parsedFrame: StackFrame = {\n      colno: frame.columnNumber,\n      filename: frame.fileName || '',\n      function: getFunction(frame),\n      lineno: frame.lineNumber,\n    };\n\n    const isInternal =\n      frame.native ||\n      (parsedFrame.filename &&\n        !parsedFrame.filename.startsWith('/') &&\n        !parsedFrame.filename.startsWith('.') &&\n        parsedFrame.filename.indexOf(':\\\\') !== 1);\n\n    // in_app is all that's not an internal Node function or a module within node_modules\n    // note that isNative appears to return true even for node core libraries\n    // see https://github.com/getsentry/raven-node/issues/176\n    parsedFrame.in_app =\n      !isInternal && parsedFrame.filename !== undefined && parsedFrame.filename.indexOf('node_modules/') === -1;\n\n    // Extract a module name based on the filename\n    if (parsedFrame.filename) {\n      parsedFrame.module = getModule(parsedFrame.filename);\n\n      if (!isInternal && linesOfContext > 0 && filesToRead.indexOf(parsedFrame.filename) === -1) {\n        filesToRead.push(parsedFrame.filename);\n      }\n    }\n\n    return parsedFrame;\n  });\n\n  // We do an early return if we do not want to fetch context liens\n  if (linesOfContext <= 0) {\n    return SyncPromise.resolve(frames);\n  }\n\n  try {\n    return addPrePostContext(filesToRead, frames, linesOfContext);\n  } catch (_) {\n    // This happens in electron for example where we are not able to read files from asar.\n    // So it's fine, we recover be just returning all frames without pre/post context.\n    return SyncPromise.resolve(frames);\n  }\n}\n\n/**\n * This function tries to read the source files + adding pre and post context (source code)\n * to a frame.\n * @param filesToRead string[] of filepaths\n * @param frames StackFrame[] containg all frames\n */\nfunction addPrePostContext(\n  filesToRead: string[],\n  frames: StackFrame[],\n  linesOfContext: number,\n): PromiseLike<StackFrame[]> {\n  return new SyncPromise<StackFrame[]>(resolve =>\n    readSourceFiles(filesToRead).then(sourceFiles => {\n      const result = frames.map(frame => {\n        if (frame.filename && sourceFiles[frame.filename]) {\n          try {\n            const lines = (sourceFiles[frame.filename] as string).split('\\n');\n\n            addContextToFrame(lines, frame, linesOfContext);\n          } catch (e) {\n            // anomaly, being defensive in case\n            // unlikely to ever happen in practice but can definitely happen in theory\n          }\n        }\n        return frame;\n      });\n\n      resolve(result);\n    }),\n  );\n}\n\n/**\n * @hidden\n */\nexport function getExceptionFromError(error: Error, options?: NodeOptions): PromiseLike<Exception> {\n  const name = error.name || error.constructor.name;\n  const stack = extractStackFromError(error);\n  return new SyncPromise<Exception>(resolve =>\n    parseStack(stack, options).then(frames => {\n      const result = {\n        stacktrace: {\n          frames: prepareFramesForEvent(frames),\n        },\n        type: name,\n        value: error.message,\n      };\n      resolve(result);\n    }),\n  );\n}\n\n/**\n * @hidden\n */\nexport function parseError(error: ExtendedError, options?: NodeOptions): PromiseLike<Event> {\n  return new SyncPromise<Event>(resolve =>\n    getExceptionFromError(error, options).then((exception: Exception) => {\n      resolve({\n        exception: {\n          values: [exception],\n        },\n      });\n    }),\n  );\n}\n\n/**\n * @hidden\n */\nexport function prepareFramesForEvent(stack: StackFrame[]): StackFrame[] {\n  if (!stack || !stack.length) {\n    return [];\n  }\n\n  let localStack = stack;\n  const firstFrameFunction = localStack[0].function || '';\n\n  if (firstFrameFunction.indexOf('captureMessage') !== -1 || firstFrameFunction.indexOf('captureException') !== -1) {\n    localStack = localStack.slice(1);\n  }\n\n  // The frame where the crash happened, should be the last entry in the array\n  return localStack.reverse();\n}\n"]},"metadata":{},"sourceType":"module"}