{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.normalizeHardhatNetworkAccountsConfig = exports.derivePrivateKeys = void 0;\n\nconst keys_derivation_1 = require(\"../../util/keys-derivation\");\n\nconst default_config_1 = require(\"../config/default-config\");\n\nconst errors_1 = require(\"../errors\");\n\nconst errors_list_1 = require(\"../errors-list\");\n\nconst HD_PATH_REGEX = /^m(:?\\/\\d+'?)+\\/?$/;\n\nfunction derivePrivateKeys(mnemonic, hdpath, initialIndex, count) {\n  if (hdpath.match(HD_PATH_REGEX) === null) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.INVALID_HD_PATH, {\n      path: hdpath\n    });\n  }\n\n  if (!hdpath.endsWith(\"/\")) {\n    hdpath += \"/\";\n  }\n\n  const privateKeys = [];\n\n  for (let i = initialIndex; i < initialIndex + count; i++) {\n    const privateKey = (0, keys_derivation_1.deriveKeyFromMnemonicAndPath)(mnemonic, hdpath + i.toString());\n\n    if (privateKey === undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.CANT_DERIVE_KEY, {\n        mnemonic,\n        path: hdpath\n      });\n    }\n\n    privateKeys.push(privateKey);\n  }\n\n  return privateKeys;\n}\n\nexports.derivePrivateKeys = derivePrivateKeys;\n\nfunction normalizeHardhatNetworkAccountsConfig(accountsConfig) {\n  if (Array.isArray(accountsConfig)) {\n    return accountsConfig;\n  }\n\n  const {\n    bufferToHex\n  } = require(\"ethereumjs-util\");\n\n  return derivePrivateKeys(accountsConfig.mnemonic, accountsConfig.path, accountsConfig.initialIndex, accountsConfig.count).map(pk => {\n    var _a;\n\n    return {\n      privateKey: bufferToHex(pk),\n      balance: (_a = accountsConfig.accountsBalance) !== null && _a !== void 0 ? _a : default_config_1.DEFAULT_HARDHAT_NETWORK_BALANCE\n    };\n  });\n}\n\nexports.normalizeHardhatNetworkAccountsConfig = normalizeHardhatNetworkAccountsConfig;","map":{"version":3,"mappings":";;;;;;;AAIA;;AACA;;AACA;;AACA;;AAEA,MAAMA,aAAa,GAAG,oBAAtB;;AAEA,SAAgBC,iBAAhB,CACEC,QADF,EAEEC,MAFF,EAGEC,YAHF,EAIEC,KAJF,EAIe;AAEb,MAAIF,MAAM,CAACG,KAAP,CAAaN,aAAb,MAAgC,IAApC,EAA0C;AACxC,UAAM,IAAIO,qBAAJ,CAAiBC,qBAAOC,OAAP,CAAeC,eAAhC,EAAiD;AAAEC,UAAI,EAAER;AAAR,KAAjD,CAAN;AACD;;AAED,MAAI,CAACA,MAAM,CAACS,QAAP,CAAgB,GAAhB,CAAL,EAA2B;AACzBT,UAAM,IAAI,GAAV;AACD;;AAED,QAAMU,WAAW,GAAa,EAA9B;;AAEA,OAAK,IAAIC,CAAC,GAAGV,YAAb,EAA2BU,CAAC,GAAGV,YAAY,GAAGC,KAA9C,EAAqDS,CAAC,EAAtD,EAA0D;AACxD,UAAMC,UAAU,GAAG,oDACjBb,QADiB,EAEjBC,MAAM,GAAGW,CAAC,CAACE,QAAF,EAFQ,CAAnB;;AAKA,QAAID,UAAU,KAAKE,SAAnB,EAA8B;AAC5B,YAAM,IAAIV,qBAAJ,CAAiBC,qBAAOC,OAAP,CAAeS,eAAhC,EAAiD;AACrDhB,gBADqD;AAErDS,YAAI,EAAER;AAF+C,OAAjD,CAAN;AAID;;AAEDU,eAAW,CAACM,IAAZ,CAAiBJ,UAAjB;AACD;;AAED,SAAOF,WAAP;AACD;;AAjCDO;;AAmCA,SAAgBC,qCAAhB,CACEC,cADF,EAC8C;AAE5C,MAAIC,KAAK,CAACC,OAAN,CAAcF,cAAd,CAAJ,EAAmC;AACjC,WAAOA,cAAP;AACD;;AAED,QAAM;AAAEG;AAAF,MAAkBC,OAAO,CAAC,iBAAD,CAA/B;;AAEA,SAAOzB,iBAAiB,CACtBqB,cAAc,CAACpB,QADO,EAEtBoB,cAAc,CAACX,IAFO,EAGtBW,cAAc,CAAClB,YAHO,EAItBkB,cAAc,CAACjB,KAJO,CAAjB,CAKLsB,GALK,CAKAC,EAAD,IAAO;;;AAAC,WAAC;AACbb,gBAAU,EAAEU,WAAW,CAACG,EAAD,CADV;AAEbC,aAAO,EAAE,oBAAc,CAACC,eAAf,MAA8B,IAA9B,IAA8BC,aAA9B,GAA8BA,EAA9B,GAAkCC;AAF9B,KAAD;AAGZ,GARK,CAAP;AASD;;AAlBDZ","names":["HD_PATH_REGEX","derivePrivateKeys","mnemonic","hdpath","initialIndex","count","match","errors_1","errors_list_1","NETWORK","INVALID_HD_PATH","path","endsWith","privateKeys","i","privateKey","toString","undefined","CANT_DERIVE_KEY","push","exports","normalizeHardhatNetworkAccountsConfig","accountsConfig","Array","isArray","bufferToHex","require","map","pk","balance","accountsBalance","_a","default_config_1"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/internal/core/providers/util.ts"],"sourcesContent":["import {\n  HardhatNetworkAccountConfig,\n  HardhatNetworkAccountsConfig,\n} from \"../../../types\";\nimport { deriveKeyFromMnemonicAndPath } from \"../../util/keys-derivation\";\nimport { DEFAULT_HARDHAT_NETWORK_BALANCE } from \"../config/default-config\";\nimport { HardhatError } from \"../errors\";\nimport { ERRORS } from \"../errors-list\";\n\nconst HD_PATH_REGEX = /^m(:?\\/\\d+'?)+\\/?$/;\n\nexport function derivePrivateKeys(\n  mnemonic: string,\n  hdpath: string,\n  initialIndex: number,\n  count: number\n): Buffer[] {\n  if (hdpath.match(HD_PATH_REGEX) === null) {\n    throw new HardhatError(ERRORS.NETWORK.INVALID_HD_PATH, { path: hdpath });\n  }\n\n  if (!hdpath.endsWith(\"/\")) {\n    hdpath += \"/\";\n  }\n\n  const privateKeys: Buffer[] = [];\n\n  for (let i = initialIndex; i < initialIndex + count; i++) {\n    const privateKey = deriveKeyFromMnemonicAndPath(\n      mnemonic,\n      hdpath + i.toString()\n    );\n\n    if (privateKey === undefined) {\n      throw new HardhatError(ERRORS.NETWORK.CANT_DERIVE_KEY, {\n        mnemonic,\n        path: hdpath,\n      });\n    }\n\n    privateKeys.push(privateKey);\n  }\n\n  return privateKeys;\n}\n\nexport function normalizeHardhatNetworkAccountsConfig(\n  accountsConfig: HardhatNetworkAccountsConfig\n): HardhatNetworkAccountConfig[] {\n  if (Array.isArray(accountsConfig)) {\n    return accountsConfig;\n  }\n\n  const { bufferToHex } = require(\"ethereumjs-util\");\n\n  return derivePrivateKeys(\n    accountsConfig.mnemonic,\n    accountsConfig.path,\n    accountsConfig.initialIndex,\n    accountsConfig.count\n  ).map((pk) => ({\n    privateKey: bufferToHex(pk),\n    balance: accountsConfig.accountsBalance ?? DEFAULT_HARDHAT_NETWORK_BALANCE,\n  }));\n}\n"]},"metadata":{},"sourceType":"script"}