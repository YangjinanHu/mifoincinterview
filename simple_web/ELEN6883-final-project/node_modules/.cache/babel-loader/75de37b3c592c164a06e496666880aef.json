{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSolidityFilesCachePath = exports.SolidityFilesCache = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\n\nconst t = __importStar(require(\"io-ts\"));\n\nconst path = __importStar(require(\"path\"));\n\nconst constants_1 = require(\"../../internal/constants\");\n\nconst log = (0, debug_1.default)(\"hardhat:core:tasks:compile:cache\");\nconst FORMAT_VERSION = \"hh-sol-cache-2\";\nconst CacheEntryCodec = t.type({\n  lastModificationDate: t.number,\n  contentHash: t.string,\n  sourceName: t.string,\n  solcConfig: t.any,\n  imports: t.array(t.string),\n  versionPragmas: t.array(t.string),\n  artifacts: t.array(t.string)\n});\nconst CacheCodec = t.type({\n  _format: t.string,\n  files: t.record(t.string, CacheEntryCodec)\n});\n\nclass SolidityFilesCache {\n  constructor(_cache) {\n    this._cache = _cache;\n  }\n\n  static createEmpty() {\n    return new SolidityFilesCache({\n      _format: FORMAT_VERSION,\n      files: {}\n    });\n  }\n\n  static async readFromFile(solidityFilesCachePath) {\n    let cacheRaw = {\n      _format: FORMAT_VERSION,\n      files: {}\n    };\n\n    if (fs_extra_1.default.existsSync(solidityFilesCachePath)) {\n      cacheRaw = await fs_extra_1.default.readJson(solidityFilesCachePath);\n    }\n\n    const result = CacheCodec.decode(cacheRaw);\n\n    if (result.isRight()) {\n      const solidityFilesCache = new SolidityFilesCache(result.value);\n      await solidityFilesCache.removeNonExistingFiles();\n      return solidityFilesCache;\n    }\n\n    log(\"There was a problem reading the cache\");\n    return new SolidityFilesCache({\n      _format: FORMAT_VERSION,\n      files: {}\n    });\n  }\n\n  async removeNonExistingFiles() {\n    for (const absolutePath of Object.keys(this._cache.files)) {\n      if (!fs_extra_1.default.existsSync(absolutePath)) {\n        this.removeEntry(absolutePath);\n        continue;\n      }\n    }\n  }\n\n  async writeToFile(solidityFilesCachePath) {\n    await fs_extra_1.default.outputJson(solidityFilesCachePath, this._cache, {\n      spaces: 2\n    });\n  }\n\n  addFile(absolutePath, entry) {\n    this._cache.files[absolutePath] = entry;\n  }\n\n  getEntries() {\n    return Object.values(this._cache.files);\n  }\n\n  getEntry(file) {\n    return this._cache.files[file];\n  }\n\n  removeEntry(file) {\n    delete this._cache.files[file];\n  }\n\n  hasFileChanged(absolutePath, contentHash, solcConfig) {\n    const {\n      isEqual\n    } = require(\"lodash\");\n\n    const cacheEntry = this.getEntry(absolutePath);\n\n    if (cacheEntry === undefined) {\n      // new file or no cache available, assume it's new\n      return true;\n    }\n\n    if (cacheEntry.contentHash !== contentHash) {\n      return true;\n    }\n\n    if (solcConfig !== undefined && !isEqual(solcConfig, cacheEntry.solcConfig)) {\n      return true;\n    }\n\n    return false;\n  }\n\n}\n\nexports.SolidityFilesCache = SolidityFilesCache;\n\nfunction getSolidityFilesCachePath(paths) {\n  return path.join(paths.cache, constants_1.SOLIDITY_FILES_CACHE_FILENAME);\n}\n\nexports.getSolidityFilesCachePath = getSolidityFilesCachePath;","map":{"version":3,"mappings":"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","names":["log","FORMAT_VERSION","CacheEntryCodec","t","type","lastModificationDate","number","contentHash","string","sourceName","solcConfig","any","imports","array","versionPragmas","artifacts","CacheCodec","_format","files","record","SolidityFilesCache","constructor","_cache","createEmpty","readFromFile","solidityFilesCachePath","cacheRaw","fs_extra_1","existsSync","readJson","result","decode","isRight","solidityFilesCache","value","removeNonExistingFiles","absolutePath","Object","keys","removeEntry","writeToFile","outputJson","spaces","addFile","entry","getEntries","values","getEntry","file","hasFileChanged","isEqual","require","cacheEntry","undefined","exports","getSolidityFilesCachePath","paths","path","join","cache","constants_1"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/builtin-tasks/utils/solidity-files-cache.ts"],"sourcesContent":["import debug from \"debug\";\nimport fsExtra from \"fs-extra\";\nimport * as t from \"io-ts\";\nimport type { LoDashStatic } from \"lodash\";\nimport * as path from \"path\";\n\nimport { SOLIDITY_FILES_CACHE_FILENAME } from \"../../internal/constants\";\nimport type { ProjectPathsConfig, SolcConfig } from \"../../types\";\n\nconst log = debug(\"hardhat:core:tasks:compile:cache\");\n\nconst FORMAT_VERSION = \"hh-sol-cache-2\";\n\nconst CacheEntryCodec = t.type({\n  lastModificationDate: t.number,\n  contentHash: t.string,\n  sourceName: t.string,\n  solcConfig: t.any,\n  imports: t.array(t.string),\n  versionPragmas: t.array(t.string),\n  artifacts: t.array(t.string),\n});\n\nconst CacheCodec = t.type({\n  _format: t.string,\n  files: t.record(t.string, CacheEntryCodec),\n});\n\nexport interface CacheEntry {\n  lastModificationDate: number;\n  contentHash: string;\n  sourceName: string;\n  solcConfig: SolcConfig;\n  imports: string[];\n  versionPragmas: string[];\n  artifacts: string[];\n}\n\nexport interface Cache {\n  _format: string;\n  files: Record<string, CacheEntry>;\n}\n\nexport class SolidityFilesCache {\n  public static createEmpty(): SolidityFilesCache {\n    return new SolidityFilesCache({\n      _format: FORMAT_VERSION,\n      files: {},\n    });\n  }\n\n  public static async readFromFile(\n    solidityFilesCachePath: string\n  ): Promise<SolidityFilesCache> {\n    let cacheRaw: Cache = {\n      _format: FORMAT_VERSION,\n      files: {},\n    };\n    if (fsExtra.existsSync(solidityFilesCachePath)) {\n      cacheRaw = await fsExtra.readJson(solidityFilesCachePath);\n    }\n\n    const result = CacheCodec.decode(cacheRaw);\n\n    if (result.isRight()) {\n      const solidityFilesCache = new SolidityFilesCache(result.value);\n      await solidityFilesCache.removeNonExistingFiles();\n      return solidityFilesCache;\n    }\n\n    log(\"There was a problem reading the cache\");\n\n    return new SolidityFilesCache({\n      _format: FORMAT_VERSION,\n      files: {},\n    });\n  }\n\n  constructor(private _cache: Cache) {}\n\n  public async removeNonExistingFiles() {\n    for (const absolutePath of Object.keys(this._cache.files)) {\n      if (!fsExtra.existsSync(absolutePath)) {\n        this.removeEntry(absolutePath);\n        continue;\n      }\n    }\n  }\n\n  public async writeToFile(solidityFilesCachePath: string) {\n    await fsExtra.outputJson(solidityFilesCachePath, this._cache, {\n      spaces: 2,\n    });\n  }\n\n  public addFile(absolutePath: string, entry: CacheEntry) {\n    this._cache.files[absolutePath] = entry;\n  }\n\n  public getEntries(): CacheEntry[] {\n    return Object.values(this._cache.files);\n  }\n\n  public getEntry(file: string): CacheEntry | undefined {\n    return this._cache.files[file];\n  }\n\n  public removeEntry(file: string) {\n    delete this._cache.files[file];\n  }\n\n  public hasFileChanged(\n    absolutePath: string,\n    contentHash: string,\n    solcConfig?: SolcConfig\n  ): boolean {\n    const { isEqual }: LoDashStatic = require(\"lodash\");\n\n    const cacheEntry = this.getEntry(absolutePath);\n\n    if (cacheEntry === undefined) {\n      // new file or no cache available, assume it's new\n      return true;\n    }\n\n    if (cacheEntry.contentHash !== contentHash) {\n      return true;\n    }\n\n    if (\n      solcConfig !== undefined &&\n      !isEqual(solcConfig, cacheEntry.solcConfig)\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n}\n\nexport function getSolidityFilesCachePath(paths: ProjectPathsConfig): string {\n  return path.join(paths.cache, SOLIDITY_FILES_CACHE_FILENAME);\n}\n"]},"metadata":{},"sourceType":"script"}