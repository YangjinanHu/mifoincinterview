{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JsonRpcServer = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst http_1 = __importDefault(require(\"http\"));\n\nconst http_2 = require(\"../../core/providers/http\");\n\nconst handler_1 = require(\"./handler\");\n\nconst log = (0, debug_1.default)(\"hardhat:core:hardhat-network:jsonrpc\");\n\nclass JsonRpcServer {\n  constructor(config) {\n    var _this = this;\n\n    this.getProvider = function () {\n      let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"json-rpc\";\n\n      const {\n        address,\n        port\n      } = _this._httpServer.address(); // TCP sockets return AddressInfo\n\n\n      return new http_2.HttpProvider(`http://${address}:${port}/`, name);\n    };\n\n    this.listen = () => {\n      return new Promise(resolve => {\n        log(`Starting JSON-RPC server on port ${this._config.port}`);\n\n        this._httpServer.listen(this._config.port, this._config.hostname, () => {\n          // We get the address and port directly from the server in order to handle random port allocation with `0`.\n          const address = this._httpServer.address(); // TCP sockets return AddressInfo\n\n\n          resolve(address);\n        });\n      });\n    };\n\n    this.waitUntilClosed = async () => {\n      const httpServerClosed = new Promise(resolve => {\n        this._httpServer.once(\"close\", resolve);\n      });\n      const wsServerClosed = new Promise(resolve => {\n        this._wsServer.once(\"close\", resolve);\n      });\n      await Promise.all([httpServerClosed, wsServerClosed]);\n    };\n\n    this.close = async () => {\n      await Promise.all([new Promise((resolve, reject) => {\n        log(\"Closing JSON-RPC server\");\n\n        this._httpServer.close(err => {\n          if (err !== null && err !== undefined) {\n            log(\"Failed to close JSON-RPC server\");\n            reject(err);\n            return;\n          }\n\n          log(\"JSON-RPC server closed\");\n          resolve();\n        });\n      }), new Promise((resolve, reject) => {\n        log(\"Closing websocket server\");\n\n        this._wsServer.close(err => {\n          if (err !== null && err !== undefined) {\n            log(\"Failed to close websocket server\");\n            reject(err);\n            return;\n          }\n\n          log(\"Websocket server closed\");\n          resolve();\n        });\n      })]);\n    };\n\n    const {\n      Server: WSServer\n    } = require(\"ws\");\n\n    this._config = config;\n    const handler = new handler_1.JsonRpcHandler(config.provider);\n    this._httpServer = http_1.default.createServer();\n    this._wsServer = new WSServer({\n      server: this._httpServer\n    });\n\n    this._httpServer.on(\"request\", handler.handleHttp);\n\n    this._wsServer.on(\"connection\", handler.handleWs);\n  }\n\n}\n\nexports.JsonRpcServer = JsonRpcServer;","map":{"version":3,"mappings":"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","names":["log","JsonRpcServer","constructor","config","name","address","port","_httpServer","http_2","Promise","resolve","_config","listen","hostname","httpServerClosed","once","wsServerClosed","_wsServer","all","reject","close","err","undefined","Server","WSServer","require","handler","handler_1","provider","http_1","createServer","server","on","handleHttp","handleWs","exports"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/internal/hardhat-network/jsonrpc/server.ts"],"sourcesContent":["import debug from \"debug\";\nimport http, { Server } from \"http\";\nimport { AddressInfo } from \"net\";\nimport type WsT from \"ws\";\n\nimport {\n  EIP1193Provider,\n  JsonRpcServer as IJsonRpcServer,\n} from \"../../../types\";\nimport { HttpProvider } from \"../../core/providers/http\";\n\nimport { JsonRpcHandler } from \"./handler\";\n\nconst log = debug(\"hardhat:core:hardhat-network:jsonrpc\");\n\nexport interface JsonRpcServerConfig {\n  hostname: string;\n  port: number;\n\n  provider: EIP1193Provider;\n}\n\nexport class JsonRpcServer implements IJsonRpcServer {\n  private _config: JsonRpcServerConfig;\n  private _httpServer: Server;\n  private _wsServer: WsT.Server;\n\n  constructor(config: JsonRpcServerConfig) {\n    const { Server: WSServer } = require(\"ws\") as typeof WsT;\n\n    this._config = config;\n\n    const handler = new JsonRpcHandler(config.provider);\n\n    this._httpServer = http.createServer();\n    this._wsServer = new WSServer({\n      server: this._httpServer,\n    });\n\n    this._httpServer.on(\"request\", handler.handleHttp);\n    this._wsServer.on(\"connection\", handler.handleWs);\n  }\n\n  public getProvider = (name = \"json-rpc\"): EIP1193Provider => {\n    const { address, port } = this._httpServer.address() as AddressInfo; // TCP sockets return AddressInfo\n\n    return new HttpProvider(`http://${address}:${port}/`, name);\n  };\n\n  public listen = (): Promise<{ address: string; port: number }> => {\n    return new Promise((resolve) => {\n      log(`Starting JSON-RPC server on port ${this._config.port}`);\n      this._httpServer.listen(this._config.port, this._config.hostname, () => {\n        // We get the address and port directly from the server in order to handle random port allocation with `0`.\n        const address = this._httpServer.address() as AddressInfo; // TCP sockets return AddressInfo\n        resolve(address);\n      });\n    });\n  };\n\n  public waitUntilClosed = async () => {\n    const httpServerClosed = new Promise((resolve) => {\n      this._httpServer.once(\"close\", resolve);\n    });\n\n    const wsServerClosed = new Promise((resolve) => {\n      this._wsServer.once(\"close\", resolve);\n    });\n\n    await Promise.all([httpServerClosed, wsServerClosed]);\n  };\n\n  public close = async () => {\n    await Promise.all([\n      new Promise<void>((resolve, reject) => {\n        log(\"Closing JSON-RPC server\");\n        this._httpServer.close((err) => {\n          if (err !== null && err !== undefined) {\n            log(\"Failed to close JSON-RPC server\");\n            reject(err);\n            return;\n          }\n\n          log(\"JSON-RPC server closed\");\n          resolve();\n        });\n      }),\n      new Promise<void>((resolve, reject) => {\n        log(\"Closing websocket server\");\n        this._wsServer.close((err) => {\n          if (err !== null && err !== undefined) {\n            log(\"Failed to close websocket server\");\n            reject(err);\n            return;\n          }\n\n          log(\"Websocket server closed\");\n          resolve();\n        });\n      }),\n    ]);\n  };\n}\n"]},"metadata":{},"sourceType":"script"}