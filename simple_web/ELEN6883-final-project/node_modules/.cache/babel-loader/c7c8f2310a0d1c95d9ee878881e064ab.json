{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hardforkGte = exports.getHardforkName = exports.HardforkName = void 0;\n\nconst errors_1 = require(\"../core/errors\");\n\nvar HardforkName;\n\n(function (HardforkName) {\n  HardforkName[\"FRONTIER\"] = \"chainstart\";\n  HardforkName[\"HOMESTEAD\"] = \"homestead\";\n  HardforkName[\"DAO\"] = \"dao\";\n  HardforkName[\"TANGERINE_WHISTLE\"] = \"tangerineWhistle\";\n  HardforkName[\"SPURIOUS_DRAGON\"] = \"spuriousDragon\";\n  HardforkName[\"BYZANTIUM\"] = \"byzantium\";\n  HardforkName[\"CONSTANTINOPLE\"] = \"constantinople\";\n  HardforkName[\"PETERSBURG\"] = \"petersburg\";\n  HardforkName[\"ISTANBUL\"] = \"istanbul\";\n  HardforkName[\"MUIR_GLACIER\"] = \"muirGlacier\";\n  HardforkName[\"BERLIN\"] = \"berlin\";\n  HardforkName[\"LONDON\"] = \"london\";\n  HardforkName[\"ARROW_GLACIER\"] = \"arrowGlacier\";\n})(HardforkName = exports.HardforkName || (exports.HardforkName = {}));\n\nconst HARDFORKS_ORDER = [HardforkName.FRONTIER, HardforkName.HOMESTEAD, HardforkName.DAO, HardforkName.TANGERINE_WHISTLE, HardforkName.SPURIOUS_DRAGON, HardforkName.BYZANTIUM, HardforkName.CONSTANTINOPLE, HardforkName.PETERSBURG, HardforkName.ISTANBUL, HardforkName.MUIR_GLACIER, HardforkName.BERLIN, HardforkName.LONDON, HardforkName.ARROW_GLACIER];\n\nfunction getHardforkName(name) {\n  const hardforkName = Object.values(HardforkName)[Object.values(HardforkName).indexOf(name)];\n  (0, errors_1.assertHardhatInvariant)(hardforkName !== undefined, `Invalid harfork name ${name}`);\n  return hardforkName;\n}\n\nexports.getHardforkName = getHardforkName;\n/**\n * Check if `hardforkA` is greater than or equal to `hardforkB`,\n * that is, if it includes all its changes.\n */\n\nfunction hardforkGte(hardforkA, hardforkB) {\n  // This function should not load any ethereumjs library, as it's used during\n  // the Hardhat initialization, and that would make it too slow.\n  const indexA = HARDFORKS_ORDER.lastIndexOf(hardforkA);\n  const indexB = HARDFORKS_ORDER.lastIndexOf(hardforkB);\n  return indexA >= indexB;\n}\n\nexports.hardforkGte = hardforkGte;","map":{"version":3,"mappings":";;;;;;;AAAA;;AAEA,IAAYA,YAAZ;;AAAA,WAAYA,YAAZ,EAAwB;AACtBA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACAA;AACD,CAdD,EAAYA,YAAY,GAAZC,gDAAY,EAAZ,CAAZ;;AAgBA,MAAMC,eAAe,GAAmB,CACtCF,YAAY,CAACG,QADyB,EAEtCH,YAAY,CAACI,SAFyB,EAGtCJ,YAAY,CAACK,GAHyB,EAItCL,YAAY,CAACM,iBAJyB,EAKtCN,YAAY,CAACO,eALyB,EAMtCP,YAAY,CAACQ,SANyB,EAOtCR,YAAY,CAACS,cAPyB,EAQtCT,YAAY,CAACU,UARyB,EAStCV,YAAY,CAACW,QATyB,EAUtCX,YAAY,CAACY,YAVyB,EAWtCZ,YAAY,CAACa,MAXyB,EAYtCb,YAAY,CAACc,MAZyB,EAatCd,YAAY,CAACe,aAbyB,CAAxC;;AAgBA,SAAgBC,eAAhB,CAAgCC,IAAhC,EAA4C;AAC1C,QAAMC,YAAY,GAChBC,MAAM,CAACC,MAAP,CAAcpB,YAAd,EACEmB,MAAM,CAACC,MAAP,CAAsBpB,YAAtB,EAAoCqB,OAApC,CAA4CJ,IAA5C,CADF,CADF;AAKA,uCACEC,YAAY,KAAKI,SADnB,EAEE,wBAAwBL,IAAI,EAF9B;AAKA,SAAOC,YAAP;AACD;;AAZDjB;AAcA;;;;;AAIA,SAAgBsB,WAAhB,CACEC,SADF,EAEEC,SAFF,EAEyB;AAEvB;AACA;AACA,QAAMC,MAAM,GAAGxB,eAAe,CAACyB,WAAhB,CAA4BH,SAA5B,CAAf;AACA,QAAMI,MAAM,GAAG1B,eAAe,CAACyB,WAAhB,CAA4BF,SAA5B,CAAf;AAEA,SAAOC,MAAM,IAAIE,MAAjB;AACD;;AAVD3B","names":["HardforkName","exports","HARDFORKS_ORDER","FRONTIER","HOMESTEAD","DAO","TANGERINE_WHISTLE","SPURIOUS_DRAGON","BYZANTIUM","CONSTANTINOPLE","PETERSBURG","ISTANBUL","MUIR_GLACIER","BERLIN","LONDON","ARROW_GLACIER","getHardforkName","name","hardforkName","Object","values","indexOf","undefined","hardforkGte","hardforkA","hardforkB","indexA","lastIndexOf","indexB"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/internal/util/hardforks.ts"],"sourcesContent":["import { assertHardhatInvariant } from \"../core/errors\";\n\nexport enum HardforkName {\n  FRONTIER = \"chainstart\",\n  HOMESTEAD = \"homestead\",\n  DAO = \"dao\",\n  TANGERINE_WHISTLE = \"tangerineWhistle\",\n  SPURIOUS_DRAGON = \"spuriousDragon\",\n  BYZANTIUM = \"byzantium\",\n  CONSTANTINOPLE = \"constantinople\",\n  PETERSBURG = \"petersburg\",\n  ISTANBUL = \"istanbul\",\n  MUIR_GLACIER = \"muirGlacier\",\n  BERLIN = \"berlin\",\n  LONDON = \"london\",\n  ARROW_GLACIER = \"arrowGlacier\",\n}\n\nconst HARDFORKS_ORDER: HardforkName[] = [\n  HardforkName.FRONTIER,\n  HardforkName.HOMESTEAD,\n  HardforkName.DAO,\n  HardforkName.TANGERINE_WHISTLE,\n  HardforkName.SPURIOUS_DRAGON,\n  HardforkName.BYZANTIUM,\n  HardforkName.CONSTANTINOPLE,\n  HardforkName.PETERSBURG,\n  HardforkName.ISTANBUL,\n  HardforkName.MUIR_GLACIER,\n  HardforkName.BERLIN,\n  HardforkName.LONDON,\n  HardforkName.ARROW_GLACIER,\n];\n\nexport function getHardforkName(name: string): HardforkName {\n  const hardforkName =\n    Object.values(HardforkName)[\n      Object.values<string>(HardforkName).indexOf(name)\n    ];\n\n  assertHardhatInvariant(\n    hardforkName !== undefined,\n    `Invalid harfork name ${name}`\n  );\n\n  return hardforkName;\n}\n\n/**\n * Check if `hardforkA` is greater than or equal to `hardforkB`,\n * that is, if it includes all its changes.\n */\nexport function hardforkGte(\n  hardforkA: HardforkName,\n  hardforkB: HardforkName\n): boolean {\n  // This function should not load any ethereumjs library, as it's used during\n  // the Hardhat initialization, and that would make it too slow.\n  const indexA = HARDFORKS_ORDER.lastIndexOf(hardforkA);\n  const indexB = HARDFORKS_ORDER.lastIndexOf(hardforkB);\n\n  return indexA >= indexB;\n}\n"]},"metadata":{},"sourceType":"script"}