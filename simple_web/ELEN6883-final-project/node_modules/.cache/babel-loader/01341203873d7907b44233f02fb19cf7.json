{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mergeCompilationJobsWithoutBug = exports.mergeCompilationJobsWithBug = exports.createCompilationJobFromFile = exports.createCompilationJobsFromConnectedComponent = exports.CompilationJob = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst semver_1 = __importDefault(require(\"semver\"));\n\nconst builtin_tasks_1 = require(\"../../types/builtin-tasks\");\n\nconst errors_1 = require(\"../core/errors\");\n\nconst log = (0, debug_1.default)(\"hardhat:core:compilation-job\"); // this should have a proper version range when it's fixed\n\nconst SOLC_BUG_9573_VERSIONS = \"*\";\n\nfunction isCompilationJobCreationError(x) {\n  return \"reason\" in x;\n}\n\nclass CompilationJob {\n  constructor(solidityConfig) {\n    this.solidityConfig = solidityConfig;\n    this._filesToCompile = new Map();\n  }\n\n  addFileToCompile(file, emitsArtifacts) {\n    const fileToCompile = this._filesToCompile.get(file.sourceName); // if the file doesn't exist, we add it\n    // we also add it if emitsArtifacts is true, to override it in case it was\n    // previously added but with a false emitsArtifacts\n\n\n    if (fileToCompile === undefined || emitsArtifacts) {\n      this._filesToCompile.set(file.sourceName, {\n        file,\n        emitsArtifacts\n      });\n    }\n  }\n\n  hasSolc9573Bug() {\n    var _a, _b, _c;\n\n    return ((_c = (_b = (_a = this.solidityConfig) === null || _a === void 0 ? void 0 : _a.settings) === null || _b === void 0 ? void 0 : _b.optimizer) === null || _c === void 0 ? void 0 : _c.enabled) === true && semver_1.default.satisfies(this.solidityConfig.version, SOLC_BUG_9573_VERSIONS);\n  }\n\n  merge(job) {\n    const {\n      isEqual\n    } = require(\"lodash\");\n\n    (0, errors_1.assertHardhatInvariant)(isEqual(this.solidityConfig, job.getSolcConfig()), \"Merging jobs with different solidity configurations\");\n    const mergedJobs = new CompilationJob(job.getSolcConfig());\n\n    for (const file of this.getResolvedFiles()) {\n      mergedJobs.addFileToCompile(file, this.emitsArtifacts(file));\n    }\n\n    for (const file of job.getResolvedFiles()) {\n      mergedJobs.addFileToCompile(file, job.emitsArtifacts(file));\n    }\n\n    return mergedJobs;\n  }\n\n  getSolcConfig() {\n    return this.solidityConfig;\n  }\n\n  isEmpty() {\n    return this._filesToCompile.size === 0;\n  }\n\n  getResolvedFiles() {\n    return [...this._filesToCompile.values()].map(x => x.file);\n  }\n  /**\n   * Check if the given file emits artifacts.\n   *\n   * If no file is given, check if *some* file in the job emits artifacts.\n   */\n\n\n  emitsArtifacts(file) {\n    const fileToCompile = this._filesToCompile.get(file.sourceName);\n\n    (0, errors_1.assertHardhatInvariant)(fileToCompile !== undefined, `File '${file.sourceName}' does not exist in this compilation job`);\n    return fileToCompile.emitsArtifacts;\n  }\n\n}\n\nexports.CompilationJob = CompilationJob;\n\nfunction mergeCompilationJobs(jobs, isMergeable) {\n  const {\n    flatten\n  } = require(\"lodash\");\n\n  const jobsMap = new Map();\n\n  for (const job of jobs) {\n    const mergedJobs = jobsMap.get(job.getSolcConfig());\n\n    if (isMergeable(job)) {\n      if (mergedJobs === undefined) {\n        jobsMap.set(job.getSolcConfig(), [job]);\n      } else if (mergedJobs.length === 1) {\n        const newJob = mergedJobs[0].merge(job);\n        jobsMap.set(job.getSolcConfig(), [newJob]);\n      } else {\n        (0, errors_1.assertHardhatInvariant)(false, \"More than one mergeable job was added for the same configuration\");\n      }\n    } else {\n      if (mergedJobs === undefined) {\n        jobsMap.set(job.getSolcConfig(), [job]);\n      } else {\n        jobsMap.set(job.getSolcConfig(), [...mergedJobs, job]);\n      }\n    }\n  }\n\n  return flatten([...jobsMap.values()]);\n}\n/**\n * Creates a list of compilation jobs from a dependency graph. *This function\n * assumes that the given graph is a connected component*.\n * Returns the list of compilation jobs on success, and a list of\n * non-compilable files on failure.\n */\n\n\nasync function createCompilationJobsFromConnectedComponent(connectedComponent, getFromFile) {\n  const compilationJobs = [];\n  const errors = [];\n\n  for (const file of connectedComponent.getResolvedFiles()) {\n    const compilationJobOrError = await getFromFile(file);\n\n    if (isCompilationJobCreationError(compilationJobOrError)) {\n      log(`'${file.absolutePath}' couldn't be compiled. Reason: '${compilationJobOrError}'`);\n      errors.push(compilationJobOrError);\n      continue;\n    }\n\n    compilationJobs.push(compilationJobOrError);\n  }\n\n  const jobs = mergeCompilationJobsWithBug(compilationJobs);\n  return {\n    jobs,\n    errors\n  };\n}\n\nexports.createCompilationJobsFromConnectedComponent = createCompilationJobsFromConnectedComponent;\n\nasync function createCompilationJobFromFile(dependencyGraph, file, solidityConfig) {\n  const directDependencies = dependencyGraph.getDependencies(file);\n  const transitiveDependencies = dependencyGraph.getTransitiveDependencies(file);\n  const compilerConfig = getCompilerConfigForFile(file, directDependencies, transitiveDependencies, solidityConfig); // if the config cannot be obtained, we just return the failure\n\n  if (isCompilationJobCreationError(compilerConfig)) {\n    return compilerConfig;\n  }\n\n  log(`File '${file.absolutePath}' will be compiled with version '${compilerConfig.version}'`);\n  const compilationJob = new CompilationJob(compilerConfig);\n  compilationJob.addFileToCompile(file, true);\n\n  for (const {\n    dependency\n  } of transitiveDependencies) {\n    log(`File '${dependency.absolutePath}' added as dependency of '${file.absolutePath}'`);\n    compilationJob.addFileToCompile(dependency, false);\n  }\n\n  return compilationJob;\n}\n\nexports.createCompilationJobFromFile = createCompilationJobFromFile;\n/**\n * Merge compilation jobs affected by the solc #9573 bug\n */\n\nfunction mergeCompilationJobsWithBug(compilationJobs) {\n  return mergeCompilationJobs(compilationJobs, job => job.hasSolc9573Bug());\n}\n\nexports.mergeCompilationJobsWithBug = mergeCompilationJobsWithBug;\n/**\n * Merge compilation jobs not affected by the solc #9573 bug\n */\n\nfunction mergeCompilationJobsWithoutBug(compilationJobs) {\n  return mergeCompilationJobs(compilationJobs, job => !job.hasSolc9573Bug());\n}\n\nexports.mergeCompilationJobsWithoutBug = mergeCompilationJobsWithoutBug;\n/**\n * Return the compiler config with the newest version that satisfies the given\n * version ranges, or a value indicating why the compiler couldn't be obtained.\n */\n\nfunction getCompilerConfigForFile(file, directDependencies, transitiveDependencies, solidityConfig) {\n  var _a;\n\n  const {\n    uniq\n  } = require(\"lodash\");\n\n  const transitiveDependenciesVersionPragmas = transitiveDependencies.map(_ref => {\n    let {\n      dependency\n    } = _ref;\n    return dependency.content.versionPragmas;\n  });\n  const versionRange = uniq([...file.content.versionPragmas, ...transitiveDependenciesVersionPragmas]).join(\" \");\n  const overrides = (_a = solidityConfig.overrides) !== null && _a !== void 0 ? _a : {};\n  const overriddenCompiler = overrides[file.sourceName]; // if there's an override, we only check that\n\n  if (overriddenCompiler !== undefined) {\n    if (!semver_1.default.satisfies(overriddenCompiler.version, versionRange)) {\n      return getCompilationJobCreationError(file, directDependencies, transitiveDependencies, [overriddenCompiler.version], true);\n    }\n\n    return overriddenCompiler;\n  } // if there's no override, we find a compiler that matches the version range\n\n\n  const compilerVersions = solidityConfig.compilers.map(x => x.version);\n  const matchingVersion = semver_1.default.maxSatisfying(compilerVersions, versionRange);\n\n  if (matchingVersion === null) {\n    return getCompilationJobCreationError(file, directDependencies, transitiveDependencies, compilerVersions, false);\n  }\n\n  const matchingConfig = solidityConfig.compilers.find(x => x.version === matchingVersion);\n  return matchingConfig;\n}\n\nfunction getCompilationJobCreationError(file, directDependencies, transitiveDependencies, compilerVersions, overriden) {\n  const fileVersionRange = file.content.versionPragmas.join(\" \");\n\n  if (semver_1.default.maxSatisfying(compilerVersions, fileVersionRange) === null) {\n    const reason = overriden ? builtin_tasks_1.CompilationJobCreationErrorReason.INCOMPATIBLE_OVERRIDEN_SOLC_VERSION : builtin_tasks_1.CompilationJobCreationErrorReason.NO_COMPATIBLE_SOLC_VERSION_FOUND;\n    return {\n      reason,\n      file\n    };\n  }\n\n  const incompatibleDirectImports = [];\n\n  for (const dependency of directDependencies) {\n    const dependencyVersionRange = dependency.content.versionPragmas.join(\" \");\n\n    if (!semver_1.default.intersects(fileVersionRange, dependencyVersionRange)) {\n      incompatibleDirectImports.push(dependency);\n    }\n  }\n\n  if (incompatibleDirectImports.length > 0) {\n    return {\n      reason: builtin_tasks_1.CompilationJobCreationErrorReason.DIRECTLY_IMPORTS_INCOMPATIBLE_FILE,\n      file,\n      extra: {\n        incompatibleDirectImports\n      }\n    };\n  }\n\n  const incompatibleIndirectImports = [];\n\n  for (const transitiveDependency of transitiveDependencies) {\n    const {\n      dependency\n    } = transitiveDependency;\n    const dependencyVersionRange = dependency.content.versionPragmas.join(\" \");\n\n    if (!semver_1.default.intersects(fileVersionRange, dependencyVersionRange)) {\n      incompatibleIndirectImports.push(transitiveDependency);\n    }\n  }\n\n  if (incompatibleIndirectImports.length > 0) {\n    return {\n      reason: builtin_tasks_1.CompilationJobCreationErrorReason.INDIRECTLY_IMPORTS_INCOMPATIBLE_FILE,\n      file,\n      extra: {\n        incompatibleIndirectImports\n      }\n    };\n  }\n\n  return {\n    reason: builtin_tasks_1.CompilationJobCreationErrorReason.OTHER_ERROR,\n    file\n  };\n}","map":{"version":3,"mappings":"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","names":["log","SOLC_BUG_9573_VERSIONS","isCompilationJobCreationError","x","CompilationJob","constructor","solidityConfig","Map","addFileToCompile","file","emitsArtifacts","fileToCompile","_filesToCompile","get","sourceName","undefined","set","hasSolc9573Bug","_a","settings","_b","optimizer","_c","enabled","semver_1","satisfies","version","merge","job","isEqual","require","getSolcConfig","mergedJobs","getResolvedFiles","isEmpty","size","values","map","exports","mergeCompilationJobs","jobs","isMergeable","flatten","jobsMap","length","newJob","createCompilationJobsFromConnectedComponent","connectedComponent","getFromFile","compilationJobs","errors","compilationJobOrError","absolutePath","push","mergeCompilationJobsWithBug","createCompilationJobFromFile","dependencyGraph","directDependencies","getDependencies","transitiveDependencies","getTransitiveDependencies","compilerConfig","getCompilerConfigForFile","compilationJob","dependency","mergeCompilationJobsWithoutBug","uniq","transitiveDependenciesVersionPragmas","content","versionPragmas","versionRange","join","overrides","overriddenCompiler","getCompilationJobCreationError","compilerVersions","compilers","matchingVersion","maxSatisfying","matchingConfig","find","overriden","fileVersionRange","reason","builtin_tasks_1","INCOMPATIBLE_OVERRIDEN_SOLC_VERSION","NO_COMPATIBLE_SOLC_VERSION_FOUND","incompatibleDirectImports","dependencyVersionRange","intersects","DIRECTLY_IMPORTS_INCOMPATIBLE_FILE","extra","incompatibleIndirectImports","transitiveDependency","INDIRECTLY_IMPORTS_INCOMPATIBLE_FILE","OTHER_ERROR"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/internal/solidity/compilation-job.ts"],"sourcesContent":["import debug from \"debug\";\nimport type { LoDashStatic } from \"lodash\";\nimport semver from \"semver\";\n\nimport { SolcConfig, SolidityConfig } from \"../../types\";\nimport * as taskTypes from \"../../types/builtin-tasks\";\nimport {\n  CompilationJobCreationError,\n  CompilationJobCreationErrorReason,\n  CompilationJobsCreationResult,\n} from \"../../types/builtin-tasks\";\nimport { assertHardhatInvariant } from \"../core/errors\";\n\nimport { ResolvedFile } from \"./resolver\";\n\nconst log = debug(\"hardhat:core:compilation-job\");\n\n// this should have a proper version range when it's fixed\nconst SOLC_BUG_9573_VERSIONS = \"*\";\n\nfunction isCompilationJobCreationError(\n  x:\n    | taskTypes.CompilationJob\n    | taskTypes.CompilationJobCreationError\n    | SolcConfig\n): x is CompilationJobCreationError {\n  return \"reason\" in x;\n}\n\nexport class CompilationJob implements taskTypes.CompilationJob {\n  private _filesToCompile: Map<\n    string,\n    { file: ResolvedFile; emitsArtifacts: boolean }\n  > = new Map();\n\n  constructor(public solidityConfig: SolcConfig) {}\n\n  public addFileToCompile(file: ResolvedFile, emitsArtifacts: boolean) {\n    const fileToCompile = this._filesToCompile.get(file.sourceName);\n\n    // if the file doesn't exist, we add it\n    // we also add it if emitsArtifacts is true, to override it in case it was\n    // previously added but with a false emitsArtifacts\n    if (fileToCompile === undefined || emitsArtifacts) {\n      this._filesToCompile.set(file.sourceName, { file, emitsArtifacts });\n    }\n  }\n\n  public hasSolc9573Bug(): boolean {\n    return (\n      this.solidityConfig?.settings?.optimizer?.enabled === true &&\n      semver.satisfies(this.solidityConfig.version, SOLC_BUG_9573_VERSIONS)\n    );\n  }\n\n  public merge(job: taskTypes.CompilationJob): CompilationJob {\n    const { isEqual }: LoDashStatic = require(\"lodash\");\n    assertHardhatInvariant(\n      isEqual(this.solidityConfig, job.getSolcConfig()),\n      \"Merging jobs with different solidity configurations\"\n    );\n    const mergedJobs = new CompilationJob(job.getSolcConfig());\n    for (const file of this.getResolvedFiles()) {\n      mergedJobs.addFileToCompile(file, this.emitsArtifacts(file));\n    }\n    for (const file of job.getResolvedFiles()) {\n      mergedJobs.addFileToCompile(file, job.emitsArtifacts(file));\n    }\n    return mergedJobs;\n  }\n\n  public getSolcConfig(): SolcConfig {\n    return this.solidityConfig;\n  }\n\n  public isEmpty() {\n    return this._filesToCompile.size === 0;\n  }\n\n  public getResolvedFiles(): ResolvedFile[] {\n    return [...this._filesToCompile.values()].map((x) => x.file);\n  }\n\n  /**\n   * Check if the given file emits artifacts.\n   *\n   * If no file is given, check if *some* file in the job emits artifacts.\n   */\n  public emitsArtifacts(file: ResolvedFile): boolean {\n    const fileToCompile = this._filesToCompile.get(file.sourceName);\n\n    assertHardhatInvariant(\n      fileToCompile !== undefined,\n      `File '${file.sourceName}' does not exist in this compilation job`\n    );\n\n    return fileToCompile.emitsArtifacts;\n  }\n}\n\nfunction mergeCompilationJobs(\n  jobs: taskTypes.CompilationJob[],\n  isMergeable: (job: taskTypes.CompilationJob) => boolean\n): taskTypes.CompilationJob[] {\n  const { flatten }: LoDashStatic = require(\"lodash\");\n\n  const jobsMap: Map<SolcConfig, taskTypes.CompilationJob[]> = new Map();\n\n  for (const job of jobs) {\n    const mergedJobs = jobsMap.get(job.getSolcConfig());\n    if (isMergeable(job)) {\n      if (mergedJobs === undefined) {\n        jobsMap.set(job.getSolcConfig(), [job]);\n      } else if (mergedJobs.length === 1) {\n        const newJob = mergedJobs[0].merge(job);\n        jobsMap.set(job.getSolcConfig(), [newJob]);\n      } else {\n        assertHardhatInvariant(\n          false,\n          \"More than one mergeable job was added for the same configuration\"\n        );\n      }\n    } else {\n      if (mergedJobs === undefined) {\n        jobsMap.set(job.getSolcConfig(), [job]);\n      } else {\n        jobsMap.set(job.getSolcConfig(), [...mergedJobs, job]);\n      }\n    }\n  }\n\n  return flatten([...jobsMap.values()]);\n}\n\n/**\n * Creates a list of compilation jobs from a dependency graph. *This function\n * assumes that the given graph is a connected component*.\n * Returns the list of compilation jobs on success, and a list of\n * non-compilable files on failure.\n */\nexport async function createCompilationJobsFromConnectedComponent(\n  connectedComponent: taskTypes.DependencyGraph,\n  getFromFile: (\n    file: ResolvedFile\n  ) => Promise<taskTypes.CompilationJob | CompilationJobCreationError>\n): Promise<CompilationJobsCreationResult> {\n  const compilationJobs: taskTypes.CompilationJob[] = [];\n  const errors: CompilationJobCreationError[] = [];\n\n  for (const file of connectedComponent.getResolvedFiles()) {\n    const compilationJobOrError = await getFromFile(file);\n\n    if (isCompilationJobCreationError(compilationJobOrError)) {\n      log(\n        `'${file.absolutePath}' couldn't be compiled. Reason: '${compilationJobOrError}'`\n      );\n      errors.push(compilationJobOrError);\n      continue;\n    }\n\n    compilationJobs.push(compilationJobOrError);\n  }\n\n  const jobs = mergeCompilationJobsWithBug(compilationJobs);\n\n  return { jobs, errors };\n}\n\nexport async function createCompilationJobFromFile(\n  dependencyGraph: taskTypes.DependencyGraph,\n  file: ResolvedFile,\n  solidityConfig: SolidityConfig\n): Promise<CompilationJob | CompilationJobCreationError> {\n  const directDependencies = dependencyGraph.getDependencies(file);\n  const transitiveDependencies =\n    dependencyGraph.getTransitiveDependencies(file);\n\n  const compilerConfig = getCompilerConfigForFile(\n    file,\n    directDependencies,\n    transitiveDependencies,\n    solidityConfig\n  );\n\n  // if the config cannot be obtained, we just return the failure\n  if (isCompilationJobCreationError(compilerConfig)) {\n    return compilerConfig;\n  }\n  log(\n    `File '${file.absolutePath}' will be compiled with version '${compilerConfig.version}'`\n  );\n\n  const compilationJob = new CompilationJob(compilerConfig);\n\n  compilationJob.addFileToCompile(file, true);\n  for (const { dependency } of transitiveDependencies) {\n    log(\n      `File '${dependency.absolutePath}' added as dependency of '${file.absolutePath}'`\n    );\n    compilationJob.addFileToCompile(dependency, false);\n  }\n\n  return compilationJob;\n}\n\n/**\n * Merge compilation jobs affected by the solc #9573 bug\n */\nexport function mergeCompilationJobsWithBug(\n  compilationJobs: taskTypes.CompilationJob[]\n): taskTypes.CompilationJob[] {\n  return mergeCompilationJobs(compilationJobs, (job) => job.hasSolc9573Bug());\n}\n\n/**\n * Merge compilation jobs not affected by the solc #9573 bug\n */\nexport function mergeCompilationJobsWithoutBug(\n  compilationJobs: taskTypes.CompilationJob[]\n): taskTypes.CompilationJob[] {\n  return mergeCompilationJobs(compilationJobs, (job) => !job.hasSolc9573Bug());\n}\n\n/**\n * Return the compiler config with the newest version that satisfies the given\n * version ranges, or a value indicating why the compiler couldn't be obtained.\n */\nfunction getCompilerConfigForFile(\n  file: ResolvedFile,\n  directDependencies: ResolvedFile[],\n  transitiveDependencies: taskTypes.TransitiveDependency[],\n  solidityConfig: SolidityConfig\n): SolcConfig | CompilationJobCreationError {\n  const { uniq }: LoDashStatic = require(\"lodash\");\n\n  const transitiveDependenciesVersionPragmas = transitiveDependencies.map(\n    ({ dependency }) => dependency.content.versionPragmas\n  );\n  const versionRange = uniq([\n    ...file.content.versionPragmas,\n    ...transitiveDependenciesVersionPragmas,\n  ]).join(\" \");\n\n  const overrides = solidityConfig.overrides ?? {};\n\n  const overriddenCompiler = overrides[file.sourceName];\n\n  // if there's an override, we only check that\n  if (overriddenCompiler !== undefined) {\n    if (!semver.satisfies(overriddenCompiler.version, versionRange)) {\n      return getCompilationJobCreationError(\n        file,\n        directDependencies,\n        transitiveDependencies,\n        [overriddenCompiler.version],\n        true\n      );\n    }\n\n    return overriddenCompiler;\n  }\n\n  // if there's no override, we find a compiler that matches the version range\n  const compilerVersions = solidityConfig.compilers.map((x) => x.version);\n  const matchingVersion = semver.maxSatisfying(compilerVersions, versionRange);\n\n  if (matchingVersion === null) {\n    return getCompilationJobCreationError(\n      file,\n      directDependencies,\n      transitiveDependencies,\n      compilerVersions,\n      false\n    );\n  }\n\n  const matchingConfig = solidityConfig.compilers.find(\n    (x) => x.version === matchingVersion\n  )!;\n\n  return matchingConfig;\n}\n\nfunction getCompilationJobCreationError(\n  file: ResolvedFile,\n  directDependencies: ResolvedFile[],\n  transitiveDependencies: taskTypes.TransitiveDependency[],\n  compilerVersions: string[],\n  overriden: boolean\n): CompilationJobCreationError {\n  const fileVersionRange = file.content.versionPragmas.join(\" \");\n  if (semver.maxSatisfying(compilerVersions, fileVersionRange) === null) {\n    const reason = overriden\n      ? CompilationJobCreationErrorReason.INCOMPATIBLE_OVERRIDEN_SOLC_VERSION\n      : CompilationJobCreationErrorReason.NO_COMPATIBLE_SOLC_VERSION_FOUND;\n    return { reason, file };\n  }\n\n  const incompatibleDirectImports: ResolvedFile[] = [];\n  for (const dependency of directDependencies) {\n    const dependencyVersionRange = dependency.content.versionPragmas.join(\" \");\n    if (!semver.intersects(fileVersionRange, dependencyVersionRange)) {\n      incompatibleDirectImports.push(dependency);\n    }\n  }\n\n  if (incompatibleDirectImports.length > 0) {\n    return {\n      reason:\n        CompilationJobCreationErrorReason.DIRECTLY_IMPORTS_INCOMPATIBLE_FILE,\n      file,\n      extra: {\n        incompatibleDirectImports,\n      },\n    };\n  }\n\n  const incompatibleIndirectImports: taskTypes.TransitiveDependency[] = [];\n  for (const transitiveDependency of transitiveDependencies) {\n    const { dependency } = transitiveDependency;\n    const dependencyVersionRange = dependency.content.versionPragmas.join(\" \");\n    if (!semver.intersects(fileVersionRange, dependencyVersionRange)) {\n      incompatibleIndirectImports.push(transitiveDependency);\n    }\n  }\n\n  if (incompatibleIndirectImports.length > 0) {\n    return {\n      reason:\n        CompilationJobCreationErrorReason.INDIRECTLY_IMPORTS_INCOMPATIBLE_FILE,\n      file,\n      extra: {\n        incompatibleIndirectImports,\n      },\n    };\n  }\n\n  return { reason: CompilationJobCreationErrorReason.OTHER_ERROR, file };\n}\n"]},"metadata":{},"sourceType":"script"}