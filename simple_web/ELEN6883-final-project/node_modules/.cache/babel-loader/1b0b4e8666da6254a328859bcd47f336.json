{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ModulesLogger = void 0;\n\nconst ansi_escapes_1 = __importDefault(require(\"ansi-escapes\"));\n\nconst chalk_1 = __importDefault(require(\"chalk\"));\n\nconst ethereumjs_util_1 = require(\"ethereumjs-util\");\n\nconst util_1 = __importDefault(require(\"util\"));\n\nconst errors_1 = require(\"../../../core/errors\");\n\nconst errors_2 = require(\"../../../core/providers/errors\");\n\nconst wei_values_1 = require(\"../../../util/wei-values\");\n\nconst message_trace_1 = require(\"../../stack-traces/message-trace\");\n\nconst model_1 = require(\"../../stack-traces/model\");\n\nconst solidity_errors_1 = require(\"../../stack-traces/solidity-errors\");\n\nconst solidity_stack_trace_1 = require(\"../../stack-traces/solidity-stack-trace\");\n\nfunction printLine(line) {\n  console.log(line);\n}\n\nfunction replaceLastLine(newLine) {\n  if (process.stdout.isTTY === true) {\n    process.stdout.write( // eslint-disable-next-line prefer-template\n    ansi_escapes_1.default.cursorHide + ansi_escapes_1.default.cursorPrevLine + newLine + ansi_escapes_1.default.eraseEndLine + \"\\n\" + ansi_escapes_1.default.cursorShow);\n  } else {\n    process.stdout.write(`${newLine}\\n`);\n  }\n}\n/**\n * Handles all the logging made from the Hardhat Network.\n *\n * Methods of this class follow this convention:\n * - Methods that start with `log` add those messages to a list of things to log\n * - Methods that start with `print` print to stdout immediately\n */\n\n\nclass ModulesLogger {\n  constructor(_enabled) {\n    let _printLine = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : printLine;\n\n    let _replaceLastLine = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : replaceLastLine;\n\n    this._enabled = _enabled;\n    this._printLine = _printLine;\n    this._replaceLastLine = _replaceLastLine;\n    this._logs = [];\n    this._titleLength = 0;\n    this._currentIndent = 0;\n    this._emptyMinedBlocksRangeStart = undefined;\n    this._methodCollapsedCount = 0;\n  }\n\n  isEnabled() {\n    return this._enabled;\n  }\n\n  setEnabled(enabled) {\n    this._enabled = enabled;\n  }\n\n  isLoggedError(err) {\n    return err instanceof solidity_errors_1.SolidityError || err instanceof errors_2.TransactionExecutionError;\n  }\n\n  logBlockFromAutomine(result, codes, txHashToHighlight) {\n    const {\n      block,\n      blockResult,\n      traces\n    } = result;\n    const {\n      results\n    } = blockResult;\n    (0, errors_1.assertHardhatInvariant)(results.length === codes.length, \"The array of codes should have the same length as the array of results\");\n\n    this._indent(() => {\n      this._logBlockNumber(block);\n\n      this._indent(() => {\n        this._logBaseFeePerGas(block);\n\n        for (let i = 0; i < block.transactions.length; i++) {\n          const tx = block.transactions[i];\n          const txGasUsed = results[i].gasUsed.toNumber();\n          const txTrace = traces[i];\n          const code = codes[i];\n          const highlightTxHash = tx.hash().equals(txHashToHighlight);\n\n          this._logTxInsideBlock(tx, txTrace, code, txGasUsed, {\n            highlightTxHash\n          });\n\n          this._logEmptyLineBetweenTransactions(i, block.transactions.length);\n        }\n      });\n    });\n  }\n\n  logMinedBlock(result, codes) {\n    const {\n      block,\n      blockResult,\n      traces\n    } = result;\n    const {\n      results\n    } = blockResult;\n    (0, errors_1.assertHardhatInvariant)(results.length === codes.length, \"The array of codes should have the same length as the array of results\");\n    const blockNumber = result.block.header.number.toNumber();\n    const isEmpty = result.block.transactions.length === 0;\n\n    this._indent(() => {\n      this.logMinedBlockNumber(blockNumber, isEmpty, block.header.baseFeePerGas);\n\n      if (isEmpty) {\n        return;\n      }\n\n      this._indent(() => {\n        this._logBlockHash(block);\n\n        this._indent(() => {\n          this._logBaseFeePerGas(block);\n\n          for (let i = 0; i < block.transactions.length; i++) {\n            const tx = block.transactions[i];\n            const txGasUsed = results[i].gasUsed.toNumber();\n            const txTrace = traces[i];\n            const code = codes[i];\n\n            this._logTxInsideBlock(tx, txTrace, code, txGasUsed, {\n              highlightTxHash: false\n            });\n\n            this._logEmptyLineBetweenTransactions(i, block.transactions.length);\n          }\n        });\n      });\n    });\n  }\n\n  logIntervalMinedBlock(result, codes) {\n    const {\n      block,\n      blockResult,\n      traces\n    } = result;\n    const {\n      results\n    } = blockResult;\n    (0, errors_1.assertHardhatInvariant)(results.length === codes.length, \"The array of codes should have the same length as the array of results\");\n\n    this._indent(() => {\n      this._logBlockHash(block);\n\n      this._indent(() => {\n        this._logBaseFeePerGas(block);\n\n        for (let i = 0; i < block.transactions.length; i++) {\n          const tx = block.transactions[i];\n          const txGasUsed = results[i].gasUsed.toNumber();\n          const txTrace = traces[i];\n          const code = codes[i];\n\n          this._logTxInsideBlock(tx, txTrace, code, txGasUsed, {\n            highlightTxHash: false\n          });\n\n          this._logEmptyLineBetweenTransactions(i, block.transactions.length);\n        }\n      });\n    });\n  }\n\n  logSingleTransaction(tx, block, txGasUsed, txTrace, code) {\n    this._indent(() => {\n      var _a;\n\n      this._logContractAndFunctionName(txTrace.trace, code);\n\n      const txHash = (0, ethereumjs_util_1.bufferToHex)(tx.hash());\n\n      this._logWithTitle(\"Transaction\", txHash);\n\n      this._logTxFrom(tx.getSenderAddress().toBuffer());\n\n      this._logTxTo((_a = tx.to) === null || _a === void 0 ? void 0 : _a.toBuffer(), txTrace.trace);\n\n      this._logTxValue(new ethereumjs_util_1.BN(tx.value));\n\n      this._logWithTitle(\"Gas used\", `${txGasUsed} of ${tx.gasLimit.toNumber()}`);\n\n      this._logWithTitle(`Block #${block.header.number.toNumber()}`, (0, ethereumjs_util_1.bufferToHex)(block.hash()));\n\n      this._logConsoleLogMessages(txTrace.consoleLogMessages);\n\n      if (txTrace.error !== undefined) {\n        this._logError(txTrace.error);\n      }\n    });\n  }\n\n  logCurrentlySentTransaction(tx, txGasUsed, txTrace, code, block) {\n    this._indent(() => {\n      var _a;\n\n      this._log(\"Currently sent transaction:\");\n\n      this.logEmptyLine();\n\n      this._logContractAndFunctionName(txTrace.trace, code);\n\n      const txHash = (0, ethereumjs_util_1.bufferToHex)(tx.hash());\n\n      this._logWithTitle(\"Transaction\", txHash);\n\n      this._logTxFrom(tx.getSenderAddress().toBuffer());\n\n      this._logTxTo((_a = tx.to) === null || _a === void 0 ? void 0 : _a.toBuffer(), txTrace.trace);\n\n      this._logTxValue(new ethereumjs_util_1.BN(tx.value));\n\n      this._logWithTitle(\"Gas used\", `${txGasUsed} of ${tx.gasLimit.toNumber()}`);\n\n      this._logWithTitle(`Block #${block.header.number.toNumber()}`, (0, ethereumjs_util_1.bufferToHex)(block.hash()));\n\n      this._logConsoleLogMessages(txTrace.consoleLogMessages);\n\n      if (txTrace.error !== undefined) {\n        this._logError(txTrace.error);\n      }\n    });\n  }\n\n  logEstimateGasTrace(callParams, code, trace, consoleLogMessages, error) {\n    this._indent(() => {\n      this._logContractAndFunctionName(trace, code, {\n        printNonContractCalled: true\n      });\n\n      this._logTxFrom(callParams.from);\n\n      this._logTxTo(callParams.to, trace);\n\n      this._logTxValue(new ethereumjs_util_1.BN(callParams.value));\n\n      this._logConsoleLogMessages(consoleLogMessages);\n\n      this._logError(error);\n    });\n  }\n\n  logCallTrace(callParams, code, trace, consoleLogMessages, error) {\n    this._indent(() => {\n      this._logContractAndFunctionName(trace, code, {\n        printNonContractCalled: true\n      });\n\n      this._logTxFrom(callParams.from);\n\n      this._logTxTo(callParams.to, trace);\n\n      if (callParams.value.gtn(0)) {\n        this._logTxValue(callParams.value);\n      }\n\n      this._logConsoleLogMessages(consoleLogMessages);\n\n      if (error !== undefined) {\n        // TODO: If throwOnCallFailures is false, this will log the error, but the RPC method won't be red\n        this._logError(error);\n      }\n    });\n  }\n\n  logMinedBlockNumber(blockNumber, isEmpty, baseFeePerGas) {\n    if (isEmpty) {\n      this._log(`Mined empty block #${blockNumber}${baseFeePerGas !== undefined ? ` with base fee ${baseFeePerGas}` : \"\"}`);\n\n      return;\n    }\n\n    this._log(`Mined block #${blockNumber}`);\n  }\n\n  logMultipleTransactionsWarning() {\n    this._indent(() => {\n      this._log(\"There were other pending transactions mined in the same block:\");\n    });\n\n    this.logEmptyLine();\n  }\n\n  logMultipleBlocksWarning() {\n    this._indent(() => {\n      this._log(\"There were other pending transactions. More than one block had to be mined:\");\n    });\n\n    this.logEmptyLine();\n  }\n\n  logEmptyLine() {\n    this._log(\"\");\n  }\n\n  _logBaseFeePerGas(block) {\n    if (block.header.baseFeePerGas !== undefined) {\n      this._log(`Base fee: ${block.header.baseFeePerGas}`);\n    }\n  }\n\n  printErrorMessage(errorMessage) {\n    this._indent(() => {\n      this._print(errorMessage);\n    });\n  }\n\n  printFailedMethod(method) {\n    this._print(method, {\n      color: chalk_1.default.red\n    });\n  }\n  /**\n   * Print all accumulated logs\n   */\n\n\n  printLogs() {\n    const logs = this._getLogs();\n\n    if (logs.length === 0) {\n      return false;\n    }\n\n    for (const msg of logs) {\n      this._print(msg);\n    }\n\n    this._clearLogs();\n\n    return true;\n  }\n\n  printMinedBlockNumber(blockNumber, isEmpty, baseFeePerGas) {\n    if (this._emptyMinedBlocksRangeStart !== undefined) {\n      this._print(`Mined empty block range #${this._emptyMinedBlocksRangeStart} to #${blockNumber}`, {\n        collapseMinedBlock: true,\n        replaceLastLine: true\n      });\n    } else {\n      this._emptyMinedBlocksRangeStart = blockNumber;\n\n      if (isEmpty) {\n        this._print(`Mined empty block #${blockNumber}${baseFeePerGas !== undefined ? ` with base fee ${baseFeePerGas}` : \"\"}`, {\n          collapseMinedBlock: true\n        });\n\n        return;\n      }\n\n      this._print(`Mined block #${blockNumber}`, {\n        collapseMinedBlock: true\n      });\n    }\n  }\n\n  printMetaMaskWarning() {\n    const message = \"If you are using MetaMask, you can learn how to fix this error here: https://hardhat.org/metamask-issue\";\n\n    this._indent(() => {\n      this._print(message, {\n        color: chalk_1.default.yellow\n      });\n    });\n  }\n\n  printMethod(method) {\n    if (this._shouldCollapseMethod(method)) {\n      this._methodCollapsedCount += 1;\n\n      this._print(chalk_1.default.green(`${method} (${this._methodCollapsedCount})`), {\n        collapsePrintedMethod: true,\n        replaceLastLine: true\n      });\n    } else {\n      this._startCollapsingMethod(method);\n\n      this._print(method, {\n        color: chalk_1.default.green,\n        collapsePrintedMethod: true\n      });\n    }\n  }\n\n  printMethodNotSupported(method) {\n    this._print(`${method} - Method not supported`, {\n      color: chalk_1.default.red\n    });\n  }\n\n  printEmptyLine() {\n    this._print(\"\");\n  }\n\n  printUnknownError(err) {\n    this._indent(() => {\n      this._printError(err);\n\n      this.printEmptyLine();\n\n      this._print(\"If you think this is a bug in Hardhat, please report it here: https://hardhat.org/reportbug\");\n    });\n  }\n\n  _format(msg) {\n    let {\n      color\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (msg === \"\") {\n      // don't indent empty lines\n      return msg;\n    }\n\n    if (this._currentIndent > 0) {\n      msg = msg.split(\"\\n\").map(line => \" \".repeat(this._currentIndent) + line).join(\"\\n\");\n    }\n\n    if (color !== undefined) {\n      return color(msg);\n    }\n\n    return msg;\n  }\n\n  _indent(cb) {\n    let enabled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (enabled) {\n      this._currentIndent += 2;\n    }\n\n    try {\n      return cb();\n    } finally {\n      if (enabled) {\n        this._currentIndent -= 2;\n      }\n    }\n  }\n\n  _indentSingleLine(message) {\n    return \" \".repeat(this._currentIndent) + message;\n  }\n\n  _log(msg) {\n    let printOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (printOptions.collapsePrintedMethod !== true) {\n      this._stopCollapsingMethod();\n    }\n\n    if (printOptions.collapseMinedBlock !== true) {\n      this._emptyMinedBlocksRangeStart = undefined;\n    }\n\n    const formattedMessage = this._format(msg, printOptions);\n\n    this._logs.push(formattedMessage);\n  }\n\n  _logError(err) {\n    if (this.isLoggedError(err)) {\n      this.logEmptyLine();\n\n      this._log(util_1.default.inspect(err));\n    }\n  }\n\n  _logTxInsideBlock(tx, txTrace, code, txGasUsed, _ref) {\n    let {\n      highlightTxHash\n    } = _ref;\n    // indentAfterTransactionHash: true,\n    // printTxBlockNumber: false,\n    // startWithTxHash: true,\n    let txHash = (0, ethereumjs_util_1.bufferToHex)(tx.hash());\n\n    if (highlightTxHash) {\n      txHash = chalk_1.default.bold(txHash);\n    }\n\n    this._logWithTitle(\"Transaction\", txHash);\n\n    this._indent(() => {\n      var _a;\n\n      this._logContractAndFunctionName(txTrace.trace, code);\n\n      this._logTxFrom(tx.getSenderAddress().toBuffer());\n\n      this._logTxTo((_a = tx.to) === null || _a === void 0 ? void 0 : _a.toBuffer(), txTrace.trace);\n\n      this._logTxValue(new ethereumjs_util_1.BN(tx.value));\n\n      this._logWithTitle(\"Gas used\", `${txGasUsed} of ${tx.gasLimit.toNumber()}`);\n\n      this._logConsoleLogMessages(txTrace.consoleLogMessages);\n\n      if (txTrace.error !== undefined) {\n        this._logError(txTrace.error);\n      }\n    });\n  }\n  /**\n   *  This should be the only function that calls _printLine and\n   *  _replaceLastLine (except for the special console.sol case),\n   *  because it's the only function that checks if the logger\n   *  is enabled.\n   */\n\n\n  _print(msg) {\n    let printOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!this._enabled) {\n      return;\n    }\n\n    if (printOptions.collapsePrintedMethod !== true) {\n      this._stopCollapsingMethod();\n    }\n\n    if (printOptions.collapseMinedBlock !== true) {\n      this._emptyMinedBlocksRangeStart = undefined;\n    }\n\n    const formattedMessage = this._format(msg, printOptions);\n\n    if (printOptions.replaceLastLine === true) {\n      this._replaceLastLine(formattedMessage);\n    } else {\n      this._printLine(formattedMessage);\n    }\n  }\n\n  _printError(err) {\n    if (this.isLoggedError(err)) {\n      this.printEmptyLine();\n\n      this._print(util_1.default.inspect(err));\n    }\n  }\n\n  _logContractAndFunctionName(trace, code) {\n    let {\n      printNonContractCalled = false\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (trace === undefined) {\n      return;\n    }\n\n    if ((0, message_trace_1.isPrecompileTrace)(trace)) {\n      this._logWithTitle(\"Precompile call\", `<PrecompileContract ${trace.precompile}>`);\n\n      return;\n    }\n\n    if ((0, message_trace_1.isCreateTrace)(trace)) {\n      if (trace.bytecode === undefined) {\n        this._logWithTitle(\"Contract deployment\", solidity_stack_trace_1.UNRECOGNIZED_CONTRACT_NAME);\n      } else {\n        this._logWithTitle(\"Contract deployment\", trace.bytecode.contract.name);\n      }\n\n      if (trace.deployedContract !== undefined && trace.error === undefined) {\n        this._logWithTitle(\"Contract address\", (0, ethereumjs_util_1.bufferToHex)(trace.deployedContract));\n      }\n\n      return;\n    }\n\n    if (code.length === 0) {\n      if (printNonContractCalled) {\n        this._log(`WARNING: Calling an account which is not a contract`);\n      }\n\n      return;\n    }\n\n    if (trace.bytecode === undefined) {\n      this._logWithTitle(\"Contract call\", solidity_stack_trace_1.UNRECOGNIZED_CONTRACT_NAME);\n\n      return;\n    }\n\n    const func = trace.bytecode.contract.getFunctionFromSelector(trace.calldata.slice(0, 4));\n    const functionName = func === undefined ? solidity_stack_trace_1.UNRECOGNIZED_FUNCTION_NAME : func.type === model_1.ContractFunctionType.FALLBACK ? solidity_stack_trace_1.FALLBACK_FUNCTION_NAME : func.type === model_1.ContractFunctionType.RECEIVE ? solidity_stack_trace_1.RECEIVE_FUNCTION_NAME : func.name;\n\n    this._logWithTitle(\"Contract call\", `${trace.bytecode.contract.name}#${functionName}`);\n  }\n\n  _shouldCollapseMethod(method) {\n    return method === this._methodBeingCollapsed && !this._hasLogs() && this._methodCollapsedCount > 0;\n  }\n\n  _startCollapsingMethod(method) {\n    this._methodBeingCollapsed = method;\n    this._methodCollapsedCount = 1;\n  }\n\n  _stopCollapsingMethod() {\n    this._methodBeingCollapsed = undefined;\n    this._methodCollapsedCount = 0;\n  }\n\n  _logTxTo(to, trace) {\n    if (trace !== undefined && (0, message_trace_1.isCreateTrace)(trace)) {\n      return;\n    }\n\n    if (to === undefined) {\n      // only for the type-checker, since `to` is undefined only when\n      // the message is a create trace\n      return;\n    }\n\n    const toString = (0, ethereumjs_util_1.bufferToHex)(to);\n\n    this._logWithTitle(\"To\", toString);\n  }\n\n  _logTxValue(value) {\n    this._logWithTitle(\"Value\", (0, wei_values_1.weiToHumanReadableString)(value));\n  }\n\n  _logTxFrom(from) {\n    this._logWithTitle(\"From\", (0, ethereumjs_util_1.bufferToHex)(from));\n  }\n\n  _logBlockNumber(block) {\n    this._log(`Block #${block.header.number.toNumber()}: ${(0, ethereumjs_util_1.bufferToHex)(block.hash())}`);\n  }\n\n  _logEmptyLineBetweenTransactions(currentIndex, totalTransactions) {\n    if (currentIndex + 1 < totalTransactions && totalTransactions > 1) {\n      this.logEmptyLine();\n    }\n  }\n\n  _logBlockHash(block) {\n    this._log(`Block: ${(0, ethereumjs_util_1.bufferToHex)(block.hash())}`);\n  }\n\n  _logConsoleLogMessages(messages) {\n    // This is a especial case, as we always want to print the console.log\n    // messages. The difference is how.\n    // If we have a logger, we should use that, so that logs are printed in\n    // order. If we don't, we just print the messages here.\n    if (!this._enabled) {\n      for (const msg of messages) {\n        this._printLine(msg);\n      }\n\n      return;\n    }\n\n    if (messages.length === 0) {\n      return;\n    }\n\n    this.logEmptyLine();\n\n    this._log(\"console.log:\");\n\n    for (const msg of messages) {\n      this._log(`  ${msg}`);\n    }\n  }\n\n  _logWithTitle(title, message) {\n    title = this._indentSingleLine(title); // We always use the max title length we've seen. Otherwise the value move\n    // a lot with each tx/call.\n\n    if (title.length > this._titleLength) {\n      this._titleLength = title.length;\n    }\n\n    this._logs.push([title, message]);\n  }\n\n  _clearLogs() {\n    this._logs = [];\n  }\n\n  _hasLogs() {\n    return this._logs.length > 0;\n  }\n\n  _getLogs() {\n    return this._logs.map(l => {\n      if (typeof l === \"string\") {\n        return l;\n      }\n\n      const title = `${l[0]}:`;\n      return `${title.padEnd(this._titleLength + 1)} ${l[1]}`;\n    });\n  }\n\n}\n\nexports.ModulesLogger = ModulesLogger;","map":{"version":3,"mappings":"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","names":["printLine","line","console","log","replaceLastLine","newLine","process","stdout","isTTY","write","ansi_escapes_1","cursorHide","cursorPrevLine","eraseEndLine","cursorShow","ModulesLogger","constructor","_enabled","_printLine","_replaceLastLine","undefined","isEnabled","setEnabled","enabled","isLoggedError","err","solidity_errors_1","errors_2","logBlockFromAutomine","result","codes","txHashToHighlight","block","blockResult","traces","results","length","_indent","_logBlockNumber","_logBaseFeePerGas","i","transactions","tx","txGasUsed","gasUsed","toNumber","txTrace","code","highlightTxHash","hash","equals","_logTxInsideBlock","_logEmptyLineBetweenTransactions","logMinedBlock","blockNumber","header","number","isEmpty","logMinedBlockNumber","baseFeePerGas","_logBlockHash","logIntervalMinedBlock","logSingleTransaction","_logContractAndFunctionName","trace","txHash","_logWithTitle","_logTxFrom","getSenderAddress","toBuffer","_logTxTo","to","_a","_logTxValue","ethereumjs_util_1","value","gasLimit","_logConsoleLogMessages","consoleLogMessages","error","_logError","logCurrentlySentTransaction","_log","logEmptyLine","logEstimateGasTrace","callParams","printNonContractCalled","from","logCallTrace","gtn","logMultipleTransactionsWarning","logMultipleBlocksWarning","printErrorMessage","errorMessage","_print","printFailedMethod","method","color","chalk_1","red","printLogs","logs","_getLogs","msg","_clearLogs","printMinedBlockNumber","_emptyMinedBlocksRangeStart","collapseMinedBlock","printMetaMaskWarning","message","yellow","printMethod","_shouldCollapseMethod","_methodCollapsedCount","green","collapsePrintedMethod","_startCollapsingMethod","printMethodNotSupported","printEmptyLine","printUnknownError","_printError","_format","_currentIndent","split","map","repeat","join","cb","_indentSingleLine","printOptions","_stopCollapsingMethod","formattedMessage","_logs","push","util_1","inspect","bold","precompile","bytecode","solidity_stack_trace_1","contract","name","deployedContract","func","getFunctionFromSelector","calldata","slice","functionName","type","model_1","FALLBACK","RECEIVE","_methodBeingCollapsed","_hasLogs","toString","currentIndex","totalTransactions","messages","title","_titleLength","l","padEnd","exports"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/internal/hardhat-network/provider/modules/logger.ts"],"sourcesContent":["import { Block } from \"@ethereumjs/block\";\nimport { TypedTransaction } from \"@ethereumjs/tx\";\nimport ansiEscapes from \"ansi-escapes\";\nimport chalk, { Chalk } from \"chalk\";\nimport { BN, bufferToHex } from \"ethereumjs-util\";\nimport util from \"util\";\n\nimport { assertHardhatInvariant } from \"../../../core/errors\";\nimport { TransactionExecutionError } from \"../../../core/providers/errors\";\nimport { weiToHumanReadableString } from \"../../../util/wei-values\";\nimport {\n  isCreateTrace,\n  isPrecompileTrace,\n  MessageTrace,\n} from \"../../stack-traces/message-trace\";\nimport { ContractFunctionType } from \"../../stack-traces/model\";\nimport { SolidityError } from \"../../stack-traces/solidity-errors\";\nimport {\n  FALLBACK_FUNCTION_NAME,\n  RECEIVE_FUNCTION_NAME,\n  UNRECOGNIZED_CONTRACT_NAME,\n  UNRECOGNIZED_FUNCTION_NAME,\n} from \"../../stack-traces/solidity-stack-trace\";\nimport { CallParams, GatherTracesResult, MineBlockResult } from \"../node-types\";\n\ninterface PrintOptions {\n  color?: Chalk;\n  replaceLastLine?: boolean;\n  collapsePrintedMethod?: boolean;\n  collapseMinedBlock?: boolean;\n}\n\nfunction printLine(line: string) {\n  console.log(line);\n}\n\nfunction replaceLastLine(newLine: string) {\n  if (process.stdout.isTTY === true) {\n    process.stdout.write(\n      // eslint-disable-next-line prefer-template\n      ansiEscapes.cursorHide +\n        ansiEscapes.cursorPrevLine +\n        newLine +\n        ansiEscapes.eraseEndLine +\n        \"\\n\" +\n        ansiEscapes.cursorShow\n    );\n  } else {\n    process.stdout.write(`${newLine}\\n`);\n  }\n}\n\n/**\n * Handles all the logging made from the Hardhat Network.\n *\n * Methods of this class follow this convention:\n * - Methods that start with `log` add those messages to a list of things to log\n * - Methods that start with `print` print to stdout immediately\n */\nexport class ModulesLogger {\n  private _logs: Array<string | [string, string]> = [];\n  private _titleLength = 0;\n  private _currentIndent = 0;\n  private _emptyMinedBlocksRangeStart: number | undefined = undefined;\n  private _methodBeingCollapsed?: string;\n  private _methodCollapsedCount: number = 0;\n\n  constructor(\n    private _enabled: boolean,\n    private _printLine = printLine,\n    private _replaceLastLine = replaceLastLine\n  ) {}\n\n  public isEnabled() {\n    return this._enabled;\n  }\n\n  public setEnabled(enabled: boolean) {\n    this._enabled = enabled;\n  }\n\n  public isLoggedError(err: Error) {\n    return (\n      err instanceof SolidityError || err instanceof TransactionExecutionError\n    );\n  }\n\n  public logBlockFromAutomine(\n    result: MineBlockResult,\n    codes: Buffer[],\n    txHashToHighlight: Buffer\n  ) {\n    const { block, blockResult, traces } = result;\n    const { results } = blockResult;\n\n    assertHardhatInvariant(\n      results.length === codes.length,\n      \"The array of codes should have the same length as the array of results\"\n    );\n\n    this._indent(() => {\n      this._logBlockNumber(block);\n\n      this._indent(() => {\n        this._logBaseFeePerGas(block);\n\n        for (let i = 0; i < block.transactions.length; i++) {\n          const tx = block.transactions[i];\n          const txGasUsed = results[i].gasUsed.toNumber();\n          const txTrace = traces[i];\n          const code = codes[i];\n\n          const highlightTxHash = tx.hash().equals(txHashToHighlight);\n\n          this._logTxInsideBlock(tx, txTrace, code, txGasUsed, {\n            highlightTxHash,\n          });\n\n          this._logEmptyLineBetweenTransactions(i, block.transactions.length);\n        }\n      });\n    });\n  }\n\n  public logMinedBlock(result: MineBlockResult, codes: Buffer[]) {\n    const { block, blockResult, traces } = result;\n    const { results } = blockResult;\n\n    assertHardhatInvariant(\n      results.length === codes.length,\n      \"The array of codes should have the same length as the array of results\"\n    );\n\n    const blockNumber = result.block.header.number.toNumber();\n    const isEmpty = result.block.transactions.length === 0;\n\n    this._indent(() => {\n      this.logMinedBlockNumber(\n        blockNumber,\n        isEmpty,\n        block.header.baseFeePerGas\n      );\n\n      if (isEmpty) {\n        return;\n      }\n\n      this._indent(() => {\n        this._logBlockHash(block);\n\n        this._indent(() => {\n          this._logBaseFeePerGas(block);\n\n          for (let i = 0; i < block.transactions.length; i++) {\n            const tx = block.transactions[i];\n            const txGasUsed = results[i].gasUsed.toNumber();\n            const txTrace = traces[i];\n            const code = codes[i];\n\n            this._logTxInsideBlock(tx, txTrace, code, txGasUsed, {\n              highlightTxHash: false,\n            });\n\n            this._logEmptyLineBetweenTransactions(i, block.transactions.length);\n          }\n        });\n      });\n    });\n  }\n\n  public logIntervalMinedBlock(result: MineBlockResult, codes: Buffer[]) {\n    const { block, blockResult, traces } = result;\n    const { results } = blockResult;\n\n    assertHardhatInvariant(\n      results.length === codes.length,\n      \"The array of codes should have the same length as the array of results\"\n    );\n\n    this._indent(() => {\n      this._logBlockHash(block);\n\n      this._indent(() => {\n        this._logBaseFeePerGas(block);\n\n        for (let i = 0; i < block.transactions.length; i++) {\n          const tx = block.transactions[i];\n          const txGasUsed = results[i].gasUsed.toNumber();\n          const txTrace = traces[i];\n          const code = codes[i];\n\n          this._logTxInsideBlock(tx, txTrace, code, txGasUsed, {\n            highlightTxHash: false,\n          });\n\n          this._logEmptyLineBetweenTransactions(i, block.transactions.length);\n        }\n      });\n    });\n  }\n\n  public logSingleTransaction(\n    tx: TypedTransaction,\n    block: Block,\n    txGasUsed: number,\n    txTrace: GatherTracesResult,\n    code: Buffer\n  ) {\n    this._indent(() => {\n      this._logContractAndFunctionName(txTrace.trace, code);\n\n      const txHash = bufferToHex(tx.hash());\n\n      this._logWithTitle(\"Transaction\", txHash);\n\n      this._logTxFrom(tx.getSenderAddress().toBuffer());\n      this._logTxTo(tx.to?.toBuffer(), txTrace.trace);\n      this._logTxValue(new BN(tx.value));\n      this._logWithTitle(\n        \"Gas used\",\n        `${txGasUsed} of ${tx.gasLimit.toNumber()}`\n      );\n\n      this._logWithTitle(\n        `Block #${block.header.number.toNumber()}`,\n        bufferToHex(block.hash())\n      );\n\n      this._logConsoleLogMessages(txTrace.consoleLogMessages);\n\n      if (txTrace.error !== undefined) {\n        this._logError(txTrace.error);\n      }\n    });\n  }\n\n  public logCurrentlySentTransaction(\n    tx: TypedTransaction,\n    txGasUsed: number,\n    txTrace: GatherTracesResult,\n    code: Buffer,\n    block: Block\n  ) {\n    this._indent(() => {\n      this._log(\"Currently sent transaction:\");\n      this.logEmptyLine();\n\n      this._logContractAndFunctionName(txTrace.trace, code);\n\n      const txHash = bufferToHex(tx.hash());\n\n      this._logWithTitle(\"Transaction\", txHash);\n\n      this._logTxFrom(tx.getSenderAddress().toBuffer());\n      this._logTxTo(tx.to?.toBuffer(), txTrace.trace);\n      this._logTxValue(new BN(tx.value));\n      this._logWithTitle(\n        \"Gas used\",\n        `${txGasUsed} of ${tx.gasLimit.toNumber()}`\n      );\n\n      this._logWithTitle(\n        `Block #${block.header.number.toNumber()}`,\n        bufferToHex(block.hash())\n      );\n\n      this._logConsoleLogMessages(txTrace.consoleLogMessages);\n\n      if (txTrace.error !== undefined) {\n        this._logError(txTrace.error);\n      }\n    });\n  }\n\n  public logEstimateGasTrace(\n    callParams: CallParams,\n    code: Buffer,\n    trace: MessageTrace | undefined,\n    consoleLogMessages: string[],\n    error: Error\n  ) {\n    this._indent(() => {\n      this._logContractAndFunctionName(trace, code, {\n        printNonContractCalled: true,\n      });\n\n      this._logTxFrom(callParams.from);\n      this._logTxTo(callParams.to, trace);\n      this._logTxValue(new BN(callParams.value));\n\n      this._logConsoleLogMessages(consoleLogMessages);\n\n      this._logError(error);\n    });\n  }\n\n  public logCallTrace(\n    callParams: CallParams,\n    code: Buffer,\n    trace: MessageTrace | undefined,\n    consoleLogMessages: string[],\n    error: Error | undefined\n  ) {\n    this._indent(() => {\n      this._logContractAndFunctionName(trace, code, {\n        printNonContractCalled: true,\n      });\n\n      this._logTxFrom(callParams.from);\n      this._logTxTo(callParams.to, trace);\n      if (callParams.value.gtn(0)) {\n        this._logTxValue(callParams.value);\n      }\n\n      this._logConsoleLogMessages(consoleLogMessages);\n\n      if (error !== undefined) {\n        // TODO: If throwOnCallFailures is false, this will log the error, but the RPC method won't be red\n        this._logError(error);\n      }\n    });\n  }\n\n  public logMinedBlockNumber(\n    blockNumber: number,\n    isEmpty: boolean,\n    baseFeePerGas?: BN\n  ) {\n    if (isEmpty) {\n      this._log(\n        `Mined empty block #${blockNumber}${\n          baseFeePerGas !== undefined ? ` with base fee ${baseFeePerGas}` : \"\"\n        }`\n      );\n\n      return;\n    }\n\n    this._log(`Mined block #${blockNumber}`);\n  }\n\n  public logMultipleTransactionsWarning() {\n    this._indent(() => {\n      this._log(\n        \"There were other pending transactions mined in the same block:\"\n      );\n    });\n    this.logEmptyLine();\n  }\n\n  public logMultipleBlocksWarning() {\n    this._indent(() => {\n      this._log(\n        \"There were other pending transactions. More than one block had to be mined:\"\n      );\n    });\n    this.logEmptyLine();\n  }\n\n  public logEmptyLine() {\n    this._log(\"\");\n  }\n\n  private _logBaseFeePerGas(block: Block) {\n    if (block.header.baseFeePerGas !== undefined) {\n      this._log(`Base fee: ${block.header.baseFeePerGas}`);\n    }\n  }\n\n  public printErrorMessage(errorMessage: string) {\n    this._indent(() => {\n      this._print(errorMessage);\n    });\n  }\n\n  public printFailedMethod(method: string) {\n    this._print(method, { color: chalk.red });\n  }\n\n  /**\n   * Print all accumulated logs\n   */\n  public printLogs(): boolean {\n    const logs = this._getLogs();\n    if (logs.length === 0) {\n      return false;\n    }\n\n    for (const msg of logs) {\n      this._print(msg);\n    }\n\n    this._clearLogs();\n\n    return true;\n  }\n\n  public printMinedBlockNumber(\n    blockNumber: number,\n    isEmpty: boolean,\n    baseFeePerGas?: BN\n  ) {\n    if (this._emptyMinedBlocksRangeStart !== undefined) {\n      this._print(\n        `Mined empty block range #${this._emptyMinedBlocksRangeStart} to #${blockNumber}`,\n        { collapseMinedBlock: true, replaceLastLine: true }\n      );\n    } else {\n      this._emptyMinedBlocksRangeStart = blockNumber;\n\n      if (isEmpty) {\n        this._print(\n          `Mined empty block #${blockNumber}${\n            baseFeePerGas !== undefined ? ` with base fee ${baseFeePerGas}` : \"\"\n          }`,\n          {\n            collapseMinedBlock: true,\n          }\n        );\n\n        return;\n      }\n\n      this._print(`Mined block #${blockNumber}`, {\n        collapseMinedBlock: true,\n      });\n    }\n  }\n\n  public printMetaMaskWarning() {\n    const message =\n      \"If you are using MetaMask, you can learn how to fix this error here: https://hardhat.org/metamask-issue\";\n\n    this._indent(() => {\n      this._print(message, { color: chalk.yellow });\n    });\n  }\n\n  public printMethod(method: string) {\n    if (this._shouldCollapseMethod(method)) {\n      this._methodCollapsedCount += 1;\n\n      this._print(chalk.green(`${method} (${this._methodCollapsedCount})`), {\n        collapsePrintedMethod: true,\n        replaceLastLine: true,\n      });\n    } else {\n      this._startCollapsingMethod(method);\n      this._print(method, { color: chalk.green, collapsePrintedMethod: true });\n    }\n  }\n\n  public printMethodNotSupported(method: string) {\n    this._print(`${method} - Method not supported`, { color: chalk.red });\n  }\n\n  public printEmptyLine() {\n    this._print(\"\");\n  }\n\n  public printUnknownError(err: Error) {\n    this._indent(() => {\n      this._printError(err);\n      this.printEmptyLine();\n\n      this._print(\n        \"If you think this is a bug in Hardhat, please report it here: https://hardhat.org/reportbug\"\n      );\n    });\n  }\n\n  private _format(msg: string, { color }: PrintOptions = {}): string {\n    if (msg === \"\") {\n      // don't indent empty lines\n      return msg;\n    }\n\n    if (this._currentIndent > 0) {\n      msg = msg\n        .split(\"\\n\")\n        .map((line) => \" \".repeat(this._currentIndent) + line)\n        .join(\"\\n\");\n    }\n\n    if (color !== undefined) {\n      return color(msg);\n    }\n\n    return msg;\n  }\n\n  private _indent<T>(cb: () => T, enabled = true) {\n    if (enabled) {\n      this._currentIndent += 2;\n    }\n    try {\n      return cb();\n    } finally {\n      if (enabled) {\n        this._currentIndent -= 2;\n      }\n    }\n  }\n\n  private _indentSingleLine(message: string): string {\n    return \" \".repeat(this._currentIndent) + message;\n  }\n\n  private _log(msg: string, printOptions: PrintOptions = {}) {\n    if (printOptions.collapsePrintedMethod !== true) {\n      this._stopCollapsingMethod();\n    }\n    if (printOptions.collapseMinedBlock !== true) {\n      this._emptyMinedBlocksRangeStart = undefined;\n    }\n    const formattedMessage = this._format(msg, printOptions);\n\n    this._logs.push(formattedMessage);\n  }\n\n  private _logError(err: Error) {\n    if (this.isLoggedError(err)) {\n      this.logEmptyLine();\n      this._log(util.inspect(err));\n    }\n  }\n\n  private _logTxInsideBlock(\n    tx: TypedTransaction,\n    txTrace: GatherTracesResult,\n    code: Buffer,\n    txGasUsed: number,\n    {\n      highlightTxHash,\n    }: {\n      highlightTxHash: boolean;\n    }\n  ) {\n    // indentAfterTransactionHash: true,\n    // printTxBlockNumber: false,\n    // startWithTxHash: true,\n    let txHash = bufferToHex(tx.hash());\n\n    if (highlightTxHash) {\n      txHash = chalk.bold(txHash);\n    }\n\n    this._logWithTitle(\"Transaction\", txHash);\n\n    this._indent(() => {\n      this._logContractAndFunctionName(txTrace.trace, code);\n      this._logTxFrom(tx.getSenderAddress().toBuffer());\n      this._logTxTo(tx.to?.toBuffer(), txTrace.trace);\n      this._logTxValue(new BN(tx.value));\n      this._logWithTitle(\n        \"Gas used\",\n        `${txGasUsed} of ${tx.gasLimit.toNumber()}`\n      );\n\n      this._logConsoleLogMessages(txTrace.consoleLogMessages);\n\n      if (txTrace.error !== undefined) {\n        this._logError(txTrace.error);\n      }\n    });\n  }\n\n  /**\n   *  This should be the only function that calls _printLine and\n   *  _replaceLastLine (except for the special console.sol case),\n   *  because it's the only function that checks if the logger\n   *  is enabled.\n   */\n  private _print(msg: string, printOptions: PrintOptions = {}) {\n    if (!this._enabled) {\n      return;\n    }\n\n    if (printOptions.collapsePrintedMethod !== true) {\n      this._stopCollapsingMethod();\n    }\n    if (printOptions.collapseMinedBlock !== true) {\n      this._emptyMinedBlocksRangeStart = undefined;\n    }\n    const formattedMessage = this._format(msg, printOptions);\n\n    if (printOptions.replaceLastLine === true) {\n      this._replaceLastLine(formattedMessage);\n    } else {\n      this._printLine(formattedMessage);\n    }\n  }\n\n  private _printError(err: Error) {\n    if (this.isLoggedError(err)) {\n      this.printEmptyLine();\n      this._print(util.inspect(err));\n    }\n  }\n\n  private _logContractAndFunctionName(\n    trace: MessageTrace | undefined,\n    code: Buffer,\n    {\n      printNonContractCalled = false,\n    }: { printNonContractCalled?: boolean } = {}\n  ) {\n    if (trace === undefined) {\n      return;\n    }\n\n    if (isPrecompileTrace(trace)) {\n      this._logWithTitle(\n        \"Precompile call\",\n        `<PrecompileContract ${trace.precompile}>`\n      );\n      return;\n    }\n\n    if (isCreateTrace(trace)) {\n      if (trace.bytecode === undefined) {\n        this._logWithTitle(\"Contract deployment\", UNRECOGNIZED_CONTRACT_NAME);\n      } else {\n        this._logWithTitle(\"Contract deployment\", trace.bytecode.contract.name);\n      }\n\n      if (trace.deployedContract !== undefined && trace.error === undefined) {\n        this._logWithTitle(\n          \"Contract address\",\n          bufferToHex(trace.deployedContract)\n        );\n      }\n\n      return;\n    }\n\n    if (code.length === 0) {\n      if (printNonContractCalled) {\n        this._log(`WARNING: Calling an account which is not a contract`);\n      }\n\n      return;\n    }\n\n    if (trace.bytecode === undefined) {\n      this._logWithTitle(\"Contract call\", UNRECOGNIZED_CONTRACT_NAME);\n      return;\n    }\n\n    const func = trace.bytecode.contract.getFunctionFromSelector(\n      trace.calldata.slice(0, 4)\n    );\n\n    const functionName: string =\n      func === undefined\n        ? UNRECOGNIZED_FUNCTION_NAME\n        : func.type === ContractFunctionType.FALLBACK\n        ? FALLBACK_FUNCTION_NAME\n        : func.type === ContractFunctionType.RECEIVE\n        ? RECEIVE_FUNCTION_NAME\n        : func.name;\n\n    this._logWithTitle(\n      \"Contract call\",\n      `${trace.bytecode.contract.name}#${functionName}`\n    );\n  }\n\n  private _shouldCollapseMethod(method: string) {\n    return (\n      method === this._methodBeingCollapsed &&\n      !this._hasLogs() &&\n      this._methodCollapsedCount > 0\n    );\n  }\n\n  private _startCollapsingMethod(method: string) {\n    this._methodBeingCollapsed = method;\n    this._methodCollapsedCount = 1;\n  }\n\n  private _stopCollapsingMethod() {\n    this._methodBeingCollapsed = undefined;\n    this._methodCollapsedCount = 0;\n  }\n\n  private _logTxTo(to: Buffer | undefined, trace?: MessageTrace) {\n    if (trace !== undefined && isCreateTrace(trace)) {\n      return;\n    }\n    if (to === undefined) {\n      // only for the type-checker, since `to` is undefined only when\n      // the message is a create trace\n      return;\n    }\n\n    const toString = bufferToHex(to);\n\n    this._logWithTitle(\"To\", toString);\n  }\n\n  private _logTxValue(value: BN) {\n    this._logWithTitle(\"Value\", weiToHumanReadableString(value));\n  }\n\n  private _logTxFrom(from: Buffer) {\n    this._logWithTitle(\"From\", bufferToHex(from));\n  }\n\n  private _logBlockNumber(block: Block) {\n    this._log(\n      `Block #${block.header.number.toNumber()}: ${bufferToHex(block.hash())}`\n    );\n  }\n\n  private _logEmptyLineBetweenTransactions(\n    currentIndex: number,\n    totalTransactions: number\n  ) {\n    if (currentIndex + 1 < totalTransactions && totalTransactions > 1) {\n      this.logEmptyLine();\n    }\n  }\n\n  private _logBlockHash(block: Block) {\n    this._log(`Block: ${bufferToHex(block.hash())}`);\n  }\n\n  private _logConsoleLogMessages(messages: string[]) {\n    // This is a especial case, as we always want to print the console.log\n    // messages. The difference is how.\n    // If we have a logger, we should use that, so that logs are printed in\n    // order. If we don't, we just print the messages here.\n    if (!this._enabled) {\n      for (const msg of messages) {\n        this._printLine(msg);\n      }\n      return;\n    }\n\n    if (messages.length === 0) {\n      return;\n    }\n\n    this.logEmptyLine();\n    this._log(\"console.log:\");\n\n    for (const msg of messages) {\n      this._log(`  ${msg}`);\n    }\n  }\n\n  private _logWithTitle(title: string, message: string) {\n    title = this._indentSingleLine(title);\n\n    // We always use the max title length we've seen. Otherwise the value move\n    // a lot with each tx/call.\n    if (title.length > this._titleLength) {\n      this._titleLength = title.length;\n    }\n\n    this._logs.push([title, message]);\n  }\n\n  private _clearLogs() {\n    this._logs = [];\n  }\n\n  private _hasLogs(): boolean {\n    return this._logs.length > 0;\n  }\n\n  private _getLogs(): string[] {\n    return this._logs.map((l) => {\n      if (typeof l === \"string\") {\n        return l;\n      }\n\n      const title = `${l[0]}:`;\n\n      return `${title.padEnd(this._titleLength + 1)} ${l[1]}`;\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"script"}