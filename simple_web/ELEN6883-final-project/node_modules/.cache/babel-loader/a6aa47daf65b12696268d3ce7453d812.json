{"ast":null,"code":"import { __read, __spread } from \"tslib\";\nimport { addGlobalEventProcessor, getCurrentHub } from '@sentry/hub';\nimport { logger } from '@sentry/utils';\nexport var installedIntegrations = [];\n/** Gets integration to install */\n\nexport function getIntegrationsToSetup(options) {\n  var defaultIntegrations = options.defaultIntegrations && __spread(options.defaultIntegrations) || [];\n  var userIntegrations = options.integrations;\n  var integrations = [];\n\n  if (Array.isArray(userIntegrations)) {\n    var userIntegrationsNames_1 = userIntegrations.map(function (i) {\n      return i.name;\n    });\n    var pickedIntegrationsNames_1 = []; // Leave only unique default integrations, that were not overridden with provided user integrations\n\n    defaultIntegrations.forEach(function (defaultIntegration) {\n      if (userIntegrationsNames_1.indexOf(defaultIntegration.name) === -1 && pickedIntegrationsNames_1.indexOf(defaultIntegration.name) === -1) {\n        integrations.push(defaultIntegration);\n        pickedIntegrationsNames_1.push(defaultIntegration.name);\n      }\n    }); // Don't add same user integration twice\n\n    userIntegrations.forEach(function (userIntegration) {\n      if (pickedIntegrationsNames_1.indexOf(userIntegration.name) === -1) {\n        integrations.push(userIntegration);\n        pickedIntegrationsNames_1.push(userIntegration.name);\n      }\n    });\n  } else if (typeof userIntegrations === 'function') {\n    integrations = userIntegrations(defaultIntegrations);\n    integrations = Array.isArray(integrations) ? integrations : [integrations];\n  } else {\n    integrations = __spread(defaultIntegrations);\n  } // Make sure that if present, `Debug` integration will always run last\n\n\n  var integrationsNames = integrations.map(function (i) {\n    return i.name;\n  });\n  var alwaysLastToRun = 'Debug';\n\n  if (integrationsNames.indexOf(alwaysLastToRun) !== -1) {\n    integrations.push.apply(integrations, __spread(integrations.splice(integrationsNames.indexOf(alwaysLastToRun), 1)));\n  }\n\n  return integrations;\n}\n/** Setup given integration */\n\nexport function setupIntegration(integration) {\n  if (installedIntegrations.indexOf(integration.name) !== -1) {\n    return;\n  }\n\n  integration.setupOnce(addGlobalEventProcessor, getCurrentHub);\n  installedIntegrations.push(integration.name);\n  logger.log(\"Integration installed: \" + integration.name);\n}\n/**\n * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default\n * integrations are added unless they were already provided before.\n * @param integrations array of integration instances\n * @param withDefault should enable default integrations\n */\n\nexport function setupIntegrations(options) {\n  var integrations = {};\n  getIntegrationsToSetup(options).forEach(function (integration) {\n    integrations[integration.name] = integration;\n    setupIntegration(integration);\n  });\n  return integrations;\n}","map":{"version":3,"mappings":"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","names":["addGlobalEventProcessor","getCurrentHub","logger","installedIntegrations","getIntegrationsToSetup","options","defaultIntegrations","__spread","userIntegrations","integrations","Array","isArray","userIntegrationsNames_1","map","name","pickedIntegrationsNames_1","forEach","indexOf","defaultIntegration","push","userIntegration","integrationsNames","alwaysLastToRun","apply","splice","setupIntegration","integration","setupOnce","log","setupIntegrations"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/@sentry/core/src/integration.ts"],"sourcesContent":["import { addGlobalEventProcessor, getCurrentHub } from '@sentry/hub';\nimport { Integration, Options } from '@sentry/types';\nimport { logger } from '@sentry/utils';\n\nexport const installedIntegrations: string[] = [];\n\n/** Map of integrations assigned to a client */\nexport interface IntegrationIndex {\n  [key: string]: Integration;\n}\n\n/** Gets integration to install */\nexport function getIntegrationsToSetup(options: Options): Integration[] {\n  const defaultIntegrations = (options.defaultIntegrations && [...options.defaultIntegrations]) || [];\n  const userIntegrations = options.integrations;\n  let integrations: Integration[] = [];\n  if (Array.isArray(userIntegrations)) {\n    const userIntegrationsNames = userIntegrations.map(i => i.name);\n    const pickedIntegrationsNames: string[] = [];\n\n    // Leave only unique default integrations, that were not overridden with provided user integrations\n    defaultIntegrations.forEach(defaultIntegration => {\n      if (\n        userIntegrationsNames.indexOf(defaultIntegration.name) === -1 &&\n        pickedIntegrationsNames.indexOf(defaultIntegration.name) === -1\n      ) {\n        integrations.push(defaultIntegration);\n        pickedIntegrationsNames.push(defaultIntegration.name);\n      }\n    });\n\n    // Don't add same user integration twice\n    userIntegrations.forEach(userIntegration => {\n      if (pickedIntegrationsNames.indexOf(userIntegration.name) === -1) {\n        integrations.push(userIntegration);\n        pickedIntegrationsNames.push(userIntegration.name);\n      }\n    });\n  } else if (typeof userIntegrations === 'function') {\n    integrations = userIntegrations(defaultIntegrations);\n    integrations = Array.isArray(integrations) ? integrations : [integrations];\n  } else {\n    integrations = [...defaultIntegrations];\n  }\n\n  // Make sure that if present, `Debug` integration will always run last\n  const integrationsNames = integrations.map(i => i.name);\n  const alwaysLastToRun = 'Debug';\n  if (integrationsNames.indexOf(alwaysLastToRun) !== -1) {\n    integrations.push(...integrations.splice(integrationsNames.indexOf(alwaysLastToRun), 1));\n  }\n\n  return integrations;\n}\n\n/** Setup given integration */\nexport function setupIntegration(integration: Integration): void {\n  if (installedIntegrations.indexOf(integration.name) !== -1) {\n    return;\n  }\n  integration.setupOnce(addGlobalEventProcessor, getCurrentHub);\n  installedIntegrations.push(integration.name);\n  logger.log(`Integration installed: ${integration.name}`);\n}\n\n/**\n * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default\n * integrations are added unless they were already provided before.\n * @param integrations array of integration instances\n * @param withDefault should enable default integrations\n */\nexport function setupIntegrations<O extends Options>(options: O): IntegrationIndex {\n  const integrations: IntegrationIndex = {};\n  getIntegrationsToSetup(options).forEach(integration => {\n    integrations[integration.name] = integration;\n    setupIntegration(integration);\n  });\n  return integrations;\n}\n"]},"metadata":{},"sourceType":"module"}