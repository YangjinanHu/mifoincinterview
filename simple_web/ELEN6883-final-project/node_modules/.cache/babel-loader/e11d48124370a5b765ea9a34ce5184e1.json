{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.lazyFunction = exports.lazyObject = void 0;\n\nconst util_1 = __importDefault(require(\"util\"));\n\nconst errors_1 = require(\"../core/errors\");\n\nconst errors_list_1 = require(\"../core/errors-list\");\n\nconst inspect = Symbol.for(\"nodejs.util.inspect.custom\");\n/**\n * This module provides function to implement proxy-based object, functions, and\n * classes (they are functions). They receive an initializer function that it's\n * not used until someone interacts with the lazy element.\n *\n * This functions can also be used like a lazy `require`, creating a proxy that\n * doesn't require the module until needed.\n *\n * The disadvantage of using this technique is that the type information is\n * lost wrt `import`, as `require` returns an `any. If done with enough care,\n * this can be manually fixed.\n *\n * TypeScript doesn't emit `require` calls for modules that are imported only\n * because of their types. So if one uses lazyObject or lazyFunction along with\n * a normal ESM import you can pass the module's type to this function.\n *\n * An example of this can be:\n *\n *    import findUpT from \"find-up\";\n *    export const findUp = lazyFunction<typeof findUpT>(() => require(\"find-up\"));\n *\n * You can also use it with named exports:\n *\n *    import { EthT } from \"web3x/eth\";\n *    const Eth = lazyFunction<typeof EthT>(() => require(\"web3x/eth\").Eth);\n */\n\nfunction lazyObject(objectCreator) {\n  return createLazyProxy(objectCreator, getRealTarget => ({\n    [inspect]() {\n      const realTarget = getRealTarget();\n      return util_1.default.inspect(realTarget);\n    }\n\n  }), object => {\n    if (object instanceof Function) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n        operation: \"Creating lazy functions or classes with lazyObject\"\n      });\n    }\n\n    if (typeof object !== \"object\" || object === null) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n        operation: \"Using lazyObject with anything other than objects\"\n      });\n    }\n  });\n}\n\nexports.lazyObject = lazyObject; // eslint-disable-next-line @typescript-eslint/ban-types\n\nfunction lazyFunction(functionCreator) {\n  return createLazyProxy(functionCreator, getRealTarget => {\n    function dummyTarget() {}\n\n    dummyTarget[inspect] = function () {\n      const realTarget = getRealTarget();\n      return util_1.default.inspect(realTarget);\n    };\n\n    return dummyTarget;\n  }, object => {\n    if (!(object instanceof Function)) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n        operation: \"Using lazyFunction with anything other than functions or classes\"\n      });\n    }\n  });\n}\n\nexports.lazyFunction = lazyFunction;\n\nfunction createLazyProxy(targetCreator, dummyTargetCreator, validator) {\n  let realTarget;\n  const dummyTarget = dummyTargetCreator(getRealTarget);\n\n  function getRealTarget() {\n    if (realTarget === undefined) {\n      const target = targetCreator();\n      validator(target); // We copy all properties. We won't use them, but help us avoid Proxy\n      // invariant violations\n\n      const properties = Object.getOwnPropertyNames(target);\n\n      for (const property of properties) {\n        const descriptor = Object.getOwnPropertyDescriptor(target, property);\n        Object.defineProperty(dummyTarget, property, descriptor);\n      }\n\n      Object.setPrototypeOf(dummyTarget, Object.getPrototypeOf(target)); // Using a null prototype seems to tirgger a V8 bug, so we forbid it\n      // See: https://github.com/nodejs/node/issues/29730\n\n      if (Object.getPrototypeOf(target) === null) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n          operation: \"Using lazyFunction or lazyObject to construct objects/functions with prototype null\"\n        });\n      }\n\n      if (!Object.isExtensible(target)) {\n        Object.preventExtensions(dummyTarget);\n      }\n\n      realTarget = target;\n    }\n\n    return realTarget;\n  }\n\n  const handler = {\n    defineProperty(target, property, descriptor) {\n      Reflect.defineProperty(dummyTarget, property, descriptor);\n      return Reflect.defineProperty(getRealTarget(), property, descriptor);\n    },\n\n    deleteProperty(target, property) {\n      Reflect.deleteProperty(dummyTarget, property);\n      return Reflect.deleteProperty(getRealTarget(), property);\n    },\n\n    get(target, property, receiver) {\n      // We have this short-circuit logic here to avoid a cyclic require when\n      // loading Web3.js.\n      //\n      // If a lazy object is somehow accessed while its real target is being\n      // created, it would trigger an endless loop of recreation, which node\n      // detects and resolve to an empty object.\n      //\n      // This happens with Web3.js because we a lazyObject that loads it,\n      // and expose it as `global.web3`. This Web3.js file accesses\n      // `global.web3` when it's being loaded, triggering the loop we mentioned\n      // before: https://github.com/ethereum/web3.js/blob/8574bd3bf11a2e9cf4bcf8850cab13e1db56653f/packages/web3-core-requestmanager/src/givenProvider.js#L41\n      //\n      // We just return `undefined` in that case, to not enter into the loop.\n      //\n      // **SUPER IMPORTANT NOTE:** Removing this is very tempting, I know. This\n      // is a horrible hack. The most obvious approach for doing so is to\n      // remove the `global` elements that trigger this crazy behavior right\n      // before doing our `require(\"web3\")`, and restore them afterwards.\n      // **THIS IS NOT ENOUGH** Users, and libraries (!!!!), will have their own\n      // `require`s that we can't control and will trigger the same bug.\n      const stack = new Error().stack;\n\n      if (stack !== undefined && stack.includes(\"givenProvider.js\") && realTarget === undefined) {\n        return undefined;\n      }\n\n      return Reflect.get(getRealTarget(), property, receiver);\n    },\n\n    getOwnPropertyDescriptor(target, property) {\n      const descriptor = Reflect.getOwnPropertyDescriptor(getRealTarget(), property);\n\n      if (descriptor !== undefined) {\n        Object.defineProperty(dummyTarget, property, descriptor);\n      }\n\n      return descriptor;\n    },\n\n    getPrototypeOf(_target) {\n      return Reflect.getPrototypeOf(getRealTarget());\n    },\n\n    has(target, property) {\n      return Reflect.has(getRealTarget(), property);\n    },\n\n    isExtensible(_target) {\n      return Reflect.isExtensible(getRealTarget());\n    },\n\n    ownKeys(_target) {\n      return Reflect.ownKeys(getRealTarget());\n    },\n\n    preventExtensions(_target) {\n      Object.preventExtensions(dummyTarget);\n      return Reflect.preventExtensions(getRealTarget());\n    },\n\n    set(target, property, value, receiver) {\n      Reflect.set(dummyTarget, property, value, receiver);\n      return Reflect.set(getRealTarget(), property, value, receiver);\n    },\n\n    setPrototypeOf(target, prototype) {\n      Reflect.setPrototypeOf(dummyTarget, prototype);\n      return Reflect.setPrototypeOf(getRealTarget(), prototype);\n    }\n\n  };\n\n  if (dummyTarget instanceof Function) {\n    // If dummy target is a function, the actual target must be a function too.\n    handler.apply = (target, thisArg, argArray) => {\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      return Reflect.apply(getRealTarget(), thisArg, argArray);\n    };\n\n    handler.construct = (target, argArray, _newTarget) => {\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      return Reflect.construct(getRealTarget(), argArray);\n    };\n  }\n\n  return new Proxy(dummyTarget, handler);\n}","map":{"version":3,"mappings":"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","names":["inspect","Symbol","for","lazyObject","objectCreator","createLazyProxy","getRealTarget","realTarget","util_1","object","Function","errors_1","errors_list_1","GENERAL","UNSUPPORTED_OPERATION","operation","exports","lazyFunction","functionCreator","dummyTarget","targetCreator","dummyTargetCreator","validator","undefined","target","properties","Object","getOwnPropertyNames","property","descriptor","getOwnPropertyDescriptor","defineProperty","setPrototypeOf","getPrototypeOf","isExtensible","preventExtensions","handler","Reflect","deleteProperty","get","receiver","stack","Error","includes","_target","has","ownKeys","set","value","prototype","apply","thisArg","argArray","construct","_newTarget","Proxy"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/internal/util/lazy.ts"],"sourcesContent":["import util from \"util\";\n\nimport { HardhatError } from \"../core/errors\";\nimport { ERRORS } from \"../core/errors-list\";\n\nconst inspect = Symbol.for(\"nodejs.util.inspect.custom\");\n\n/**\n * This module provides function to implement proxy-based object, functions, and\n * classes (they are functions). They receive an initializer function that it's\n * not used until someone interacts with the lazy element.\n *\n * This functions can also be used like a lazy `require`, creating a proxy that\n * doesn't require the module until needed.\n *\n * The disadvantage of using this technique is that the type information is\n * lost wrt `import`, as `require` returns an `any. If done with enough care,\n * this can be manually fixed.\n *\n * TypeScript doesn't emit `require` calls for modules that are imported only\n * because of their types. So if one uses lazyObject or lazyFunction along with\n * a normal ESM import you can pass the module's type to this function.\n *\n * An example of this can be:\n *\n *    import findUpT from \"find-up\";\n *    export const findUp = lazyFunction<typeof findUpT>(() => require(\"find-up\"));\n *\n * You can also use it with named exports:\n *\n *    import { EthT } from \"web3x/eth\";\n *    const Eth = lazyFunction<typeof EthT>(() => require(\"web3x/eth\").Eth);\n */\n\nexport function lazyObject<T extends object>(objectCreator: () => T): T {\n  return createLazyProxy(\n    objectCreator,\n    (getRealTarget) => ({\n      [inspect]() {\n        const realTarget = getRealTarget();\n        return util.inspect(realTarget);\n      },\n    }),\n    (object) => {\n      if (object instanceof Function) {\n        throw new HardhatError(ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n          operation: \"Creating lazy functions or classes with lazyObject\",\n        });\n      }\n\n      if (typeof object !== \"object\" || object === null) {\n        throw new HardhatError(ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n          operation: \"Using lazyObject with anything other than objects\",\n        });\n      }\n    }\n  );\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function lazyFunction<T extends Function>(functionCreator: () => T): T {\n  return createLazyProxy(\n    functionCreator,\n    (getRealTarget) => {\n      function dummyTarget() {}\n\n      (dummyTarget as any)[inspect] = function () {\n        const realTarget = getRealTarget();\n        return util.inspect(realTarget);\n      };\n\n      return dummyTarget;\n    },\n    (object) => {\n      if (!(object instanceof Function)) {\n        throw new HardhatError(ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n          operation:\n            \"Using lazyFunction with anything other than functions or classes\",\n        });\n      }\n    }\n  );\n}\n\nfunction createLazyProxy<ActualT extends GuardT, GuardT extends object>(\n  targetCreator: () => ActualT,\n  dummyTargetCreator: (getRealTarget: () => ActualT) => GuardT,\n  validator: (target: any) => void\n): ActualT {\n  let realTarget: ActualT | undefined;\n\n  const dummyTarget: ActualT = dummyTargetCreator(getRealTarget) as any;\n\n  function getRealTarget(): ActualT {\n    if (realTarget === undefined) {\n      const target = targetCreator();\n      validator(target);\n\n      // We copy all properties. We won't use them, but help us avoid Proxy\n      // invariant violations\n      const properties = Object.getOwnPropertyNames(target);\n      for (const property of properties) {\n        const descriptor = Object.getOwnPropertyDescriptor(target, property)!;\n        Object.defineProperty(dummyTarget, property, descriptor);\n      }\n\n      Object.setPrototypeOf(dummyTarget, Object.getPrototypeOf(target));\n\n      // Using a null prototype seems to tirgger a V8 bug, so we forbid it\n      // See: https://github.com/nodejs/node/issues/29730\n      if (Object.getPrototypeOf(target) === null) {\n        throw new HardhatError(ERRORS.GENERAL.UNSUPPORTED_OPERATION, {\n          operation:\n            \"Using lazyFunction or lazyObject to construct objects/functions with prototype null\",\n        });\n      }\n\n      if (!Object.isExtensible(target)) {\n        Object.preventExtensions(dummyTarget);\n      }\n\n      realTarget = target;\n    }\n\n    return realTarget;\n  }\n\n  const handler: ProxyHandler<ActualT> = {\n    defineProperty(target, property, descriptor) {\n      Reflect.defineProperty(dummyTarget, property, descriptor);\n      return Reflect.defineProperty(getRealTarget(), property, descriptor);\n    },\n\n    deleteProperty(target, property) {\n      Reflect.deleteProperty(dummyTarget, property);\n      return Reflect.deleteProperty(getRealTarget(), property);\n    },\n\n    get(target, property, receiver) {\n      // We have this short-circuit logic here to avoid a cyclic require when\n      // loading Web3.js.\n      //\n      // If a lazy object is somehow accessed while its real target is being\n      // created, it would trigger an endless loop of recreation, which node\n      // detects and resolve to an empty object.\n      //\n      // This happens with Web3.js because we a lazyObject that loads it,\n      // and expose it as `global.web3`. This Web3.js file accesses\n      // `global.web3` when it's being loaded, triggering the loop we mentioned\n      // before: https://github.com/ethereum/web3.js/blob/8574bd3bf11a2e9cf4bcf8850cab13e1db56653f/packages/web3-core-requestmanager/src/givenProvider.js#L41\n      //\n      // We just return `undefined` in that case, to not enter into the loop.\n      //\n      // **SUPER IMPORTANT NOTE:** Removing this is very tempting, I know. This\n      // is a horrible hack. The most obvious approach for doing so is to\n      // remove the `global` elements that trigger this crazy behavior right\n      // before doing our `require(\"web3\")`, and restore them afterwards.\n      // **THIS IS NOT ENOUGH** Users, and libraries (!!!!), will have their own\n      // `require`s that we can't control and will trigger the same bug.\n      const stack = new Error().stack;\n      if (\n        stack !== undefined &&\n        stack.includes(\"givenProvider.js\") &&\n        realTarget === undefined\n      ) {\n        return undefined;\n      }\n\n      return Reflect.get(getRealTarget(), property, receiver);\n    },\n\n    getOwnPropertyDescriptor(target, property) {\n      const descriptor = Reflect.getOwnPropertyDescriptor(\n        getRealTarget(),\n        property\n      );\n\n      if (descriptor !== undefined) {\n        Object.defineProperty(dummyTarget, property, descriptor);\n      }\n\n      return descriptor;\n    },\n\n    getPrototypeOf(_target) {\n      return Reflect.getPrototypeOf(getRealTarget());\n    },\n\n    has(target, property) {\n      return Reflect.has(getRealTarget(), property);\n    },\n\n    isExtensible(_target) {\n      return Reflect.isExtensible(getRealTarget());\n    },\n\n    ownKeys(_target) {\n      return Reflect.ownKeys(getRealTarget());\n    },\n\n    preventExtensions(_target) {\n      Object.preventExtensions(dummyTarget);\n      return Reflect.preventExtensions(getRealTarget());\n    },\n\n    set(target, property, value, receiver) {\n      Reflect.set(dummyTarget, property, value, receiver);\n      return Reflect.set(getRealTarget(), property, value, receiver);\n    },\n\n    setPrototypeOf(target, prototype) {\n      Reflect.setPrototypeOf(dummyTarget, prototype);\n      return Reflect.setPrototypeOf(getRealTarget(), prototype);\n    },\n  };\n\n  if (dummyTarget instanceof Function) {\n    // If dummy target is a function, the actual target must be a function too.\n    handler.apply = (target, thisArg: any, argArray?: any) => {\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      return Reflect.apply(getRealTarget() as Function, thisArg, argArray);\n    };\n\n    handler.construct = (target, argArray: any, _newTarget?: any) => {\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      return Reflect.construct(getRealTarget() as Function, argArray);\n    };\n  }\n\n  return new Proxy(dummyTarget, handler);\n}\n"]},"metadata":{},"sourceType":"script"}