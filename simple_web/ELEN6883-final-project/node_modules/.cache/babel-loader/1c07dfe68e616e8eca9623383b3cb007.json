{"ast":null,"code":"'use strict';\n\nvar Suite = require('../suite');\n\nvar errors = require('../errors');\n\nvar createMissingArgumentError = errors.createMissingArgumentError;\nvar createUnsupportedError = errors.createUnsupportedError;\n/**\n * Functions common to more than one interface.\n *\n * @param {Suite[]} suites\n * @param {Context} context\n * @param {Mocha} mocha\n * @return {Object} An object containing common functions.\n */\n\nmodule.exports = function (suites, context, mocha) {\n  /**\n   * Check if the suite should be tested.\n   *\n   * @private\n   * @param {Suite} suite - suite to check\n   * @returns {boolean}\n   */\n  function shouldBeTested(suite) {\n    return !mocha.options.grep || mocha.options.grep && mocha.options.grep.test(suite.fullTitle()) && !mocha.options.invert;\n  }\n\n  return {\n    /**\n     * This is only present if flag --delay is passed into Mocha. It triggers\n     * root suite execution.\n     *\n     * @param {Suite} suite The root suite.\n     * @return {Function} A function which runs the root suite\n     */\n    runWithSuite: function runWithSuite(suite) {\n      return function run() {\n        suite.run();\n      };\n    },\n\n    /**\n     * Execute before running tests.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    before: function (name, fn) {\n      suites[0].beforeAll(name, fn);\n    },\n\n    /**\n     * Execute after running tests.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    after: function (name, fn) {\n      suites[0].afterAll(name, fn);\n    },\n\n    /**\n     * Execute before each test case.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    beforeEach: function (name, fn) {\n      suites[0].beforeEach(name, fn);\n    },\n\n    /**\n     * Execute after each test case.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    afterEach: function (name, fn) {\n      suites[0].afterEach(name, fn);\n    },\n    suite: {\n      /**\n       * Create an exclusive Suite; convenience function\n       * See docstring for create() below.\n       *\n       * @param {Object} opts\n       * @returns {Suite}\n       */\n      only: function only(opts) {\n        opts.isOnly = true;\n        return this.create(opts);\n      },\n\n      /**\n       * Create a Suite, but skip it; convenience function\n       * See docstring for create() below.\n       *\n       * @param {Object} opts\n       * @returns {Suite}\n       */\n      skip: function skip(opts) {\n        opts.pending = true;\n        return this.create(opts);\n      },\n\n      /**\n       * Creates a suite.\n       *\n       * @param {Object} opts Options\n       * @param {string} opts.title Title of Suite\n       * @param {Function} [opts.fn] Suite Function (not always applicable)\n       * @param {boolean} [opts.pending] Is Suite pending?\n       * @param {string} [opts.file] Filepath where this Suite resides\n       * @param {boolean} [opts.isOnly] Is Suite exclusive?\n       * @returns {Suite}\n       */\n      create: function create(opts) {\n        var suite = Suite.create(suites[0], opts.title);\n        suite.pending = Boolean(opts.pending);\n        suite.file = opts.file;\n        suites.unshift(suite);\n\n        if (opts.isOnly) {\n          if (mocha.options.forbidOnly && shouldBeTested(suite)) {\n            throw createUnsupportedError('`.only` forbidden');\n          }\n\n          suite.parent.appendOnlySuite(suite);\n        }\n\n        if (suite.pending) {\n          if (mocha.options.forbidPending && shouldBeTested(suite)) {\n            throw createUnsupportedError('Pending test forbidden');\n          }\n        }\n\n        if (typeof opts.fn === 'function') {\n          opts.fn.call(suite);\n          suites.shift();\n        } else if (typeof opts.fn === 'undefined' && !suite.pending) {\n          throw createMissingArgumentError('Suite \"' + suite.fullTitle() + '\" was defined but no callback was supplied. ' + 'Supply a callback or explicitly skip the suite.', 'callback', 'function');\n        } else if (!opts.fn && suite.pending) {\n          suites.shift();\n        }\n\n        return suite;\n      }\n    },\n    test: {\n      /**\n       * Exclusive test-case.\n       *\n       * @param {Object} mocha\n       * @param {Function} test\n       * @returns {*}\n       */\n      only: function (mocha, test) {\n        if (mocha.options.forbidOnly) throw createUnsupportedError('`.only` forbidden');\n        test.markOnly();\n        return test;\n      },\n\n      /**\n       * Pending test case.\n       *\n       * @param {string} title\n       */\n      skip: function (title) {\n        context.test(title);\n      },\n\n      /**\n       * Number of retry attempts\n       *\n       * @param {number} n\n       */\n      retries: function (n) {\n        context.retries(n);\n      }\n    }\n  };\n};","map":{"version":3,"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/mocha/lib/interfaces/common.js"],"names":["Suite","require","errors","createMissingArgumentError","createUnsupportedError","module","exports","suites","context","mocha","shouldBeTested","suite","options","grep","test","fullTitle","invert","runWithSuite","run","before","name","fn","beforeAll","after","afterAll","beforeEach","afterEach","only","opts","isOnly","create","skip","pending","title","Boolean","file","unshift","forbidOnly","parent","appendOnlySuite","forbidPending","call","shift","markOnly","retries","n"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Suite = require('../suite');\nvar errors = require('../errors');\nvar createMissingArgumentError = errors.createMissingArgumentError;\nvar createUnsupportedError = errors.createUnsupportedError;\n\n/**\n * Functions common to more than one interface.\n *\n * @param {Suite[]} suites\n * @param {Context} context\n * @param {Mocha} mocha\n * @return {Object} An object containing common functions.\n */\nmodule.exports = function(suites, context, mocha) {\n  /**\n   * Check if the suite should be tested.\n   *\n   * @private\n   * @param {Suite} suite - suite to check\n   * @returns {boolean}\n   */\n  function shouldBeTested(suite) {\n    return (\n      !mocha.options.grep ||\n      (mocha.options.grep &&\n        mocha.options.grep.test(suite.fullTitle()) &&\n        !mocha.options.invert)\n    );\n  }\n\n  return {\n    /**\n     * This is only present if flag --delay is passed into Mocha. It triggers\n     * root suite execution.\n     *\n     * @param {Suite} suite The root suite.\n     * @return {Function} A function which runs the root suite\n     */\n    runWithSuite: function runWithSuite(suite) {\n      return function run() {\n        suite.run();\n      };\n    },\n\n    /**\n     * Execute before running tests.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    before: function(name, fn) {\n      suites[0].beforeAll(name, fn);\n    },\n\n    /**\n     * Execute after running tests.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    after: function(name, fn) {\n      suites[0].afterAll(name, fn);\n    },\n\n    /**\n     * Execute before each test case.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    beforeEach: function(name, fn) {\n      suites[0].beforeEach(name, fn);\n    },\n\n    /**\n     * Execute after each test case.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    afterEach: function(name, fn) {\n      suites[0].afterEach(name, fn);\n    },\n\n    suite: {\n      /**\n       * Create an exclusive Suite; convenience function\n       * See docstring for create() below.\n       *\n       * @param {Object} opts\n       * @returns {Suite}\n       */\n      only: function only(opts) {\n        opts.isOnly = true;\n        return this.create(opts);\n      },\n\n      /**\n       * Create a Suite, but skip it; convenience function\n       * See docstring for create() below.\n       *\n       * @param {Object} opts\n       * @returns {Suite}\n       */\n      skip: function skip(opts) {\n        opts.pending = true;\n        return this.create(opts);\n      },\n\n      /**\n       * Creates a suite.\n       *\n       * @param {Object} opts Options\n       * @param {string} opts.title Title of Suite\n       * @param {Function} [opts.fn] Suite Function (not always applicable)\n       * @param {boolean} [opts.pending] Is Suite pending?\n       * @param {string} [opts.file] Filepath where this Suite resides\n       * @param {boolean} [opts.isOnly] Is Suite exclusive?\n       * @returns {Suite}\n       */\n      create: function create(opts) {\n        var suite = Suite.create(suites[0], opts.title);\n        suite.pending = Boolean(opts.pending);\n        suite.file = opts.file;\n        suites.unshift(suite);\n        if (opts.isOnly) {\n          if (mocha.options.forbidOnly && shouldBeTested(suite)) {\n            throw createUnsupportedError('`.only` forbidden');\n          }\n\n          suite.parent.appendOnlySuite(suite);\n        }\n        if (suite.pending) {\n          if (mocha.options.forbidPending && shouldBeTested(suite)) {\n            throw createUnsupportedError('Pending test forbidden');\n          }\n        }\n        if (typeof opts.fn === 'function') {\n          opts.fn.call(suite);\n          suites.shift();\n        } else if (typeof opts.fn === 'undefined' && !suite.pending) {\n          throw createMissingArgumentError(\n            'Suite \"' +\n              suite.fullTitle() +\n              '\" was defined but no callback was supplied. ' +\n              'Supply a callback or explicitly skip the suite.',\n            'callback',\n            'function'\n          );\n        } else if (!opts.fn && suite.pending) {\n          suites.shift();\n        }\n\n        return suite;\n      }\n    },\n\n    test: {\n      /**\n       * Exclusive test-case.\n       *\n       * @param {Object} mocha\n       * @param {Function} test\n       * @returns {*}\n       */\n      only: function(mocha, test) {\n        if (mocha.options.forbidOnly)\n          throw createUnsupportedError('`.only` forbidden');\n        test.markOnly();\n        return test;\n      },\n\n      /**\n       * Pending test case.\n       *\n       * @param {string} title\n       */\n      skip: function(title) {\n        context.test(title);\n      },\n\n      /**\n       * Number of retry attempts\n       *\n       * @param {number} n\n       */\n      retries: function(n) {\n        context.retries(n);\n      }\n    }\n  };\n};\n"]},"metadata":{},"sourceType":"script"}