{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Resolver = exports.ResolvedFile = void 0;\n\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\n\nconst path_1 = __importDefault(require(\"path\"));\n\nconst resolve_1 = __importDefault(require(\"resolve\"));\n\nconst source_names_1 = require(\"../../utils/source-names\");\n\nconst errors_1 = require(\"../core/errors\");\n\nconst errors_list_1 = require(\"../core/errors-list\");\n\nconst hash_1 = require(\"../util/hash\");\n\nconst NODE_MODULES = \"node_modules\";\n\nclass ResolvedFile {\n  constructor(sourceName, absolutePath, content, contentHash, lastModificationDate, libraryName, libraryVersion) {\n    this.sourceName = sourceName;\n    this.absolutePath = absolutePath;\n    this.content = content;\n    this.contentHash = contentHash;\n    this.lastModificationDate = lastModificationDate;\n    (0, errors_1.assertHardhatInvariant)(libraryName === undefined && libraryVersion === undefined || libraryName !== undefined && libraryVersion !== undefined, \"Libraries should have both name and version, or neither one\");\n\n    if (libraryName !== undefined && libraryVersion !== undefined) {\n      this.library = {\n        name: libraryName,\n        version: libraryVersion\n      };\n    }\n  }\n\n  getVersionedName() {\n    return this.sourceName + (this.library !== undefined ? `@v${this.library.version}` : \"\");\n  }\n\n}\n\nexports.ResolvedFile = ResolvedFile;\n\nclass Resolver {\n  constructor(_projectRoot, _parser, _readFile) {\n    this._projectRoot = _projectRoot;\n    this._parser = _parser;\n    this._readFile = _readFile;\n  }\n  /**\n   * Resolves a source name into a ResolvedFile.\n   *\n   * @param sourceName The source name as it would be provided to solc.\n   */\n\n\n  async resolveSourceName(sourceName) {\n    (0, source_names_1.validateSourceNameFormat)(sourceName);\n\n    if (await (0, source_names_1.isLocalSourceName)(this._projectRoot, sourceName)) {\n      return this._resolveLocalSourceName(sourceName);\n    }\n\n    return this._resolveLibrarySourceName(sourceName);\n  }\n  /**\n   * Resolves an import from an already resolved file.\n   * @param from The file were the import statement is present.\n   * @param imported The path in the import statement.\n   */\n\n\n  async resolveImport(from, imported) {\n    const scheme = this._getUriScheme(imported);\n\n    if (scheme !== undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_PROTOCOL, {\n        from: from.sourceName,\n        imported,\n        protocol: scheme\n      });\n    }\n\n    if ((0, source_names_1.replaceBackslashes)(imported) !== imported) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_BACKSLASH, {\n        from: from.sourceName,\n        imported\n      });\n    }\n\n    if ((0, source_names_1.isAbsolutePathSourceName)(imported)) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_ABSOLUTE_PATH, {\n        from: from.sourceName,\n        imported\n      });\n    }\n\n    try {\n      if (!this._isRelativeImport(imported)) {\n        return await this.resolveSourceName((0, source_names_1.normalizeSourceName)(imported));\n      }\n\n      const sourceName = await this._relativeImportToSourceName(from, imported); // We have this special case here, because otherwise local relative\n      // imports can be treated as library imports. For example if\n      // `contracts/c.sol` imports `../non-existent/a.sol`\n\n      if (from.library === undefined && !this._isRelativeImportToLibrary(from, imported)) {\n        return await this._resolveLocalSourceName(sourceName);\n      }\n\n      return await this.resolveSourceName(sourceName);\n    } catch (error) {\n      if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.RESOLVER.FILE_NOT_FOUND) || errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.RESOLVER.LIBRARY_FILE_NOT_FOUND)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.IMPORTED_FILE_NOT_FOUND, {\n          imported,\n          from: from.sourceName\n        }, error);\n      }\n\n      if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.RESOLVER.WRONG_SOURCE_NAME_CASING)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_WRONG_CASING, {\n          imported,\n          from: from.sourceName\n        }, error);\n      }\n\n      if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.RESOLVER.LIBRARY_NOT_INSTALLED)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.IMPORTED_LIBRARY_NOT_INSTALLED, {\n          library: error.messageArguments.library,\n          from: from.sourceName\n        }, error);\n      } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n      throw error;\n    }\n  }\n\n  async _resolveLocalSourceName(sourceName) {\n    await this._validateSourceNameExistenceAndCasing(this._projectRoot, sourceName, false);\n    const absolutePath = path_1.default.join(this._projectRoot, sourceName);\n    return this._resolveFile(sourceName, absolutePath);\n  }\n\n  async _resolveLibrarySourceName(sourceName) {\n    const libraryName = this._getLibraryName(sourceName);\n\n    let packageJsonPath;\n\n    try {\n      packageJsonPath = this._resolveNodeModulesFileFromProjectRoot(path_1.default.join(libraryName, \"package.json\"));\n    } catch (error) {\n      // if the project is using a dependency from hardhat itself but it can't\n      // be found, this means that a global installation is being used, so we\n      // resolve the dependency relative to this file\n      if (libraryName === \"hardhat\") {\n        const hardhatCoreDir = path_1.default.join(__dirname, \"..\", \"..\");\n        packageJsonPath = path_1.default.join(hardhatCoreDir, \"package.json\");\n      } else {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.LIBRARY_NOT_INSTALLED, {\n          library: libraryName\n        }, error);\n      }\n    }\n\n    let nodeModulesPath = path_1.default.dirname(path_1.default.dirname(packageJsonPath));\n\n    if (this._isScopedPackage(sourceName)) {\n      nodeModulesPath = path_1.default.dirname(nodeModulesPath);\n    }\n\n    await this._validateSourceNameExistenceAndCasing(nodeModulesPath, sourceName, true);\n    const packageInfo = await fs_extra_1.default.readJson(packageJsonPath);\n    const libraryVersion = packageInfo.version;\n    return this._resolveFile(sourceName, // We resolve to the real path here, as we may be resolving a linked library\n    await fs_extra_1.default.realpath(path_1.default.join(nodeModulesPath, sourceName)), libraryName, libraryVersion);\n  }\n\n  async _relativeImportToSourceName(from, imported) {\n    // This is a special case, were we turn relative imports from local files\n    // into library imports if necessary. The reason for this is that many\n    // users just do `import \"../node_modules/lib/a.sol\";`.\n    if (this._isRelativeImportToLibrary(from, imported)) {\n      return this._relativeImportToLibraryToSourceName(from, imported);\n    }\n\n    const sourceName = (0, source_names_1.normalizeSourceName)(path_1.default.join(path_1.default.dirname(from.sourceName), imported)); // If the file with the import is local, and the normalized version\n    // starts with ../ means that it's trying to get outside of the project.\n\n    if (from.library === undefined && sourceName.startsWith(\"../\")) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_OUTSIDE_OF_PROJECT, {\n        from: from.sourceName,\n        imported\n      });\n    }\n\n    if (from.library !== undefined && !this._isInsideSameDir(from.sourceName, sourceName)) {\n      // If the file is being imported from a library, this means that it's\n      // trying to reach another one.\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.ILLEGAL_IMPORT, {\n        from: from.sourceName,\n        imported\n      });\n    }\n\n    return sourceName;\n  }\n\n  async _resolveFile(sourceName, absolutePath, libraryName, libraryVersion) {\n    const rawContent = await this._readFile(absolutePath);\n    const stats = await fs_extra_1.default.stat(absolutePath);\n    const lastModificationDate = new Date(stats.ctime);\n    const contentHash = (0, hash_1.createNonCryptographicHashBasedIdentifier)(Buffer.from(rawContent)).toString(\"hex\");\n\n    const parsedContent = this._parser.parse(rawContent, absolutePath, contentHash);\n\n    const content = Object.assign({\n      rawContent\n    }, parsedContent);\n    return new ResolvedFile(sourceName, absolutePath, content, contentHash, lastModificationDate, libraryName, libraryVersion);\n  }\n\n  _isRelativeImport(imported) {\n    return imported.startsWith(\"./\") || imported.startsWith(\"../\");\n  }\n\n  _resolveNodeModulesFileFromProjectRoot(fileName) {\n    return resolve_1.default.sync(fileName, {\n      basedir: this._projectRoot,\n      preserveSymlinks: true\n    });\n  }\n\n  _getLibraryName(sourceName) {\n    let endIndex;\n\n    if (this._isScopedPackage(sourceName)) {\n      endIndex = sourceName.indexOf(\"/\", sourceName.indexOf(\"/\") + 1);\n    } else if (sourceName.indexOf(\"/\") === -1) {\n      endIndex = sourceName.length;\n    } else {\n      endIndex = sourceName.indexOf(\"/\");\n    }\n\n    return sourceName.slice(0, endIndex);\n  }\n\n  _getUriScheme(s) {\n    const re = /([a-zA-Z]+):\\/\\//;\n    const match = re.exec(s);\n\n    if (match === null) {\n      return undefined;\n    }\n\n    return match[1];\n  }\n\n  _isInsideSameDir(sourceNameInDir, sourceNameToTest) {\n    const firstSlash = sourceNameInDir.indexOf(\"/\");\n    const dir = firstSlash !== -1 ? sourceNameInDir.substring(0, firstSlash) : sourceNameInDir;\n    return sourceNameToTest.startsWith(dir);\n  }\n\n  _isScopedPackage(packageOrPackageFile) {\n    return packageOrPackageFile.startsWith(\"@\");\n  }\n\n  _isRelativeImportToLibrary(from, imported) {\n    return this._isRelativeImport(imported) && from.library === undefined && imported.includes(`${NODE_MODULES}/`);\n  }\n\n  _relativeImportToLibraryToSourceName(from, imported) {\n    const sourceName = (0, source_names_1.normalizeSourceName)(path_1.default.join(path_1.default.dirname(from.sourceName), imported));\n    const nmIndex = sourceName.indexOf(`${NODE_MODULES}/`);\n    return sourceName.substr(nmIndex + NODE_MODULES.length + 1);\n  }\n\n  async _validateSourceNameExistenceAndCasing(fromDir, sourceName, isLibrary) {\n    try {\n      await (0, source_names_1.validateSourceNameExistenceAndCasing)(fromDir, sourceName);\n    } catch (error) {\n      if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.SOURCE_NAMES.FILE_NOT_FOUND)) {\n        throw new errors_1.HardhatError(isLibrary ? errors_list_1.ERRORS.RESOLVER.LIBRARY_FILE_NOT_FOUND : errors_list_1.ERRORS.RESOLVER.FILE_NOT_FOUND, {\n          file: sourceName\n        }, error);\n      }\n\n      if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.SOURCE_NAMES.WRONG_CASING)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.WRONG_SOURCE_NAME_CASING, {\n          incorrect: sourceName,\n          correct: error.messageArguments.correct\n        }, error);\n      } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n      throw error;\n    }\n  }\n\n}\n\nexports.Resolver = Resolver;","map":{"version":3,"mappings":"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","names":["NODE_MODULES","ResolvedFile","constructor","sourceName","absolutePath","content","contentHash","lastModificationDate","libraryName","libraryVersion","undefined","library","name","version","getVersionedName","exports","Resolver","_projectRoot","_parser","_readFile","resolveSourceName","_resolveLocalSourceName","_resolveLibrarySourceName","resolveImport","from","imported","scheme","_getUriScheme","errors_1","errors_list_1","RESOLVER","INVALID_IMPORT_PROTOCOL","protocol","INVALID_IMPORT_BACKSLASH","INVALID_IMPORT_ABSOLUTE_PATH","_isRelativeImport","_relativeImportToSourceName","_isRelativeImportToLibrary","error","isHardhatErrorType","FILE_NOT_FOUND","LIBRARY_FILE_NOT_FOUND","IMPORTED_FILE_NOT_FOUND","WRONG_SOURCE_NAME_CASING","INVALID_IMPORT_WRONG_CASING","LIBRARY_NOT_INSTALLED","IMPORTED_LIBRARY_NOT_INSTALLED","messageArguments","_validateSourceNameExistenceAndCasing","path_1","join","_resolveFile","_getLibraryName","packageJsonPath","_resolveNodeModulesFileFromProjectRoot","hardhatCoreDir","__dirname","nodeModulesPath","dirname","_isScopedPackage","packageInfo","fs_extra_1","readJson","realpath","_relativeImportToLibraryToSourceName","startsWith","INVALID_IMPORT_OUTSIDE_OF_PROJECT","_isInsideSameDir","ILLEGAL_IMPORT","rawContent","stats","stat","Date","ctime","Buffer","toString","parsedContent","parse","fileName","resolve_1","sync","basedir","preserveSymlinks","endIndex","indexOf","length","slice","s","re","match","exec","sourceNameInDir","sourceNameToTest","firstSlash","dir","substring","packageOrPackageFile","includes","nmIndex","substr","fromDir","isLibrary","SOURCE_NAMES","file","WRONG_CASING","incorrect","correct"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/internal/solidity/resolver.ts"],"sourcesContent":["import fsExtra from \"fs-extra\";\nimport path from \"path\";\nimport resolve from \"resolve\";\n\nimport {\n  FileContent,\n  LibraryInfo,\n  ResolvedFile as IResolvedFile,\n} from \"../../types/builtin-tasks\";\nimport {\n  isAbsolutePathSourceName,\n  isLocalSourceName,\n  normalizeSourceName,\n  replaceBackslashes,\n  validateSourceNameExistenceAndCasing,\n  validateSourceNameFormat,\n} from \"../../utils/source-names\";\nimport { assertHardhatInvariant, HardhatError } from \"../core/errors\";\nimport { ERRORS } from \"../core/errors-list\";\nimport { createNonCryptographicHashBasedIdentifier } from \"../util/hash\";\n\nimport { Parser } from \"./parse\";\n\nexport interface ResolvedFilesMap {\n  [sourceName: string]: ResolvedFile;\n}\n\nconst NODE_MODULES = \"node_modules\";\n\nexport class ResolvedFile implements IResolvedFile {\n  public readonly library?: LibraryInfo;\n\n  constructor(\n    public readonly sourceName: string,\n    public readonly absolutePath: string,\n    public readonly content: FileContent,\n    public readonly contentHash: string,\n    public readonly lastModificationDate: Date,\n    libraryName?: string,\n    libraryVersion?: string\n  ) {\n    assertHardhatInvariant(\n      (libraryName === undefined && libraryVersion === undefined) ||\n        (libraryName !== undefined && libraryVersion !== undefined),\n      \"Libraries should have both name and version, or neither one\"\n    );\n\n    if (libraryName !== undefined && libraryVersion !== undefined) {\n      this.library = {\n        name: libraryName,\n        version: libraryVersion,\n      };\n    }\n  }\n\n  public getVersionedName() {\n    return (\n      this.sourceName +\n      (this.library !== undefined ? `@v${this.library.version}` : \"\")\n    );\n  }\n}\n\nexport class Resolver {\n  constructor(\n    private readonly _projectRoot: string,\n    private readonly _parser: Parser,\n    private readonly _readFile: (absolutePath: string) => Promise<string>\n  ) {}\n\n  /**\n   * Resolves a source name into a ResolvedFile.\n   *\n   * @param sourceName The source name as it would be provided to solc.\n   */\n  public async resolveSourceName(sourceName: string): Promise<ResolvedFile> {\n    validateSourceNameFormat(sourceName);\n\n    if (await isLocalSourceName(this._projectRoot, sourceName)) {\n      return this._resolveLocalSourceName(sourceName);\n    }\n\n    return this._resolveLibrarySourceName(sourceName);\n  }\n\n  /**\n   * Resolves an import from an already resolved file.\n   * @param from The file were the import statement is present.\n   * @param imported The path in the import statement.\n   */\n  public async resolveImport(\n    from: ResolvedFile,\n    imported: string\n  ): Promise<ResolvedFile> {\n    const scheme = this._getUriScheme(imported);\n    if (scheme !== undefined) {\n      throw new HardhatError(ERRORS.RESOLVER.INVALID_IMPORT_PROTOCOL, {\n        from: from.sourceName,\n        imported,\n        protocol: scheme,\n      });\n    }\n\n    if (replaceBackslashes(imported) !== imported) {\n      throw new HardhatError(ERRORS.RESOLVER.INVALID_IMPORT_BACKSLASH, {\n        from: from.sourceName,\n        imported,\n      });\n    }\n\n    if (isAbsolutePathSourceName(imported)) {\n      throw new HardhatError(ERRORS.RESOLVER.INVALID_IMPORT_ABSOLUTE_PATH, {\n        from: from.sourceName,\n        imported,\n      });\n    }\n\n    try {\n      if (!this._isRelativeImport(imported)) {\n        return await this.resolveSourceName(normalizeSourceName(imported));\n      }\n\n      const sourceName = await this._relativeImportToSourceName(from, imported);\n\n      // We have this special case here, because otherwise local relative\n      // imports can be treated as library imports. For example if\n      // `contracts/c.sol` imports `../non-existent/a.sol`\n      if (\n        from.library === undefined &&\n        !this._isRelativeImportToLibrary(from, imported)\n      ) {\n        return await this._resolveLocalSourceName(sourceName);\n      }\n\n      return await this.resolveSourceName(sourceName);\n    } catch (error) {\n      if (\n        HardhatError.isHardhatErrorType(\n          error,\n          ERRORS.RESOLVER.FILE_NOT_FOUND\n        ) ||\n        HardhatError.isHardhatErrorType(\n          error,\n          ERRORS.RESOLVER.LIBRARY_FILE_NOT_FOUND\n        )\n      ) {\n        throw new HardhatError(\n          ERRORS.RESOLVER.IMPORTED_FILE_NOT_FOUND,\n          {\n            imported,\n            from: from.sourceName,\n          },\n          error\n        );\n      }\n\n      if (\n        HardhatError.isHardhatErrorType(\n          error,\n          ERRORS.RESOLVER.WRONG_SOURCE_NAME_CASING\n        )\n      ) {\n        throw new HardhatError(\n          ERRORS.RESOLVER.INVALID_IMPORT_WRONG_CASING,\n          {\n            imported,\n            from: from.sourceName,\n          },\n          error\n        );\n      }\n\n      if (\n        HardhatError.isHardhatErrorType(\n          error,\n          ERRORS.RESOLVER.LIBRARY_NOT_INSTALLED\n        )\n      ) {\n        throw new HardhatError(\n          ERRORS.RESOLVER.IMPORTED_LIBRARY_NOT_INSTALLED,\n          {\n            library: error.messageArguments.library,\n            from: from.sourceName,\n          },\n          error\n        );\n      }\n\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n  }\n\n  private async _resolveLocalSourceName(\n    sourceName: string\n  ): Promise<ResolvedFile> {\n    await this._validateSourceNameExistenceAndCasing(\n      this._projectRoot,\n      sourceName,\n      false\n    );\n\n    const absolutePath = path.join(this._projectRoot, sourceName);\n    return this._resolveFile(sourceName, absolutePath);\n  }\n\n  private async _resolveLibrarySourceName(\n    sourceName: string\n  ): Promise<ResolvedFile> {\n    const libraryName = this._getLibraryName(sourceName);\n\n    let packageJsonPath;\n    try {\n      packageJsonPath = this._resolveNodeModulesFileFromProjectRoot(\n        path.join(libraryName, \"package.json\")\n      );\n    } catch (error) {\n      // if the project is using a dependency from hardhat itself but it can't\n      // be found, this means that a global installation is being used, so we\n      // resolve the dependency relative to this file\n      if (libraryName === \"hardhat\") {\n        const hardhatCoreDir = path.join(__dirname, \"..\", \"..\");\n        packageJsonPath = path.join(hardhatCoreDir, \"package.json\");\n      } else {\n        throw new HardhatError(\n          ERRORS.RESOLVER.LIBRARY_NOT_INSTALLED,\n          {\n            library: libraryName,\n          },\n          error as Error\n        );\n      }\n    }\n\n    let nodeModulesPath = path.dirname(path.dirname(packageJsonPath));\n    if (this._isScopedPackage(sourceName)) {\n      nodeModulesPath = path.dirname(nodeModulesPath);\n    }\n\n    await this._validateSourceNameExistenceAndCasing(\n      nodeModulesPath,\n      sourceName,\n      true\n    );\n\n    const packageInfo: {\n      name: string;\n      version: string;\n    } = await fsExtra.readJson(packageJsonPath);\n    const libraryVersion = packageInfo.version;\n\n    return this._resolveFile(\n      sourceName,\n      // We resolve to the real path here, as we may be resolving a linked library\n      await fsExtra.realpath(path.join(nodeModulesPath, sourceName)),\n      libraryName,\n      libraryVersion\n    );\n  }\n\n  private async _relativeImportToSourceName(\n    from: ResolvedFile,\n    imported: string\n  ): Promise<string> {\n    // This is a special case, were we turn relative imports from local files\n    // into library imports if necessary. The reason for this is that many\n    // users just do `import \"../node_modules/lib/a.sol\";`.\n    if (this._isRelativeImportToLibrary(from, imported)) {\n      return this._relativeImportToLibraryToSourceName(from, imported);\n    }\n\n    const sourceName = normalizeSourceName(\n      path.join(path.dirname(from.sourceName), imported)\n    );\n\n    // If the file with the import is local, and the normalized version\n    // starts with ../ means that it's trying to get outside of the project.\n    if (from.library === undefined && sourceName.startsWith(\"../\")) {\n      throw new HardhatError(\n        ERRORS.RESOLVER.INVALID_IMPORT_OUTSIDE_OF_PROJECT,\n        { from: from.sourceName, imported }\n      );\n    }\n\n    if (\n      from.library !== undefined &&\n      !this._isInsideSameDir(from.sourceName, sourceName)\n    ) {\n      // If the file is being imported from a library, this means that it's\n      // trying to reach another one.\n      throw new HardhatError(ERRORS.RESOLVER.ILLEGAL_IMPORT, {\n        from: from.sourceName,\n        imported,\n      });\n    }\n\n    return sourceName;\n  }\n\n  private async _resolveFile(\n    sourceName: string,\n    absolutePath: string,\n    libraryName?: string,\n    libraryVersion?: string\n  ): Promise<ResolvedFile> {\n    const rawContent = await this._readFile(absolutePath);\n    const stats = await fsExtra.stat(absolutePath);\n    const lastModificationDate = new Date(stats.ctime);\n\n    const contentHash = createNonCryptographicHashBasedIdentifier(\n      Buffer.from(rawContent)\n    ).toString(\"hex\");\n\n    const parsedContent = this._parser.parse(\n      rawContent,\n      absolutePath,\n      contentHash\n    );\n\n    const content = {\n      rawContent,\n      ...parsedContent,\n    };\n\n    return new ResolvedFile(\n      sourceName,\n      absolutePath,\n      content,\n      contentHash,\n      lastModificationDate,\n      libraryName,\n      libraryVersion\n    );\n  }\n\n  private _isRelativeImport(imported: string): boolean {\n    return imported.startsWith(\"./\") || imported.startsWith(\"../\");\n  }\n\n  private _resolveNodeModulesFileFromProjectRoot(fileName: string) {\n    return resolve.sync(fileName, {\n      basedir: this._projectRoot,\n      preserveSymlinks: true,\n    });\n  }\n\n  private _getLibraryName(sourceName: string): string {\n    let endIndex: number;\n    if (this._isScopedPackage(sourceName)) {\n      endIndex = sourceName.indexOf(\"/\", sourceName.indexOf(\"/\") + 1);\n    } else if (sourceName.indexOf(\"/\") === -1) {\n      endIndex = sourceName.length;\n    } else {\n      endIndex = sourceName.indexOf(\"/\");\n    }\n\n    return sourceName.slice(0, endIndex);\n  }\n\n  private _getUriScheme(s: string): string | undefined {\n    const re = /([a-zA-Z]+):\\/\\//;\n    const match = re.exec(s);\n    if (match === null) {\n      return undefined;\n    }\n\n    return match[1];\n  }\n\n  private _isInsideSameDir(sourceNameInDir: string, sourceNameToTest: string) {\n    const firstSlash = sourceNameInDir.indexOf(\"/\");\n    const dir =\n      firstSlash !== -1\n        ? sourceNameInDir.substring(0, firstSlash)\n        : sourceNameInDir;\n\n    return sourceNameToTest.startsWith(dir);\n  }\n\n  private _isScopedPackage(packageOrPackageFile: string): boolean {\n    return packageOrPackageFile.startsWith(\"@\");\n  }\n\n  private _isRelativeImportToLibrary(\n    from: ResolvedFile,\n    imported: string\n  ): boolean {\n    return (\n      this._isRelativeImport(imported) &&\n      from.library === undefined &&\n      imported.includes(`${NODE_MODULES}/`)\n    );\n  }\n\n  private _relativeImportToLibraryToSourceName(\n    from: ResolvedFile,\n    imported: string\n  ): string {\n    const sourceName = normalizeSourceName(\n      path.join(path.dirname(from.sourceName), imported)\n    );\n\n    const nmIndex = sourceName.indexOf(`${NODE_MODULES}/`);\n    return sourceName.substr(nmIndex + NODE_MODULES.length + 1);\n  }\n\n  private async _validateSourceNameExistenceAndCasing(\n    fromDir: string,\n    sourceName: string,\n    isLibrary: boolean\n  ) {\n    try {\n      await validateSourceNameExistenceAndCasing(fromDir, sourceName);\n    } catch (error) {\n      if (\n        HardhatError.isHardhatErrorType(\n          error,\n          ERRORS.SOURCE_NAMES.FILE_NOT_FOUND\n        )\n      ) {\n        throw new HardhatError(\n          isLibrary\n            ? ERRORS.RESOLVER.LIBRARY_FILE_NOT_FOUND\n            : ERRORS.RESOLVER.FILE_NOT_FOUND,\n          { file: sourceName },\n          error\n        );\n      }\n\n      if (\n        HardhatError.isHardhatErrorType(error, ERRORS.SOURCE_NAMES.WRONG_CASING)\n      ) {\n        throw new HardhatError(\n          ERRORS.RESOLVER.WRONG_SOURCE_NAME_CASING,\n          {\n            incorrect: sourceName,\n            correct: error.messageArguments.correct,\n          },\n          error\n        );\n      }\n\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}