{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findDistance = exports.parseName = exports.parseFullyQualifiedName = exports.isFullyQualifiedName = exports.getFullyQualifiedName = void 0;\n\nconst errors_1 = require(\"../internal/core/errors\");\n\nconst errors_list_1 = require(\"../internal/core/errors-list\");\n/**\n * Returns a fully qualified name from a sourceName and contractName.\n */\n\n\nfunction getFullyQualifiedName(sourceName, contractName) {\n  return `${sourceName}:${contractName}`;\n}\n\nexports.getFullyQualifiedName = getFullyQualifiedName;\n/**\n * Returns true if a name is fully qualified, and not just a bare contract name.\n */\n\nfunction isFullyQualifiedName(name) {\n  return name.includes(\":\");\n}\n\nexports.isFullyQualifiedName = isFullyQualifiedName;\n/**\n * Parses a fully qualified name.\n *\n * @param fullyQualifiedName It MUST be a fully qualified name.\n */\n\nfunction parseFullyQualifiedName(fullyQualifiedName) {\n  const {\n    sourceName,\n    contractName\n  } = parseName(fullyQualifiedName);\n\n  if (sourceName === undefined) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.CONTRACT_NAMES.INVALID_FULLY_QUALIFIED_NAME, {\n      name: fullyQualifiedName\n    });\n  }\n\n  return {\n    sourceName,\n    contractName\n  };\n}\n\nexports.parseFullyQualifiedName = parseFullyQualifiedName;\n/**\n * Parses a name, which can be a bare contract name, or a fully qualified name.\n */\n\nfunction parseName(name) {\n  const parts = name.split(\":\");\n\n  if (parts.length === 1) {\n    return {\n      contractName: parts[0]\n    };\n  }\n\n  const contractName = parts[parts.length - 1];\n  const sourceName = parts.slice(0, parts.length - 1).join(\":\");\n  return {\n    sourceName,\n    contractName\n  };\n}\n\nexports.parseName = parseName;\n/**\n * Returns the edit-distance between two given strings using Levenshtein distance.\n *\n * @param a First string being compared\n * @param b Second string being compared\n * @returns distance between the two strings (lower number == more similar)\n * @see https://github.com/gustf/js-levenshtein\n * @license MIT - https://github.com/gustf/js-levenshtein/blob/master/LICENSE\n */\n\nfunction findDistance(a, b) {\n  function _min(_d0, _d1, _d2, _bx, _ay) {\n    return _d0 < _d1 || _d2 < _d1 ? _d0 > _d2 ? _d2 + 1 : _d0 + 1 : _bx === _ay ? _d1 : _d1 + 1;\n  }\n\n  if (a === b) {\n    return 0;\n  }\n\n  if (a.length > b.length) {\n    [a, b] = [b, a];\n  }\n\n  let la = a.length;\n  let lb = b.length;\n\n  while (la > 0 && a.charCodeAt(la - 1) === b.charCodeAt(lb - 1)) {\n    la--;\n    lb--;\n  }\n\n  let offset = 0;\n\n  while (offset < la && a.charCodeAt(offset) === b.charCodeAt(offset)) {\n    offset++;\n  }\n\n  la -= offset;\n  lb -= offset;\n\n  if (la === 0 || lb < 3) {\n    return lb;\n  }\n\n  let x = 0;\n  let y;\n  let d0;\n  let d1;\n  let d2;\n  let d3;\n  let dd = 0; // typescript gets angry if we don't assign here\n\n  let dy;\n  let ay;\n  let bx0;\n  let bx1;\n  let bx2;\n  let bx3;\n  const vector = [];\n\n  for (y = 0; y < la; y++) {\n    vector.push(y + 1);\n    vector.push(a.charCodeAt(offset + y));\n  }\n\n  const len = vector.length - 1;\n\n  for (; x < lb - 3;) {\n    bx0 = b.charCodeAt(offset + (d0 = x));\n    bx1 = b.charCodeAt(offset + (d1 = x + 1));\n    bx2 = b.charCodeAt(offset + (d2 = x + 2));\n    bx3 = b.charCodeAt(offset + (d3 = x + 3));\n    dd = x += 4;\n\n    for (y = 0; y < len; y += 2) {\n      dy = vector[y];\n      ay = vector[y + 1];\n      d0 = _min(dy, d0, d1, bx0, ay);\n      d1 = _min(d0, d1, d2, bx1, ay);\n      d2 = _min(d1, d2, d3, bx2, ay);\n      dd = _min(d2, d3, dd, bx3, ay);\n      vector[y] = dd;\n      d3 = d2;\n      d2 = d1;\n      d1 = d0;\n      d0 = dy;\n    }\n  }\n\n  for (; x < lb;) {\n    bx0 = b.charCodeAt(offset + (d0 = x));\n    dd = ++x;\n\n    for (y = 0; y < len; y += 2) {\n      dy = vector[y];\n      vector[y] = dd = _min(dy, d0, dd, bx0, vector[y + 1]);\n      d0 = dy;\n    }\n  }\n\n  return dd;\n}\n\nexports.findDistance = findDistance;","map":{"version":3,"mappings":"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","names":["getFullyQualifiedName","sourceName","contractName","exports","isFullyQualifiedName","name","includes","parseFullyQualifiedName","fullyQualifiedName","parseName","undefined","errors_1","errors_list_1","CONTRACT_NAMES","INVALID_FULLY_QUALIFIED_NAME","parts","split","length","slice","join","findDistance","a","b","_min","_d0","_d1","_d2","_bx","_ay","la","lb","charCodeAt","offset","x","y","d0","d1","d2","d3","dd","dy","ay","bx0","bx1","bx2","bx3","vector","push","len"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/hardhat/src/utils/contract-names.ts"],"sourcesContent":["import { HardhatError } from \"../internal/core/errors\";\nimport { ERRORS } from \"../internal/core/errors-list\";\n\n/**\n * Returns a fully qualified name from a sourceName and contractName.\n */\nexport function getFullyQualifiedName(\n  sourceName: string,\n  contractName: string\n): string {\n  return `${sourceName}:${contractName}`;\n}\n\n/**\n * Returns true if a name is fully qualified, and not just a bare contract name.\n */\nexport function isFullyQualifiedName(name: string): boolean {\n  return name.includes(\":\");\n}\n\n/**\n * Parses a fully qualified name.\n *\n * @param fullyQualifiedName It MUST be a fully qualified name.\n */\nexport function parseFullyQualifiedName(fullyQualifiedName: string): {\n  sourceName: string;\n  contractName: string;\n} {\n  const { sourceName, contractName } = parseName(fullyQualifiedName);\n\n  if (sourceName === undefined) {\n    throw new HardhatError(ERRORS.CONTRACT_NAMES.INVALID_FULLY_QUALIFIED_NAME, {\n      name: fullyQualifiedName,\n    });\n  }\n\n  return { sourceName, contractName };\n}\n\n/**\n * Parses a name, which can be a bare contract name, or a fully qualified name.\n */\nexport function parseName(name: string): {\n  sourceName?: string;\n  contractName: string;\n} {\n  const parts = name.split(\":\");\n\n  if (parts.length === 1) {\n    return { contractName: parts[0] };\n  }\n\n  const contractName = parts[parts.length - 1];\n  const sourceName = parts.slice(0, parts.length - 1).join(\":\");\n\n  return { sourceName, contractName };\n}\n\n/**\n * Returns the edit-distance between two given strings using Levenshtein distance.\n *\n * @param a First string being compared\n * @param b Second string being compared\n * @returns distance between the two strings (lower number == more similar)\n * @see https://github.com/gustf/js-levenshtein\n * @license MIT - https://github.com/gustf/js-levenshtein/blob/master/LICENSE\n */\nexport function findDistance(a: string, b: string): number {\n  function _min(\n    _d0: number,\n    _d1: number,\n    _d2: number,\n    _bx: number,\n    _ay: number\n  ): number {\n    return _d0 < _d1 || _d2 < _d1\n      ? _d0 > _d2\n        ? _d2 + 1\n        : _d0 + 1\n      : _bx === _ay\n      ? _d1\n      : _d1 + 1;\n  }\n\n  if (a === b) {\n    return 0;\n  }\n\n  if (a.length > b.length) {\n    [a, b] = [b, a];\n  }\n\n  let la = a.length;\n  let lb = b.length;\n\n  while (la > 0 && a.charCodeAt(la - 1) === b.charCodeAt(lb - 1)) {\n    la--;\n    lb--;\n  }\n\n  let offset = 0;\n\n  while (offset < la && a.charCodeAt(offset) === b.charCodeAt(offset)) {\n    offset++;\n  }\n\n  la -= offset;\n  lb -= offset;\n\n  if (la === 0 || lb < 3) {\n    return lb;\n  }\n\n  let x = 0;\n  let y: number;\n  let d0: number;\n  let d1: number;\n  let d2: number;\n  let d3: number;\n  let dd: number = 0; // typescript gets angry if we don't assign here\n  let dy: number;\n  let ay: number;\n  let bx0: number;\n  let bx1: number;\n  let bx2: number;\n  let bx3: number;\n\n  const vector = [];\n\n  for (y = 0; y < la; y++) {\n    vector.push(y + 1);\n    vector.push(a.charCodeAt(offset + y));\n  }\n\n  const len = vector.length - 1;\n\n  for (; x < lb - 3; ) {\n    bx0 = b.charCodeAt(offset + (d0 = x));\n    bx1 = b.charCodeAt(offset + (d1 = x + 1));\n    bx2 = b.charCodeAt(offset + (d2 = x + 2));\n    bx3 = b.charCodeAt(offset + (d3 = x + 3));\n    dd = x += 4;\n    for (y = 0; y < len; y += 2) {\n      dy = vector[y];\n      ay = vector[y + 1];\n      d0 = _min(dy, d0, d1, bx0, ay);\n      d1 = _min(d0, d1, d2, bx1, ay);\n      d2 = _min(d1, d2, d3, bx2, ay);\n      dd = _min(d2, d3, dd, bx3, ay);\n      vector[y] = dd;\n      d3 = d2;\n      d2 = d1;\n      d1 = d0;\n      d0 = dy;\n    }\n  }\n\n  for (; x < lb; ) {\n    bx0 = b.charCodeAt(offset + (d0 = x));\n    dd = ++x;\n    for (y = 0; y < len; y += 2) {\n      dy = vector[y];\n      vector[y] = dd = _min(dy, d0, dd, bx0, vector[y + 1]);\n      d0 = dy;\n    }\n  }\n\n  return dd;\n}\n"]},"metadata":{},"sourceType":"script"}