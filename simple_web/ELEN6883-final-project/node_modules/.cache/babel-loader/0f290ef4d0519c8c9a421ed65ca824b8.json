{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\nimport { browserPerformanceTimeOrigin, getGlobalObject, logger } from '@sentry/utils';\nimport { msToSec } from '../utils';\nimport { getCLS } from './web-vitals/getCLS';\nimport { getFID } from './web-vitals/getFID';\nimport { getLCP } from './web-vitals/getLCP';\nimport { getTTFB } from './web-vitals/getTTFB';\nimport { getFirstHidden } from './web-vitals/lib/getFirstHidden';\nvar global = getGlobalObject();\n/** Class tracking metrics  */\n\nvar MetricsInstrumentation =\n/** @class */\nfunction () {\n  function MetricsInstrumentation() {\n    this._measurements = {};\n    this._performanceCursor = 0;\n\n    if (global && global.performance) {\n      if (global.performance.mark) {\n        global.performance.mark('sentry-tracing-init');\n      }\n\n      this._trackCLS();\n\n      this._trackLCP();\n\n      this._trackFID();\n\n      this._trackTTFB();\n    }\n  }\n  /** Add performance related spans to a transaction */\n\n\n  MetricsInstrumentation.prototype.addPerformanceEntries = function (transaction) {\n    var _this = this;\n\n    if (!global || !global.performance || !global.performance.getEntries || !browserPerformanceTimeOrigin) {\n      // Gatekeeper if performance API not available\n      return;\n    }\n\n    logger.log('[Tracing] Adding & adjusting spans using Performance API');\n    var timeOrigin = msToSec(browserPerformanceTimeOrigin);\n    var entryScriptSrc;\n\n    if (global.document) {\n      // eslint-disable-next-line @typescript-eslint/prefer-for-of\n      for (var i = 0; i < document.scripts.length; i++) {\n        // We go through all scripts on the page and look for 'data-entry'\n        // We remember the name and measure the time between this script finished loading and\n        // our mark 'sentry-tracing-init'\n        if (document.scripts[i].dataset.entry === 'true') {\n          entryScriptSrc = document.scripts[i].src;\n          break;\n        }\n      }\n    }\n\n    var entryScriptStartTimestamp;\n    var tracingInitMarkStartTime;\n    global.performance.getEntries().slice(this._performanceCursor).forEach(function (entry) {\n      var startTime = msToSec(entry.startTime);\n      var duration = msToSec(entry.duration);\n\n      if (transaction.op === 'navigation' && timeOrigin + startTime < transaction.startTimestamp) {\n        return;\n      }\n\n      switch (entry.entryType) {\n        case 'navigation':\n          addNavigationSpans(transaction, entry, timeOrigin);\n          break;\n\n        case 'mark':\n        case 'paint':\n        case 'measure':\n          {\n            var startTimestamp = addMeasureSpans(transaction, entry, startTime, duration, timeOrigin);\n\n            if (tracingInitMarkStartTime === undefined && entry.name === 'sentry-tracing-init') {\n              tracingInitMarkStartTime = startTimestamp;\n            } // capture web vitals\n\n\n            var firstHidden = getFirstHidden(); // Only report if the page wasn't hidden prior to the web vital.\n\n            var shouldRecord = entry.startTime < firstHidden.timeStamp;\n\n            if (entry.name === 'first-paint' && shouldRecord) {\n              logger.log('[Measurements] Adding FP');\n              _this._measurements['fp'] = {\n                value: entry.startTime\n              };\n              _this._measurements['mark.fp'] = {\n                value: startTimestamp\n              };\n            }\n\n            if (entry.name === 'first-contentful-paint' && shouldRecord) {\n              logger.log('[Measurements] Adding FCP');\n              _this._measurements['fcp'] = {\n                value: entry.startTime\n              };\n              _this._measurements['mark.fcp'] = {\n                value: startTimestamp\n              };\n            }\n\n            break;\n          }\n\n        case 'resource':\n          {\n            var resourceName = entry.name.replace(window.location.origin, '');\n            var endTimestamp = addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin); // We remember the entry script end time to calculate the difference to the first init mark\n\n            if (entryScriptStartTimestamp === undefined && (entryScriptSrc || '').indexOf(resourceName) > -1) {\n              entryScriptStartTimestamp = endTimestamp;\n            }\n\n            break;\n          }\n\n        default: // Ignore other entry types.\n\n      }\n    });\n\n    if (entryScriptStartTimestamp !== undefined && tracingInitMarkStartTime !== undefined) {\n      _startChild(transaction, {\n        description: 'evaluation',\n        endTimestamp: tracingInitMarkStartTime,\n        op: 'script',\n        startTimestamp: entryScriptStartTimestamp\n      });\n    }\n\n    this._performanceCursor = Math.max(performance.getEntries().length - 1, 0);\n\n    this._trackNavigator(transaction); // Measurements are only available for pageload transactions\n\n\n    if (transaction.op === 'pageload') {\n      // normalize applicable web vital values to be relative to transaction.startTimestamp\n      var timeOrigin_1 = msToSec(browserPerformanceTimeOrigin);\n      ['fcp', 'fp', 'lcp', 'ttfb'].forEach(function (name) {\n        if (!_this._measurements[name] || timeOrigin_1 >= transaction.startTimestamp) {\n          return;\n        } // The web vitals, fcp, fp, lcp, and ttfb, all measure relative to timeOrigin.\n        // Unfortunately, timeOrigin is not captured within the transaction span data, so these web vitals will need\n        // to be adjusted to be relative to transaction.startTimestamp.\n\n\n        var oldValue = _this._measurements[name].value;\n        var measurementTimestamp = timeOrigin_1 + msToSec(oldValue); // normalizedValue should be in milliseconds\n\n        var normalizedValue = Math.abs((measurementTimestamp - transaction.startTimestamp) * 1000);\n        var delta = normalizedValue - oldValue;\n        logger.log(\"[Measurements] Normalized \" + name + \" from \" + oldValue + \" to \" + normalizedValue + \" (\" + delta + \")\");\n        _this._measurements[name].value = normalizedValue;\n      });\n\n      if (this._measurements['mark.fid'] && this._measurements['fid']) {\n        // create span for FID\n        _startChild(transaction, {\n          description: 'first input delay',\n          endTimestamp: this._measurements['mark.fid'].value + msToSec(this._measurements['fid'].value),\n          op: 'web.vitals',\n          startTimestamp: this._measurements['mark.fid'].value\n        });\n      }\n\n      transaction.setMeasurements(this._measurements);\n    }\n  };\n  /** Starts tracking the Cumulative Layout Shift on the current page. */\n\n\n  MetricsInstrumentation.prototype._trackCLS = function () {\n    var _this = this;\n\n    getCLS(function (metric) {\n      var entry = metric.entries.pop();\n\n      if (!entry) {\n        return;\n      }\n\n      logger.log('[Measurements] Adding CLS');\n      _this._measurements['cls'] = {\n        value: metric.value\n      };\n    });\n  };\n  /**\n   * Capture the information of the user agent.\n   */\n\n\n  MetricsInstrumentation.prototype._trackNavigator = function (transaction) {\n    var navigator = global.navigator;\n\n    if (!navigator) {\n      return;\n    } // track network connectivity\n\n\n    var connection = navigator.connection;\n\n    if (connection) {\n      if (connection.effectiveType) {\n        transaction.setTag('effectiveConnectionType', connection.effectiveType);\n      }\n\n      if (connection.type) {\n        transaction.setTag('connectionType', connection.type);\n      }\n\n      if (isMeasurementValue(connection.rtt)) {\n        this._measurements['connection.rtt'] = {\n          value: connection.rtt\n        };\n      }\n\n      if (isMeasurementValue(connection.downlink)) {\n        this._measurements['connection.downlink'] = {\n          value: connection.downlink\n        };\n      }\n    }\n\n    if (isMeasurementValue(navigator.deviceMemory)) {\n      transaction.setTag('deviceMemory', String(navigator.deviceMemory));\n    }\n\n    if (isMeasurementValue(navigator.hardwareConcurrency)) {\n      transaction.setTag('hardwareConcurrency', String(navigator.hardwareConcurrency));\n    }\n  };\n  /** Starts tracking the Largest Contentful Paint on the current page. */\n\n\n  MetricsInstrumentation.prototype._trackLCP = function () {\n    var _this = this;\n\n    getLCP(function (metric) {\n      var entry = metric.entries.pop();\n\n      if (!entry) {\n        return;\n      }\n\n      var timeOrigin = msToSec(performance.timeOrigin);\n      var startTime = msToSec(entry.startTime);\n      logger.log('[Measurements] Adding LCP');\n      _this._measurements['lcp'] = {\n        value: metric.value\n      };\n      _this._measurements['mark.lcp'] = {\n        value: timeOrigin + startTime\n      };\n    });\n  };\n  /** Starts tracking the First Input Delay on the current page. */\n\n\n  MetricsInstrumentation.prototype._trackFID = function () {\n    var _this = this;\n\n    getFID(function (metric) {\n      var entry = metric.entries.pop();\n\n      if (!entry) {\n        return;\n      }\n\n      var timeOrigin = msToSec(performance.timeOrigin);\n      var startTime = msToSec(entry.startTime);\n      logger.log('[Measurements] Adding FID');\n      _this._measurements['fid'] = {\n        value: metric.value\n      };\n      _this._measurements['mark.fid'] = {\n        value: timeOrigin + startTime\n      };\n    });\n  };\n  /** Starts tracking the Time to First Byte on the current page. */\n\n\n  MetricsInstrumentation.prototype._trackTTFB = function () {\n    var _this = this;\n\n    getTTFB(function (metric) {\n      var _a;\n\n      var entry = metric.entries.pop();\n\n      if (!entry) {\n        return;\n      }\n\n      logger.log('[Measurements] Adding TTFB');\n      _this._measurements['ttfb'] = {\n        value: metric.value\n      }; // Capture the time spent making the request and receiving the first byte of the response\n\n      var requestTime = metric.value - (_a = metric.entries[0], _a !== null && _a !== void 0 ? _a : entry).requestStart;\n      _this._measurements['ttfb.requestTime'] = {\n        value: requestTime\n      };\n    });\n  };\n\n  return MetricsInstrumentation;\n}();\n\nexport { MetricsInstrumentation };\n/** Instrument navigation entries */\n\nfunction addNavigationSpans(transaction, entry, timeOrigin) {\n  addPerformanceNavigationTiming(transaction, entry, 'unloadEvent', timeOrigin);\n  addPerformanceNavigationTiming(transaction, entry, 'redirect', timeOrigin);\n  addPerformanceNavigationTiming(transaction, entry, 'domContentLoadedEvent', timeOrigin);\n  addPerformanceNavigationTiming(transaction, entry, 'loadEvent', timeOrigin);\n  addPerformanceNavigationTiming(transaction, entry, 'connect', timeOrigin);\n  addPerformanceNavigationTiming(transaction, entry, 'secureConnection', timeOrigin, 'connectEnd');\n  addPerformanceNavigationTiming(transaction, entry, 'fetch', timeOrigin, 'domainLookupStart');\n  addPerformanceNavigationTiming(transaction, entry, 'domainLookup', timeOrigin);\n  addRequest(transaction, entry, timeOrigin);\n}\n/** Create measure related spans */\n\n\nfunction addMeasureSpans(transaction, entry, startTime, duration, timeOrigin) {\n  var measureStartTimestamp = timeOrigin + startTime;\n  var measureEndTimestamp = measureStartTimestamp + duration;\n\n  _startChild(transaction, {\n    description: entry.name,\n    endTimestamp: measureEndTimestamp,\n    op: entry.entryType,\n    startTimestamp: measureStartTimestamp\n  });\n\n  return measureStartTimestamp;\n}\n/** Create resource-related spans */\n\n\nexport function addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin) {\n  // we already instrument based on fetch and xhr, so we don't need to\n  // duplicate spans here.\n  if (entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch') {\n    return undefined;\n  }\n\n  var data = {};\n\n  if ('transferSize' in entry) {\n    data['Transfer Size'] = entry.transferSize;\n  }\n\n  if ('encodedBodySize' in entry) {\n    data['Encoded Body Size'] = entry.encodedBodySize;\n  }\n\n  if ('decodedBodySize' in entry) {\n    data['Decoded Body Size'] = entry.decodedBodySize;\n  }\n\n  var startTimestamp = timeOrigin + startTime;\n  var endTimestamp = startTimestamp + duration;\n\n  _startChild(transaction, {\n    description: resourceName,\n    endTimestamp: endTimestamp,\n    op: entry.initiatorType ? \"resource.\" + entry.initiatorType : 'resource',\n    startTimestamp: startTimestamp,\n    data: data\n  });\n\n  return endTimestamp;\n}\n/** Create performance navigation related spans */\n\nfunction addPerformanceNavigationTiming(transaction, entry, event, timeOrigin, eventEnd) {\n  var end = eventEnd ? entry[eventEnd] : entry[event + \"End\"];\n  var start = entry[event + \"Start\"];\n\n  if (!start || !end) {\n    return;\n  }\n\n  _startChild(transaction, {\n    op: 'browser',\n    description: event,\n    startTimestamp: timeOrigin + msToSec(start),\n    endTimestamp: timeOrigin + msToSec(end)\n  });\n}\n/** Create request and response related spans */\n\n\nfunction addRequest(transaction, entry, timeOrigin) {\n  _startChild(transaction, {\n    op: 'browser',\n    description: 'request',\n    startTimestamp: timeOrigin + msToSec(entry.requestStart),\n    endTimestamp: timeOrigin + msToSec(entry.responseEnd)\n  });\n\n  _startChild(transaction, {\n    op: 'browser',\n    description: 'response',\n    startTimestamp: timeOrigin + msToSec(entry.responseStart),\n    endTimestamp: timeOrigin + msToSec(entry.responseEnd)\n  });\n}\n/**\n * Helper function to start child on transactions. This function will make sure that the transaction will\n * use the start timestamp of the created child span if it is earlier than the transactions actual\n * start timestamp.\n */\n\n\nexport function _startChild(transaction, _a) {\n  var startTimestamp = _a.startTimestamp,\n      ctx = __rest(_a, [\"startTimestamp\"]);\n\n  if (startTimestamp && transaction.startTimestamp > startTimestamp) {\n    transaction.startTimestamp = startTimestamp;\n  }\n\n  return transaction.startChild(__assign({\n    startTimestamp: startTimestamp\n  }, ctx));\n}\n/**\n * Checks if a given value is a valid measurement value.\n */\n\nfunction isMeasurementValue(value) {\n  return typeof value === 'number' && isFinite(value);\n}","map":{"version":3,"mappings":";AAGA,SAASA,4BAAT,EAAuCC,eAAvC,EAAwDC,MAAxD,QAAsE,eAAtE;AAIA,SAASC,OAAT,QAAwB,UAAxB;AACA,SAASC,MAAT,QAAuB,qBAAvB;AACA,SAASC,MAAT,QAAuB,qBAAvB;AACA,SAASC,MAAT,QAAuB,qBAAvB;AACA,SAASC,OAAT,QAAwB,sBAAxB;AACA,SAASC,cAAT,QAA+B,iCAA/B;AAGA,IAAMC,MAAM,GAAGR,eAAe,EAA9B;AAEA;;AACA;AAAA;AAAA;AAKE;AAJQ,yBAA8B,EAA9B;AAEA,8BAA6B,CAA7B;;AAGN,QAAIQ,MAAM,IAAIA,MAAM,CAACC,WAArB,EAAkC;AAChC,UAAID,MAAM,CAACC,WAAP,CAAmBC,IAAvB,EAA6B;AAC3BF,cAAM,CAACC,WAAP,CAAmBC,IAAnB,CAAwB,qBAAxB;AACD;;AAED,WAAKC,SAAL;;AACA,WAAKC,SAAL;;AACA,WAAKC,SAAL;;AACA,WAAKC,UAAL;AACD;AACF;AAED;;;AACOC,2DAAP,UAA6BC,WAA7B,EAAqD;AAArD;;AACE,QAAI,CAACR,MAAD,IAAW,CAACA,MAAM,CAACC,WAAnB,IAAkC,CAACD,MAAM,CAACC,WAAP,CAAmBQ,UAAtD,IAAoE,CAAClB,4BAAzE,EAAuG;AACrG;AACA;AACD;;AAEDE,UAAM,CAACiB,GAAP,CAAW,0DAAX;AAEA,QAAMC,UAAU,GAAGjB,OAAO,CAACH,4BAAD,CAA1B;AACA,QAAIqB,cAAJ;;AAEA,QAAIZ,MAAM,CAACa,QAAX,EAAqB;AACnB;AACA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,QAAQ,CAACE,OAAT,CAAiBC,MAArC,EAA6CF,CAAC,EAA9C,EAAkD;AAChD;AACA;AACA;AACA,YAAID,QAAQ,CAACE,OAAT,CAAiBD,CAAjB,EAAoBG,OAApB,CAA4BC,KAA5B,KAAsC,MAA1C,EAAkD;AAChDN,wBAAc,GAAGC,QAAQ,CAACE,OAAT,CAAiBD,CAAjB,EAAoBK,GAArC;AACA;AACD;AACF;AACF;;AAED,QAAIC,yBAAJ;AACA,QAAIC,wBAAJ;AAEArB,UAAM,CAACC,WAAP,CACGQ,UADH,GAEGa,KAFH,CAES,KAAKC,kBAFd,EAGGC,OAHH,CAGW,UAACN,KAAD,EAA2B;AAClC,UAAMO,SAAS,GAAG/B,OAAO,CAACwB,KAAK,CAACO,SAAP,CAAzB;AACA,UAAMC,QAAQ,GAAGhC,OAAO,CAACwB,KAAK,CAACQ,QAAP,CAAxB;;AAEA,UAAIlB,WAAW,CAACmB,EAAZ,KAAmB,YAAnB,IAAmChB,UAAU,GAAGc,SAAb,GAAyBjB,WAAW,CAACoB,cAA5E,EAA4F;AAC1F;AACD;;AAED,cAAQV,KAAK,CAACW,SAAd;AACE,aAAK,YAAL;AACEC,4BAAkB,CAACtB,WAAD,EAAcU,KAAd,EAAqBP,UAArB,CAAlB;AACA;;AACF,aAAK,MAAL;AACA,aAAK,OAAL;AACA,aAAK,SAAL;AAAgB;AACd,gBAAMiB,cAAc,GAAGG,eAAe,CAACvB,WAAD,EAAcU,KAAd,EAAqBO,SAArB,EAAgCC,QAAhC,EAA0Cf,UAA1C,CAAtC;;AACA,gBAAIU,wBAAwB,KAAKW,SAA7B,IAA0Cd,KAAK,CAACe,IAAN,KAAe,qBAA7D,EAAoF;AAClFZ,sCAAwB,GAAGO,cAA3B;AACD,aAJa,CAMd;;;AAEA,gBAAMM,WAAW,GAAGnC,cAAc,EAAlC,CARc,CASd;;AACA,gBAAMoC,YAAY,GAAGjB,KAAK,CAACO,SAAN,GAAkBS,WAAW,CAACE,SAAnD;;AAEA,gBAAIlB,KAAK,CAACe,IAAN,KAAe,aAAf,IAAgCE,YAApC,EAAkD;AAChD1C,oBAAM,CAACiB,GAAP,CAAW,0BAAX;AACA2B,mBAAI,CAACC,aAAL,CAAmB,IAAnB,IAA2B;AAAEC,qBAAK,EAAErB,KAAK,CAACO;AAAf,eAA3B;AACAY,mBAAI,CAACC,aAAL,CAAmB,SAAnB,IAAgC;AAAEC,qBAAK,EAAEX;AAAT,eAAhC;AACD;;AAED,gBAAIV,KAAK,CAACe,IAAN,KAAe,wBAAf,IAA2CE,YAA/C,EAA6D;AAC3D1C,oBAAM,CAACiB,GAAP,CAAW,2BAAX;AACA2B,mBAAI,CAACC,aAAL,CAAmB,KAAnB,IAA4B;AAAEC,qBAAK,EAAErB,KAAK,CAACO;AAAf,eAA5B;AACAY,mBAAI,CAACC,aAAL,CAAmB,UAAnB,IAAiC;AAAEC,qBAAK,EAAEX;AAAT,eAAjC;AACD;;AAED;AACD;;AACD,aAAK,UAAL;AAAiB;AACf,gBAAMY,YAAY,GAAItB,KAAK,CAACe,IAAN,CAAsBQ,OAAtB,CAA8BC,MAAM,CAACC,QAAP,CAAgBC,MAA9C,EAAsD,EAAtD,CAAtB;AACA,gBAAMC,YAAY,GAAGC,gBAAgB,CAACtC,WAAD,EAAcU,KAAd,EAAqBsB,YAArB,EAAmCf,SAAnC,EAA8CC,QAA9C,EAAwDf,UAAxD,CAArC,CAFe,CAGf;;AACA,gBAAIS,yBAAyB,KAAKY,SAA9B,IAA2C,CAACpB,cAAc,IAAI,EAAnB,EAAuBmC,OAAvB,CAA+BP,YAA/B,IAA+C,CAAC,CAA/F,EAAkG;AAChGpB,uCAAyB,GAAGyB,YAA5B;AACD;;AACD;AACD;;AACD,gBAzCF,CA0CE;;AA1CF;AA4CD,KAvDH;;AAyDA,QAAIzB,yBAAyB,KAAKY,SAA9B,IAA2CX,wBAAwB,KAAKW,SAA5E,EAAuF;AACrFgB,iBAAW,CAACxC,WAAD,EAAc;AACvByC,mBAAW,EAAE,YADU;AAEvBJ,oBAAY,EAAExB,wBAFS;AAGvBM,UAAE,EAAE,QAHmB;AAIvBC,sBAAc,EAAER;AAJO,OAAd,CAAX;AAMD;;AAED,SAAKG,kBAAL,GAA0B2B,IAAI,CAACC,GAAL,CAASlD,WAAW,CAACQ,UAAZ,GAAyBO,MAAzB,GAAkC,CAA3C,EAA8C,CAA9C,CAA1B;;AAEA,SAAKoC,eAAL,CAAqB5C,WAArB,EA/FmD,CAiGnD;;;AACA,QAAIA,WAAW,CAACmB,EAAZ,KAAmB,UAAvB,EAAmC;AACjC;AAEA,UAAM0B,YAAU,GAAG3D,OAAO,CAACH,4BAAD,CAA1B;AAEA,OAAC,KAAD,EAAQ,IAAR,EAAc,KAAd,EAAqB,MAArB,EAA6BiC,OAA7B,CAAqC,gBAAI;AACvC,YAAI,CAACa,KAAI,CAACC,aAAL,CAAmBL,IAAnB,CAAD,IAA6BoB,YAAU,IAAI7C,WAAW,CAACoB,cAA3D,EAA2E;AACzE;AACD,SAHsC,CAKvC;AACA;AACA;;;AAEA,YAAM0B,QAAQ,GAAGjB,KAAI,CAACC,aAAL,CAAmBL,IAAnB,EAAyBM,KAA1C;AACA,YAAMgB,oBAAoB,GAAGF,YAAU,GAAG3D,OAAO,CAAC4D,QAAD,CAAjD,CAVuC,CAWvC;;AACA,YAAME,eAAe,GAAGN,IAAI,CAACO,GAAL,CAAS,CAACF,oBAAoB,GAAG/C,WAAW,CAACoB,cAApC,IAAsD,IAA/D,CAAxB;AAEA,YAAM8B,KAAK,GAAGF,eAAe,GAAGF,QAAhC;AACA7D,cAAM,CAACiB,GAAP,CAAW,+BAA6BuB,IAA7B,GAAiC,QAAjC,GAA0CqB,QAA1C,GAAkD,MAAlD,GAAyDE,eAAzD,GAAwE,IAAxE,GAA6EE,KAA7E,GAAkF,GAA7F;AAEArB,aAAI,CAACC,aAAL,CAAmBL,IAAnB,EAAyBM,KAAzB,GAAiCiB,eAAjC;AACD,OAlBD;;AAoBA,UAAI,KAAKlB,aAAL,CAAmB,UAAnB,KAAkC,KAAKA,aAAL,CAAmB,KAAnB,CAAtC,EAAiE;AAC/D;AAEAU,mBAAW,CAACxC,WAAD,EAAc;AACvByC,qBAAW,EAAE,mBADU;AAEvBJ,sBAAY,EAAE,KAAKP,aAAL,CAAmB,UAAnB,EAA+BC,KAA/B,GAAuC7C,OAAO,CAAC,KAAK4C,aAAL,CAAmB,KAAnB,EAA0BC,KAA3B,CAFrC;AAGvBZ,YAAE,EAAE,YAHmB;AAIvBC,wBAAc,EAAE,KAAKU,aAAL,CAAmB,UAAnB,EAA+BC;AAJxB,SAAd,CAAX;AAMD;;AAED/B,iBAAW,CAACmD,eAAZ,CAA4B,KAAKrB,aAAjC;AACD;AACF,GAxIM;AA0IP;;;AACQ/B,+CAAR;AAAA;;AACEZ,UAAM,CAAC,kBAAM;AACX,UAAMuB,KAAK,GAAG0C,MAAM,CAACC,OAAP,CAAeC,GAAf,EAAd;;AAEA,UAAI,CAAC5C,KAAL,EAAY;AACV;AACD;;AAEDzB,YAAM,CAACiB,GAAP,CAAW,2BAAX;AACA2B,WAAI,CAACC,aAAL,CAAmB,KAAnB,IAA4B;AAAEC,aAAK,EAAEqB,MAAM,CAACrB;AAAhB,OAA5B;AACD,KATK,CAAN;AAUD,GAXO;AAaR;;;;;AAGQhC,qDAAR,UAAwBC,WAAxB,EAAgD;AAC9C,QAAMuD,SAAS,GAAG/D,MAAM,CAAC+D,SAAzB;;AAEA,QAAI,CAACA,SAAL,EAAgB;AACd;AACD,KAL6C,CAO9C;;;AAEA,QAAMC,UAAU,GAAGD,SAAS,CAACC,UAA7B;;AACA,QAAIA,UAAJ,EAAgB;AACd,UAAIA,UAAU,CAACC,aAAf,EAA8B;AAC5BzD,mBAAW,CAAC0D,MAAZ,CAAmB,yBAAnB,EAA8CF,UAAU,CAACC,aAAzD;AACD;;AAED,UAAID,UAAU,CAACG,IAAf,EAAqB;AACnB3D,mBAAW,CAAC0D,MAAZ,CAAmB,gBAAnB,EAAqCF,UAAU,CAACG,IAAhD;AACD;;AAED,UAAIC,kBAAkB,CAACJ,UAAU,CAACK,GAAZ,CAAtB,EAAwC;AACtC,aAAK/B,aAAL,CAAmB,gBAAnB,IAAuC;AAAEC,eAAK,EAAEyB,UAAU,CAACK;AAApB,SAAvC;AACD;;AAED,UAAID,kBAAkB,CAACJ,UAAU,CAACM,QAAZ,CAAtB,EAA6C;AAC3C,aAAKhC,aAAL,CAAmB,qBAAnB,IAA4C;AAAEC,eAAK,EAAEyB,UAAU,CAACM;AAApB,SAA5C;AACD;AACF;;AAED,QAAIF,kBAAkB,CAACL,SAAS,CAACQ,YAAX,CAAtB,EAAgD;AAC9C/D,iBAAW,CAAC0D,MAAZ,CAAmB,cAAnB,EAAmCM,MAAM,CAACT,SAAS,CAACQ,YAAX,CAAzC;AACD;;AAED,QAAIH,kBAAkB,CAACL,SAAS,CAACU,mBAAX,CAAtB,EAAuD;AACrDjE,iBAAW,CAAC0D,MAAZ,CAAmB,qBAAnB,EAA0CM,MAAM,CAACT,SAAS,CAACU,mBAAX,CAAhD;AACD;AACF,GAnCO;AAqCR;;;AACQlE,+CAAR;AAAA;;AACEV,UAAM,CAAC,kBAAM;AACX,UAAMqB,KAAK,GAAG0C,MAAM,CAACC,OAAP,CAAeC,GAAf,EAAd;;AAEA,UAAI,CAAC5C,KAAL,EAAY;AACV;AACD;;AAED,UAAMP,UAAU,GAAGjB,OAAO,CAACO,WAAW,CAACU,UAAb,CAA1B;AACA,UAAMc,SAAS,GAAG/B,OAAO,CAACwB,KAAK,CAACO,SAAP,CAAzB;AACAhC,YAAM,CAACiB,GAAP,CAAW,2BAAX;AACA2B,WAAI,CAACC,aAAL,CAAmB,KAAnB,IAA4B;AAAEC,aAAK,EAAEqB,MAAM,CAACrB;AAAhB,OAA5B;AACAF,WAAI,CAACC,aAAL,CAAmB,UAAnB,IAAiC;AAAEC,aAAK,EAAE5B,UAAU,GAAGc;AAAtB,OAAjC;AACD,KAZK,CAAN;AAaD,GAdO;AAgBR;;;AACQlB,+CAAR;AAAA;;AACEX,UAAM,CAAC,kBAAM;AACX,UAAMsB,KAAK,GAAG0C,MAAM,CAACC,OAAP,CAAeC,GAAf,EAAd;;AAEA,UAAI,CAAC5C,KAAL,EAAY;AACV;AACD;;AAED,UAAMP,UAAU,GAAGjB,OAAO,CAACO,WAAW,CAACU,UAAb,CAA1B;AACA,UAAMc,SAAS,GAAG/B,OAAO,CAACwB,KAAK,CAACO,SAAP,CAAzB;AACAhC,YAAM,CAACiB,GAAP,CAAW,2BAAX;AACA2B,WAAI,CAACC,aAAL,CAAmB,KAAnB,IAA4B;AAAEC,aAAK,EAAEqB,MAAM,CAACrB;AAAhB,OAA5B;AACAF,WAAI,CAACC,aAAL,CAAmB,UAAnB,IAAiC;AAAEC,aAAK,EAAE5B,UAAU,GAAGc;AAAtB,OAAjC;AACD,KAZK,CAAN;AAaD,GAdO;AAgBR;;;AACQlB,gDAAR;AAAA;;AACET,WAAO,CAAC,kBAAM;;;AACZ,UAAMoB,KAAK,GAAG0C,MAAM,CAACC,OAAP,CAAeC,GAAf,EAAd;;AAEA,UAAI,CAAC5C,KAAL,EAAY;AACV;AACD;;AAEDzB,YAAM,CAACiB,GAAP,CAAW,4BAAX;AACA2B,WAAI,CAACC,aAAL,CAAmB,MAAnB,IAA6B;AAAEC,aAAK,EAAEqB,MAAM,CAACrB;AAAhB,OAA7B,CARY,CAUZ;;AACA,UAAMmC,WAAW,GAAGd,MAAM,CAACrB,KAAP,GAAgB,MAACqB,MAAM,CAACC,OAAP,CAAe,CAAf,CAAD,EAAkBc,oCAAIzD,KAAtB,EAA6D0D,YAAjG;AACAvC,WAAI,CAACC,aAAL,CAAmB,kBAAnB,IAAyC;AAAEC,aAAK,EAAEmC;AAAT,OAAzC;AACD,KAbM,CAAP;AAcD,GAfO;;AAgBV;AAAC,CAtQD;;;AAwQA;;AACA,SAAS5C,kBAAT,CAA4BtB,WAA5B,EAAsDU,KAAtD,EAAkFP,UAAlF,EAAoG;AAClGkE,gCAA8B,CAACrE,WAAD,EAAcU,KAAd,EAAqB,aAArB,EAAoCP,UAApC,CAA9B;AACAkE,gCAA8B,CAACrE,WAAD,EAAcU,KAAd,EAAqB,UAArB,EAAiCP,UAAjC,CAA9B;AACAkE,gCAA8B,CAACrE,WAAD,EAAcU,KAAd,EAAqB,uBAArB,EAA8CP,UAA9C,CAA9B;AACAkE,gCAA8B,CAACrE,WAAD,EAAcU,KAAd,EAAqB,WAArB,EAAkCP,UAAlC,CAA9B;AACAkE,gCAA8B,CAACrE,WAAD,EAAcU,KAAd,EAAqB,SAArB,EAAgCP,UAAhC,CAA9B;AACAkE,gCAA8B,CAACrE,WAAD,EAAcU,KAAd,EAAqB,kBAArB,EAAyCP,UAAzC,EAAqD,YAArD,CAA9B;AACAkE,gCAA8B,CAACrE,WAAD,EAAcU,KAAd,EAAqB,OAArB,EAA8BP,UAA9B,EAA0C,mBAA1C,CAA9B;AACAkE,gCAA8B,CAACrE,WAAD,EAAcU,KAAd,EAAqB,cAArB,EAAqCP,UAArC,CAA9B;AACAmE,YAAU,CAACtE,WAAD,EAAcU,KAAd,EAAqBP,UAArB,CAAV;AACD;AAED;;;AACA,SAASoB,eAAT,CACEvB,WADF,EAEEU,KAFF,EAGEO,SAHF,EAIEC,QAJF,EAKEf,UALF,EAKoB;AAElB,MAAMoE,qBAAqB,GAAGpE,UAAU,GAAGc,SAA3C;AACA,MAAMuD,mBAAmB,GAAGD,qBAAqB,GAAGrD,QAApD;;AAEAsB,aAAW,CAACxC,WAAD,EAAc;AACvByC,eAAW,EAAE/B,KAAK,CAACe,IADI;AAEvBY,gBAAY,EAAEmC,mBAFS;AAGvBrD,MAAE,EAAET,KAAK,CAACW,SAHa;AAIvBD,kBAAc,EAAEmD;AAJO,GAAd,CAAX;;AAOA,SAAOA,qBAAP;AACD;AASD;;;AACA,OAAM,SAAUjC,gBAAV,CACJtC,WADI,EAEJU,KAFI,EAGJsB,YAHI,EAIJf,SAJI,EAKJC,QALI,EAMJf,UANI,EAMc;AAElB;AACA;AACA,MAAIO,KAAK,CAAC+D,aAAN,KAAwB,gBAAxB,IAA4C/D,KAAK,CAAC+D,aAAN,KAAwB,OAAxE,EAAiF;AAC/E,WAAOjD,SAAP;AACD;;AAED,MAAMkD,IAAI,GAAwB,EAAlC;;AACA,MAAI,kBAAkBhE,KAAtB,EAA6B;AAC3BgE,QAAI,CAAC,eAAD,CAAJ,GAAwBhE,KAAK,CAACiE,YAA9B;AACD;;AACD,MAAI,qBAAqBjE,KAAzB,EAAgC;AAC9BgE,QAAI,CAAC,mBAAD,CAAJ,GAA4BhE,KAAK,CAACkE,eAAlC;AACD;;AACD,MAAI,qBAAqBlE,KAAzB,EAAgC;AAC9BgE,QAAI,CAAC,mBAAD,CAAJ,GAA4BhE,KAAK,CAACmE,eAAlC;AACD;;AAED,MAAMzD,cAAc,GAAGjB,UAAU,GAAGc,SAApC;AACA,MAAMoB,YAAY,GAAGjB,cAAc,GAAGF,QAAtC;;AAEAsB,aAAW,CAACxC,WAAD,EAAc;AACvByC,eAAW,EAAET,YADU;AAEvBK,gBAAY,cAFW;AAGvBlB,MAAE,EAAET,KAAK,CAAC+D,aAAN,GAAsB,cAAY/D,KAAK,CAAC+D,aAAxC,GAA0D,UAHvC;AAIvBrD,kBAAc,gBAJS;AAKvBsD,QAAI;AALmB,GAAd,CAAX;;AAQA,SAAOrC,YAAP;AACD;AAED;;AACA,SAASgC,8BAAT,CACErE,WADF,EAEEU,KAFF,EAGEoE,KAHF,EAIE3E,UAJF,EAKE4E,QALF,EAKmB;AAEjB,MAAMC,GAAG,GAAGD,QAAQ,GAAIrE,KAAK,CAACqE,QAAD,CAAT,GAA8CrE,KAAK,CAAIoE,KAAK,QAAT,CAAvE;AACA,MAAMG,KAAK,GAAGvE,KAAK,CAAIoE,KAAK,UAAT,CAAnB;;AACA,MAAI,CAACG,KAAD,IAAU,CAACD,GAAf,EAAoB;AAClB;AACD;;AACDxC,aAAW,CAACxC,WAAD,EAAc;AACvBmB,MAAE,EAAE,SADmB;AAEvBsB,eAAW,EAAEqC,KAFU;AAGvB1D,kBAAc,EAAEjB,UAAU,GAAGjB,OAAO,CAAC+F,KAAD,CAHb;AAIvB5C,gBAAY,EAAElC,UAAU,GAAGjB,OAAO,CAAC8F,GAAD;AAJX,GAAd,CAAX;AAMD;AAED;;;AACA,SAASV,UAAT,CAAoBtE,WAApB,EAA8CU,KAA9C,EAA0EP,UAA1E,EAA4F;AAC1FqC,aAAW,CAACxC,WAAD,EAAc;AACvBmB,MAAE,EAAE,SADmB;AAEvBsB,eAAW,EAAE,SAFU;AAGvBrB,kBAAc,EAAEjB,UAAU,GAAGjB,OAAO,CAACwB,KAAK,CAAC0D,YAAP,CAHb;AAIvB/B,gBAAY,EAAElC,UAAU,GAAGjB,OAAO,CAACwB,KAAK,CAACwE,WAAP;AAJX,GAAd,CAAX;;AAOA1C,aAAW,CAACxC,WAAD,EAAc;AACvBmB,MAAE,EAAE,SADmB;AAEvBsB,eAAW,EAAE,UAFU;AAGvBrB,kBAAc,EAAEjB,UAAU,GAAGjB,OAAO,CAACwB,KAAK,CAACyE,aAAP,CAHb;AAIvB9C,gBAAY,EAAElC,UAAU,GAAGjB,OAAO,CAACwB,KAAK,CAACwE,WAAP;AAJX,GAAd,CAAX;AAMD;AAED;;;;;;;AAKA,OAAM,SAAU1C,WAAV,CAAsBxC,WAAtB,EAAgDmE,EAAhD,EAAuF;AAArC;AAAA,MAAgBiB,oCAAhB;;AACtD,MAAIhE,cAAc,IAAIpB,WAAW,CAACoB,cAAZ,GAA6BA,cAAnD,EAAmE;AACjEpB,eAAW,CAACoB,cAAZ,GAA6BA,cAA7B;AACD;;AAED,SAAOpB,WAAW,CAACqF,UAAZ,CAAsBC;AAC3BlE,kBAAc;AADa,KAExBgE,GAFwB,CAAtB,CAAP;AAID;AAED;;;;AAGA,SAASxB,kBAAT,CAA4B7B,KAA5B,EAAsC;AACpC,SAAO,OAAOA,KAAP,KAAiB,QAAjB,IAA6BwD,QAAQ,CAACxD,KAAD,CAA5C;AACD","names":["browserPerformanceTimeOrigin","getGlobalObject","logger","msToSec","getCLS","getFID","getLCP","getTTFB","getFirstHidden","global","performance","mark","_trackCLS","_trackLCP","_trackFID","_trackTTFB","MetricsInstrumentation","transaction","getEntries","log","timeOrigin","entryScriptSrc","document","i","scripts","length","dataset","entry","src","entryScriptStartTimestamp","tracingInitMarkStartTime","slice","_performanceCursor","forEach","startTime","duration","op","startTimestamp","entryType","addNavigationSpans","addMeasureSpans","undefined","name","firstHidden","shouldRecord","timeStamp","_this","_measurements","value","resourceName","replace","window","location","origin","endTimestamp","addResourceSpans","indexOf","_startChild","description","Math","max","_trackNavigator","timeOrigin_1","oldValue","measurementTimestamp","normalizedValue","abs","delta","setMeasurements","metric","entries","pop","navigator","connection","effectiveType","setTag","type","isMeasurementValue","rtt","downlink","deviceMemory","String","hardwareConcurrency","requestTime","_a","requestStart","addPerformanceNavigationTiming","addRequest","measureStartTimestamp","measureEndTimestamp","initiatorType","data","transferSize","encodedBodySize","decodedBodySize","event","eventEnd","end","start","responseEnd","responseStart","ctx","startChild","__assign","isFinite"],"sources":["/Users/huyangjinan/Columbia/Blockchain/FinalProject/ELEN6883-final-project/node_modules/@sentry/tracing/src/browser/metrics.ts"],"sourcesContent":["/* eslint-disable max-lines */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Measurements, SpanContext } from '@sentry/types';\nimport { browserPerformanceTimeOrigin, getGlobalObject, logger } from '@sentry/utils';\n\nimport { Span } from '../span';\nimport { Transaction } from '../transaction';\nimport { msToSec } from '../utils';\nimport { getCLS } from './web-vitals/getCLS';\nimport { getFID } from './web-vitals/getFID';\nimport { getLCP } from './web-vitals/getLCP';\nimport { getTTFB } from './web-vitals/getTTFB';\nimport { getFirstHidden } from './web-vitals/lib/getFirstHidden';\nimport { NavigatorDeviceMemory, NavigatorNetworkInformation } from './web-vitals/types';\n\nconst global = getGlobalObject<Window>();\n\n/** Class tracking metrics  */\nexport class MetricsInstrumentation {\n  private _measurements: Measurements = {};\n\n  private _performanceCursor: number = 0;\n\n  public constructor() {\n    if (global && global.performance) {\n      if (global.performance.mark) {\n        global.performance.mark('sentry-tracing-init');\n      }\n\n      this._trackCLS();\n      this._trackLCP();\n      this._trackFID();\n      this._trackTTFB();\n    }\n  }\n\n  /** Add performance related spans to a transaction */\n  public addPerformanceEntries(transaction: Transaction): void {\n    if (!global || !global.performance || !global.performance.getEntries || !browserPerformanceTimeOrigin) {\n      // Gatekeeper if performance API not available\n      return;\n    }\n\n    logger.log('[Tracing] Adding & adjusting spans using Performance API');\n\n    const timeOrigin = msToSec(browserPerformanceTimeOrigin);\n    let entryScriptSrc: string | undefined;\n\n    if (global.document) {\n      // eslint-disable-next-line @typescript-eslint/prefer-for-of\n      for (let i = 0; i < document.scripts.length; i++) {\n        // We go through all scripts on the page and look for 'data-entry'\n        // We remember the name and measure the time between this script finished loading and\n        // our mark 'sentry-tracing-init'\n        if (document.scripts[i].dataset.entry === 'true') {\n          entryScriptSrc = document.scripts[i].src;\n          break;\n        }\n      }\n    }\n\n    let entryScriptStartTimestamp: number | undefined;\n    let tracingInitMarkStartTime: number | undefined;\n\n    global.performance\n      .getEntries()\n      .slice(this._performanceCursor)\n      .forEach((entry: Record<string, any>) => {\n        const startTime = msToSec(entry.startTime as number);\n        const duration = msToSec(entry.duration as number);\n\n        if (transaction.op === 'navigation' && timeOrigin + startTime < transaction.startTimestamp) {\n          return;\n        }\n\n        switch (entry.entryType) {\n          case 'navigation':\n            addNavigationSpans(transaction, entry, timeOrigin);\n            break;\n          case 'mark':\n          case 'paint':\n          case 'measure': {\n            const startTimestamp = addMeasureSpans(transaction, entry, startTime, duration, timeOrigin);\n            if (tracingInitMarkStartTime === undefined && entry.name === 'sentry-tracing-init') {\n              tracingInitMarkStartTime = startTimestamp;\n            }\n\n            // capture web vitals\n\n            const firstHidden = getFirstHidden();\n            // Only report if the page wasn't hidden prior to the web vital.\n            const shouldRecord = entry.startTime < firstHidden.timeStamp;\n\n            if (entry.name === 'first-paint' && shouldRecord) {\n              logger.log('[Measurements] Adding FP');\n              this._measurements['fp'] = { value: entry.startTime };\n              this._measurements['mark.fp'] = { value: startTimestamp };\n            }\n\n            if (entry.name === 'first-contentful-paint' && shouldRecord) {\n              logger.log('[Measurements] Adding FCP');\n              this._measurements['fcp'] = { value: entry.startTime };\n              this._measurements['mark.fcp'] = { value: startTimestamp };\n            }\n\n            break;\n          }\n          case 'resource': {\n            const resourceName = (entry.name as string).replace(window.location.origin, '');\n            const endTimestamp = addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin);\n            // We remember the entry script end time to calculate the difference to the first init mark\n            if (entryScriptStartTimestamp === undefined && (entryScriptSrc || '').indexOf(resourceName) > -1) {\n              entryScriptStartTimestamp = endTimestamp;\n            }\n            break;\n          }\n          default:\n          // Ignore other entry types.\n        }\n      });\n\n    if (entryScriptStartTimestamp !== undefined && tracingInitMarkStartTime !== undefined) {\n      _startChild(transaction, {\n        description: 'evaluation',\n        endTimestamp: tracingInitMarkStartTime,\n        op: 'script',\n        startTimestamp: entryScriptStartTimestamp,\n      });\n    }\n\n    this._performanceCursor = Math.max(performance.getEntries().length - 1, 0);\n\n    this._trackNavigator(transaction);\n\n    // Measurements are only available for pageload transactions\n    if (transaction.op === 'pageload') {\n      // normalize applicable web vital values to be relative to transaction.startTimestamp\n\n      const timeOrigin = msToSec(browserPerformanceTimeOrigin);\n\n      ['fcp', 'fp', 'lcp', 'ttfb'].forEach(name => {\n        if (!this._measurements[name] || timeOrigin >= transaction.startTimestamp) {\n          return;\n        }\n\n        // The web vitals, fcp, fp, lcp, and ttfb, all measure relative to timeOrigin.\n        // Unfortunately, timeOrigin is not captured within the transaction span data, so these web vitals will need\n        // to be adjusted to be relative to transaction.startTimestamp.\n\n        const oldValue = this._measurements[name].value;\n        const measurementTimestamp = timeOrigin + msToSec(oldValue);\n        // normalizedValue should be in milliseconds\n        const normalizedValue = Math.abs((measurementTimestamp - transaction.startTimestamp) * 1000);\n\n        const delta = normalizedValue - oldValue;\n        logger.log(`[Measurements] Normalized ${name} from ${oldValue} to ${normalizedValue} (${delta})`);\n\n        this._measurements[name].value = normalizedValue;\n      });\n\n      if (this._measurements['mark.fid'] && this._measurements['fid']) {\n        // create span for FID\n\n        _startChild(transaction, {\n          description: 'first input delay',\n          endTimestamp: this._measurements['mark.fid'].value + msToSec(this._measurements['fid'].value),\n          op: 'web.vitals',\n          startTimestamp: this._measurements['mark.fid'].value,\n        });\n      }\n\n      transaction.setMeasurements(this._measurements);\n    }\n  }\n\n  /** Starts tracking the Cumulative Layout Shift on the current page. */\n  private _trackCLS(): void {\n    getCLS(metric => {\n      const entry = metric.entries.pop();\n\n      if (!entry) {\n        return;\n      }\n\n      logger.log('[Measurements] Adding CLS');\n      this._measurements['cls'] = { value: metric.value };\n    });\n  }\n\n  /**\n   * Capture the information of the user agent.\n   */\n  private _trackNavigator(transaction: Transaction): void {\n    const navigator = global.navigator as null | (Navigator & NavigatorNetworkInformation & NavigatorDeviceMemory);\n\n    if (!navigator) {\n      return;\n    }\n\n    // track network connectivity\n\n    const connection = navigator.connection;\n    if (connection) {\n      if (connection.effectiveType) {\n        transaction.setTag('effectiveConnectionType', connection.effectiveType);\n      }\n\n      if (connection.type) {\n        transaction.setTag('connectionType', connection.type);\n      }\n\n      if (isMeasurementValue(connection.rtt)) {\n        this._measurements['connection.rtt'] = { value: connection.rtt as number };\n      }\n\n      if (isMeasurementValue(connection.downlink)) {\n        this._measurements['connection.downlink'] = { value: connection.downlink as number };\n      }\n    }\n\n    if (isMeasurementValue(navigator.deviceMemory)) {\n      transaction.setTag('deviceMemory', String(navigator.deviceMemory));\n    }\n\n    if (isMeasurementValue(navigator.hardwareConcurrency)) {\n      transaction.setTag('hardwareConcurrency', String(navigator.hardwareConcurrency));\n    }\n  }\n\n  /** Starts tracking the Largest Contentful Paint on the current page. */\n  private _trackLCP(): void {\n    getLCP(metric => {\n      const entry = metric.entries.pop();\n\n      if (!entry) {\n        return;\n      }\n\n      const timeOrigin = msToSec(performance.timeOrigin);\n      const startTime = msToSec(entry.startTime as number);\n      logger.log('[Measurements] Adding LCP');\n      this._measurements['lcp'] = { value: metric.value };\n      this._measurements['mark.lcp'] = { value: timeOrigin + startTime };\n    });\n  }\n\n  /** Starts tracking the First Input Delay on the current page. */\n  private _trackFID(): void {\n    getFID(metric => {\n      const entry = metric.entries.pop();\n\n      if (!entry) {\n        return;\n      }\n\n      const timeOrigin = msToSec(performance.timeOrigin);\n      const startTime = msToSec(entry.startTime as number);\n      logger.log('[Measurements] Adding FID');\n      this._measurements['fid'] = { value: metric.value };\n      this._measurements['mark.fid'] = { value: timeOrigin + startTime };\n    });\n  }\n\n  /** Starts tracking the Time to First Byte on the current page. */\n  private _trackTTFB(): void {\n    getTTFB(metric => {\n      const entry = metric.entries.pop();\n\n      if (!entry) {\n        return;\n      }\n\n      logger.log('[Measurements] Adding TTFB');\n      this._measurements['ttfb'] = { value: metric.value };\n\n      // Capture the time spent making the request and receiving the first byte of the response\n      const requestTime = metric.value - ((metric.entries[0] ?? entry) as PerformanceNavigationTiming).requestStart;\n      this._measurements['ttfb.requestTime'] = { value: requestTime };\n    });\n  }\n}\n\n/** Instrument navigation entries */\nfunction addNavigationSpans(transaction: Transaction, entry: Record<string, any>, timeOrigin: number): void {\n  addPerformanceNavigationTiming(transaction, entry, 'unloadEvent', timeOrigin);\n  addPerformanceNavigationTiming(transaction, entry, 'redirect', timeOrigin);\n  addPerformanceNavigationTiming(transaction, entry, 'domContentLoadedEvent', timeOrigin);\n  addPerformanceNavigationTiming(transaction, entry, 'loadEvent', timeOrigin);\n  addPerformanceNavigationTiming(transaction, entry, 'connect', timeOrigin);\n  addPerformanceNavigationTiming(transaction, entry, 'secureConnection', timeOrigin, 'connectEnd');\n  addPerformanceNavigationTiming(transaction, entry, 'fetch', timeOrigin, 'domainLookupStart');\n  addPerformanceNavigationTiming(transaction, entry, 'domainLookup', timeOrigin);\n  addRequest(transaction, entry, timeOrigin);\n}\n\n/** Create measure related spans */\nfunction addMeasureSpans(\n  transaction: Transaction,\n  entry: Record<string, any>,\n  startTime: number,\n  duration: number,\n  timeOrigin: number,\n): number {\n  const measureStartTimestamp = timeOrigin + startTime;\n  const measureEndTimestamp = measureStartTimestamp + duration;\n\n  _startChild(transaction, {\n    description: entry.name as string,\n    endTimestamp: measureEndTimestamp,\n    op: entry.entryType as string,\n    startTimestamp: measureStartTimestamp,\n  });\n\n  return measureStartTimestamp;\n}\n\nexport interface ResourceEntry extends Record<string, unknown> {\n  initiatorType?: string;\n  transferSize?: number;\n  encodedBodySize?: number;\n  decodedBodySize?: number;\n}\n\n/** Create resource-related spans */\nexport function addResourceSpans(\n  transaction: Transaction,\n  entry: ResourceEntry,\n  resourceName: string,\n  startTime: number,\n  duration: number,\n  timeOrigin: number,\n): number | undefined {\n  // we already instrument based on fetch and xhr, so we don't need to\n  // duplicate spans here.\n  if (entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch') {\n    return undefined;\n  }\n\n  const data: Record<string, any> = {};\n  if ('transferSize' in entry) {\n    data['Transfer Size'] = entry.transferSize;\n  }\n  if ('encodedBodySize' in entry) {\n    data['Encoded Body Size'] = entry.encodedBodySize;\n  }\n  if ('decodedBodySize' in entry) {\n    data['Decoded Body Size'] = entry.decodedBodySize;\n  }\n\n  const startTimestamp = timeOrigin + startTime;\n  const endTimestamp = startTimestamp + duration;\n\n  _startChild(transaction, {\n    description: resourceName,\n    endTimestamp,\n    op: entry.initiatorType ? `resource.${entry.initiatorType}` : 'resource',\n    startTimestamp,\n    data,\n  });\n\n  return endTimestamp;\n}\n\n/** Create performance navigation related spans */\nfunction addPerformanceNavigationTiming(\n  transaction: Transaction,\n  entry: Record<string, any>,\n  event: string,\n  timeOrigin: number,\n  eventEnd?: string,\n): void {\n  const end = eventEnd ? (entry[eventEnd] as number | undefined) : (entry[`${event}End`] as number | undefined);\n  const start = entry[`${event}Start`] as number | undefined;\n  if (!start || !end) {\n    return;\n  }\n  _startChild(transaction, {\n    op: 'browser',\n    description: event,\n    startTimestamp: timeOrigin + msToSec(start),\n    endTimestamp: timeOrigin + msToSec(end),\n  });\n}\n\n/** Create request and response related spans */\nfunction addRequest(transaction: Transaction, entry: Record<string, any>, timeOrigin: number): void {\n  _startChild(transaction, {\n    op: 'browser',\n    description: 'request',\n    startTimestamp: timeOrigin + msToSec(entry.requestStart as number),\n    endTimestamp: timeOrigin + msToSec(entry.responseEnd as number),\n  });\n\n  _startChild(transaction, {\n    op: 'browser',\n    description: 'response',\n    startTimestamp: timeOrigin + msToSec(entry.responseStart as number),\n    endTimestamp: timeOrigin + msToSec(entry.responseEnd as number),\n  });\n}\n\n/**\n * Helper function to start child on transactions. This function will make sure that the transaction will\n * use the start timestamp of the created child span if it is earlier than the transactions actual\n * start timestamp.\n */\nexport function _startChild(transaction: Transaction, { startTimestamp, ...ctx }: SpanContext): Span {\n  if (startTimestamp && transaction.startTimestamp > startTimestamp) {\n    transaction.startTimestamp = startTimestamp;\n  }\n\n  return transaction.startChild({\n    startTimestamp,\n    ...ctx,\n  });\n}\n\n/**\n * Checks if a given value is a valid measurement value.\n */\nfunction isMeasurementValue(value: any): boolean {\n  return typeof value === 'number' && isFinite(value);\n}\n"]},"metadata":{},"sourceType":"module"}